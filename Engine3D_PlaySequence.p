unit	Engine3D_PlaySequence;	interfaceuses	types,	memory,	quickdraw,	icons,	Dream3Display_Tipi;const	KeyBackward =	1;	KeyLeftward =	2;	KeyRightward =	4;	KeyTurnLeft =	8;	KeyForward =	16;	KeyTurnRight =	32;		MaxStep =	1000;		PlaySequenceResType =	'PlyS';		PlaySequenceBaseSize =	16;		type	PlaySequence =	record						StartPosition :		point;						StartDirection :	integer;						CurrentStep :		integer;						TheNPC :			NPCPtr;						LastTick :			longint;						StepTicks :			integer;						StepN :				integer;						Step :				packed array [0..0] of byte;					end;	PlaySequencePtr =	^PlaySequence;	PlaySequenceHandle =	^PlaySequencePtr;	function GetPlaySequence (	Id :	integer) :	PlaySequenceHandle;procedure Engine3D_DisposeSequence (var TheSequence :	PlaySequenceHandle);function NewSequence (	ThePosition :	point;						TheDirection :	integer) :	PlaySequenceHandle;procedure RecordOneStep (	ThePlaySequence :			PlaySequenceHandle;							K2, K4, K6, K7, K8, K9 :	boolean);							procedure SaveSequence (Id :		integer;						TheSeq :	PlaySequenceHandle);						implementation{$R-}uses	resources,	segload,		Cilindro,	dreamtypes,	lowlevel,		Engine3D_Rotate;{	Engine3D_NPC;}	{$S Engine3D_PlaySequenceTools}function GetPlaySequence (	Id :	integer) :	PlaySequenceHandle;var	Tmp :	handle;	tmp2 :	PlaySequenceHandle;	begin	Tmp := mygetresource (PlaySequenceResType, Id, true, true);	if Tmp = nil then		DeathAlert (errMissingScenRes, 74);		tmp2 := PlaySequenceHandle (newhandle (gethandlesize (tmp)));	hlock (tmp);	hlock (handle (tmp2));	blockmovedata (tmp^, tmp2^, gethandlesize (tmp));	hunlock (handle (tmp2));	releaseresource (tmp);	GetPlaySequence := PlaySequenceHandle (tmp2);end;{$S Engine3D_PlaySequenceTools}procedure Engine3D_DisposeSequence (var TheSequence :	PlaySequenceHandle);begin	disposehandle (handle (TheSequence));end;{$S Engine3D_PlaySequenceTools}function NewSequence (	ThePosition :	point;						TheDirection :	integer) :	PlaySequenceHandle;var	Tmp :		PlaySequenceHandle;	TmpPtr :	PlaySequencePtr;	begin	Tmp := PlaySequenceHandle (newhandle (sizeof (PlaySequence) + 1023));	if tmp = nil then		deathalert (erroutofmemory, memerror);	hlock (handle (Tmp));	TmpPtr := Tmp^;	with TmpPtr^ do begin		StartPosition := ThePosition;		StartDirection := TheDirection;		CurrentStep := -1;		StepN := 0;	end;	hunlock (handle (Tmp));	NewSequence := Tmp;end;{$S Engine3D_PlaySequenceTools}procedure SaveSequence (Id :		integer;						TheSeq :	PlaySequenceHandle);						var	Tmp, Tmp2 :	handle;begin	hlock (handle (TheSeq));	Tmp := newhandle (sizeof (PlaySequence) + TheSeq^^.StepN - 1);	if tmp = nil then		deathalert (erroutofmemory, memerror);	hlock (Tmp);	blockmove (TheSeq^, Tmp^, sizeof (PlaySequence) + TheSeq^^.StepN - 1);	Tmp2 := mygetresource ('PlyS', Id, true, true);	if Tmp2 <> nil then begin		removeresource (Tmp2);		updateresfile (curresfile);		disposehandle (Tmp2);	end;	addresource (Tmp, 'PlyS', Id, '');	updateresfile (curresfile);	detachresource (Tmp);	disposehandle (Tmp);	hunlock (handle (TheSeq));end;{$S Engine3D_PlaySequenceTools}procedure RecordOneStep (	ThePlaySequence :			PlaySequenceHandle;							K2, K4, K6, K7, K8, K9 :	boolean);							var	ThePlay :	PlaySequencePtr;	TheStep :	byte;	begin	hlock (handle (ThePlaySequence));	ThePlay := ThePlaySequence^;	with ThePlay^ do begin		if K2 then			TheStep := KeyBackward		else			TheSTep := 0;		if K4 then			TheStep := TheStep + KeyLeftWard;		if K6 then			TheStep := TheStep + KeyRightWard;		if K7 then			TheStep := TheStep + KeyTurnLeft;		if K8 then			TheStep := TheStep + KeyForWard;		if K9 then			TheStep := TheStep + KeyTurnRight;		Step [StepN] := TheStep;		StepN := StepN + 1;	end;	hunlock (handle (ThePlaySequence));end;end.