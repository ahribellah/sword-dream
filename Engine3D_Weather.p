unit	Engine3D_Weather;interfaceuses	types,	quickdraw,	Dream3Display_Tipi,	Engine3D_Globals;type	WeatherResource =	record							FrameTicks :	integer;							FrameN :		integer;							FrameCIconId :	packed array [0..0] of integer;						end;	WeatherResourcePtr =	^WeatherResource;	WeatherResourceHandle =	^WeatherResourcePtr;procedure WeatherResource2Weather (	TheWeatherResource :													WeatherResourceHandle);function GetWeather (	Id :	integer) :	WeatherResourceHandle;procedure ShowWeather;procedure DisposeWeather;procedure Scape_Init;procedure Scape_Rflx1 (	Where :	point);implementationuses	fixmath,	toolutils,	windows,	qdoffscreen,	resources,	icons,	palettes,	AppleEvents,	AERegistry,		segload,	memory,		cilindro,	dreamtypes,	lowlevel,		Dream3Display_Tools,	Engine3D_CIconArray,	Engine3D_Roofs,	Engine3D_DrawXLine,	Engine3D_Rotate;const	MaxWeatherFrames =	10;	WeatherResType =	'Weat';	type		Weather =	record					FrameTicks :	integer;					LastTick :		longint;					FrameN :		integer;					CurrentFrame :	integer;					Frame :			array [0..MaxWeatherFrames - 1] of ptr;				end;	WeatherPtr =	^Weather;	WeatherHandle =	^WeatherPtr;			ScapeRecord =	record						ScapePalette :	ByteColorArray;						Rflx1Array :	array [0..50] of integer;					end;	ScapeRecordPtr =	^ScapeRecord;		var	EnvironmentWeather :	Weather;		ScapeGlobals :			ScapeRecordPtr;		{$S Engine3D_WeatherTools}function GetWeather (	Id :	integer) :	WeatherResourceHandle;var	Tmp :	handle;begin	Tmp := mygetresource (WeatherResType, Id, false, false);	if Tmp = nil then		deathalert (errmissingscenres, 0);	GetWeather := WeatherResourceHandle (Tmp);end;{$S Engine3D_WeatherTools}{$PUSH} {$R-}procedure WeatherResource2Weather (	TheWeatherResource :													WeatherResourceHandle);var	I :				integer;	TheWeatherPtr :	WeatherResourcePtr;	dummy :			boolean;	begin	hlock (handle (TheWeatherResource));	TheWeatherPtr := TheWeatherResource^;	with TheWeatherPtr^ do begin		EnvironmentWeather.FrameTicks := FrameTicks;		EnvironmentWeather.FrameN := FrameN;		EnvironmentWeather.LastTick := 0;		EnvironmentWeather.CurrentFrame := 0;		for I := 0 to FrameN do			EnvironmentWeather.Frame [I] := GetCIconOnPtr (FrameCIconId [I], true, dummy);	end;	releaseresource (handle (TheWeatherResource));end;{$POP}{$S Engine3D}procedure ShowWeather;var	I, J :		integer;	ThePtr :	ptr;	TheRect :	rect;	{$R-}begin	with EnvironmentWeather do begin		if TheTick > LastTick + FrameTicks then begin			LastTick := TheTick;			CurrentFrame := CurrentFrame + 1;			if CurrentFrame = FrameN + 1 then				CurrentFrame := 0;		end;		ThePtr := Frame [CurrentFrame];		for I := 4 downto 0 do			for J := 3 downto 0 do begin				with TheRect do begin					top := bsl (J, 6);					left := bsl (I, 6);					bottom := bsl (J + 1, 6);					right := bsl (I + 1, 6);				end;				FastPlotHCicon (ThePtr, TheRect);			end;	end;end;{$S Engine3D_WeatherTools}procedure DisposeWeather;var	I :	integer;	begin	with EnvironmentWeather do begin		for I := FrameN downto 0 do			disposeptr (Frame [I]);	end;end;procedure Scape_Init;procedure InitRflx1;var	I :	integer;	begin	ScapeGlobals^.ScapePalette := Array66^;	for I := 0 to 25 do		ScapeGlobals^.Rflx1Array [I] := round (25 * cos (I * 3.1415926 / 50));	for I := 26 to 50 do		ScapeGlobals^.Rflx1Array [I] := round (25 * cos ((50 - I) * 3.1415926 / 50));end;begin	ScapeGlobals := ScapeRecordPtr (newptr (sizeof (ScapeRecord)));	if ScapeGlobals = nil then;		InitRflx1;end;procedure Scape_Rflx1 (	Where :	point);type	byteptr =	^byte;	var	I, J :		longint;	TheAddr :	byteptr;	TheBaseAddr :	ptr;	LocalRow :	longint;	LocalArray :	ByteColorArray;	LocalI :	integer;begin	LocalRow := DstRow;	TheBaseAddr := ptr (longint (OffScreenAddr) + Where.h + Where.v * LocalRow);	LocalArray := ScapeGlobals^.ScapePalette;	for I := 0 to 50 do begin		LocalI := ScapeGlobals^.Rflx1Array [I];		TheAddr := byteptr (longint (TheBaseAddr) + LocalI);		for J := LocalI to 50 - LocalI do begin			TheAddr^ := LocalArray [TheAddr^];			TheAddr := byteptr (longint (TheAddr) + 1);		end;		TheBaseAddr := ptr (longint (TheBaseAddr) + LocalRow);	end;end;end.