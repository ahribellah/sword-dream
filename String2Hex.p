unit	String2Hex;interfaceuses	types,	QuickDraw,	TextUtils,	Memory,	HyperXCMD;{$MAIN}procedure Esegui (paramPtr: XCMDPtr);IMPLEMENTATION{$S Num2Hex}procedure Esegui (paramPtr: XCMDPtr);VAR	stringaPascal, risultatoHex, bufferHex: Str255;	ilNumero: Longint;	state, numLoop, i, len: Integer;begin	WITH paramPtr^ DO BEGIN		{ Converti }		state := HGetState (params[1]);		HLock (params[1]);		ZeroToPas (paramPtr, params[1]^, stringaPascal);		{ Rimetti la handle sorgente come l'hai trovata }		HSetState (params[1], state);		{ Converto la stringa, in forma Pascal binaria, a blocchi di 4 byte.		Eseguo volontariamente overshoot, convertendo più byte del dovuto.		Alla fine troncherò la stringa risultante, tenendo solo i nibble		veramente parte della stringa }		len := length (stringaPascal);		numLoop := len DIV 4;		FOR i := 0 TO numLoop DO BEGIN			BlockMoveData (@stringaPascal[i*4], @ilNumero, 4);			NumToHex (paramPtr, ilNumero, 8, bufferHex);			BlockMoveData (@bufferHex[1], @risultatoHex[1+i*8], 8);			END;		{ restituisci il risultato }		risultatoHex[0] := Chr ((len+1)*2); { Considera solo i byte significativi }		returnValue := PasToZero (paramPtr, risultatoHex)		END { with }end;end. { unit }