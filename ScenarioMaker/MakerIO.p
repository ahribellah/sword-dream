Unit MakerIO;(***GESTISCE	Open del menu file	Gli eventi Apple	***)	InterfaceUses	Types,	QuickDraw,	{ List 2 }	OSUtils,	QDOffscreen,	SegLoad,	{ List 3 - needs List 1/2 types }	Files;				{ needs OSUtils, SegLoad }PROCEDURE IOInit;{ Inizializza la unit }FUNCTION IOShutdown: BOOLEAN;FUNCTION DoLoadScenario (whichScenario: FSSpecPtr): boolean;PROCEDURE DoPageSetup;PROCEDURE DoPrintWindow;{ Implementano il meccanismo di stampa }ImplementationUses	Appearance,	AppleEvents,	Controls,	Errors,	Events,	Memory,	Navigation,	Resources,	TextEdit,	TextUtils,	Aliases,	AppleTalk,	Notification,	Processes,	Windows,	Dialogs,	Lists,	PPCToolBox,	StandardFile,	EPPC,	Printing,	Cilindro,	TaskMaster3,	BinIO,		SMErrors,	Windoid,	SMMenus,	SMResources,	SMDialogs;CONST	{ AppleEvents - Messages to InternalODOCPDOC via Refcon }	kOpenTheseRefcon = 0;	kPrintTheseRefcon = 1;TYPE	IoResult = (failedAbort, userCancel, failedRetry, failedContinue, allRight);VAR	{ Per la stampa }	gPrinterRecord: THPrint;{ print handle, maintained by printText }	gPrinterPort: TPPrPort; { pointer to Print Manager's GrafPort }{$S MkrProcs}   PROCEDURE DoPageSetup;            VAR         ignore: boolean;      BEGIN         PrOpen;         IF PrError = noErr THEN ignore := PrStlDialog(gPrinterRecord);         PrClose      END; { DoPageSetup }{$S MkrProcs}Procedure DoPrintWindow;CONST	kMargins = 40;VAR	rView: rect;		{ rect della pagina }	thePrinterStatus: TPrStatus;	{ printer status }	openPrintManager: boolean;		{ flag if print manager can be opened okay }	theWindow: WindowPtr;begin	theWindow := TMFrontWindow;	{ Trova la window da stampare. Ce n'è sempre una… }	{ Mostra la finestra di stampa }	 openPrintManager := false; {printer not open yet}	 IF gPrinterRecord <> NIL THEN BEGIN { do we have a legitimate record?}		PrOpen; {open my print record if okay}		IF PrJobDialog(gPrinterRecord) THEN BEGIN {bring up job dialog}		   gPrinterPort := PrOpenDoc(gPrinterRecord, NIL, NIL);		   openPrintManager := (PrError = noErr)		END { if }	 END; { if }	{ Preparati alla stampa aprendo il print grafport }	 IF openPrintManager THEN BEGIN		SetPort(GrafPtr(gPrinterPort)); { printer port is now the current										 port }		rView := gPrinterRecord^^.PrInfo.rPage; { get size of page rectangle }		InsetRect(rView, kMargins, kMargins); { adjust it for the margins }		PrOpenPage(gPrinterPort, NIL);		ClipRect(gPrinterRecord^^.PrInfo.rPage); { Open clipping so something will be drawn }			{ Chiama la sua defproc caratteristica }		SetPort (theWindow);		DrawWindow (theWindow);				{ Chiudi il print GrafPort }		PrClosePage(gPrinterPort); { close everything up }		PrCloseDoc(gPrinterPort);		IF (gPrinterRecord^^.prJob.bJDocLoop = bSpoolLoop) AND (PrError =               noErr) THEN               PrPicFile(gPrinterRecord, NIL, NIL, NIL, thePrinterStatus);		PrClose;		END; { If printing was non cancelled }end;{$S MkrProcs}FUNCTION MyGotRequiredParams (theAE: AppleEvent): OSErr;{ IM VI pag. 6-47 }VAR	returnType: DescType;	sz: Size;	err: OSErr;BEGIN	err := AEGetAttributePtr (theAE, keyMissedKeywordAttr, typeWildCard,		returnType, nil, 0, sz);	if err = errAEDescNotFound THEN		MyGotRequiredParams := noErr	ELSE IF err = noErr THEN		MyGotRequiredParams := errAEEventNotHandled	ELSE		MyGotRequiredParams := errEND;{$S MkrProcs}PROCEDURE MyNavigationCallbackProcedure (message: NavEventCallbackMessage,	callbackParms: NavCBRecPtr;	unusedID: NavCallBackUserData);BEGIN	{$UNUSED unusedID}	CASE message OF		kNavCBEvent: CASE callBackParms.eventData.event.what OF			updateEvt:			activateEvt:			END; { inner case }		END { outer case }END;{$S MkrProcs}FUNCTION MyGetFile: FSSpecPtr;CONST	kOpenResource = 'open';	kFileTypesResID = 128:VAR	myFileList: SFTypeList;	myReply: StandardFileReply;	myNavReply: NavReplyRecord;	openableList: NavTypeListHandle;	eventProc: NavEventUPP;	err: OSErr;BEGIN	IF NavServicesAvailable THEN BEGIN		eventProc := NewNavEventProc (MyNavigationCallbackProcedure);		openableList := NavTypeListHandle (Get1Resource (kOpenResource, kFileTypesResID));		err := NavGetFile (NIL,					{ AEDesc *defaultLocation, }			myNavReply,			NIL,										{ NavDialogOptions *dialogOptions, }			eventProc,			NIL,										{ NavPreviewUPP previewProc, }			NIL,										{ filterProc }			openableList,			0);										{ NavCallBackUserData callBackUD }		ReleaseResource (ResHandle (openableList));		DisposeRoutineDescriptor(eventProc);		END	ELSE BEGIN		{ Specify filetypes which I can read }		myFileList[0] := fileTypeScenario;		myFileList[1] := fileTypeScenario3D;		StandardGetFile (nil, 2, @myFileList, myReply);		whichScenario := @myReply.sfFile;	{ File found! }		result := myReply.sfGood;					END;END;{$S MkrProcs}FUNCTION DoLoadScenario (whichScenario: FSSpecPtr): boolean;var	result: BOOLEAN;begin	result := TRUE;						{ Supponiamo di riuscirci }			{ Did caller specify a scenario to be opened? }	IF whichScenario = NIL THEN BEGIN		{ No, so ask user }		whichScenario := MyGetFile;		result := (whichScenario <> NIL)	{ If user cancelled, then no hope }		END;			{ Do open it. }	IF result THEN BEGIN		{ Se ho un vecchio scenario da chiudere, chiudiamolo. }		IF currentScenario.resFork <> 0 THEN		{ Zero indica che non c'è scenario prec. }			Close (currentScenario);		{ Ricorda il file aperto. Serve per chiuderlo più tardi. }		ResetRByFSS (currentScenario, whichScenario^);		result := (currentScenario.errore = noErr);				IF result THEN			LoadScenarioInfo		ELSE			NewErrorAlert (kAlertStopAlert, errChooseAnother, currentScenario.errore);				END;	(*** Should check if I can write onto this ***)	DoLoadScenario := resultEND;{$S MkrProcs}FUNCTION IOShutdown: BOOLEAN;BEGIN		IOShutdown := TRUE;END;{$S MkrProcs}FUNCTION InternalOAPP (VAR theAE, reply: AppleEvent;	refCon: longint): OSErr;BEGIN	{$UNUSED theAE, reply, refCon}	InternalOAPP := noErr;END;{$S MkrProcs}FUNCTION InternalQUIT (VAR theAE, reply: AppleEvent;	refCon: longint): OSErr;BEGIN	{$UNUSED theAE, reply, refCon}	InternalQUIT := noErr;	gQuit := trueEND;{$S MkrProcs}FUNCTION InternalODOCPDOC (VAR theAE, reply: AppleEvent;	refCon: longint): OSErr;VAR	err: OSErr;	oneFSS: FSSpec;			{ FSS del file da aprire/stampare }	numFiles: longint;		{ Numero dei file da aprire/stampare }	docList: AEDescList;		{ lista linkata dei descrittori dei file }	kw: AEKeyword;				{ Returned from AEGetNthPtr }	typ: DescType;				{ Returned from AEGetNthPtr }	sz: Size;					{ Returned from AEGetNthPtr }BEGIN	{$UNUSED reply}	err := AEGetParamDesc (theAE, keyDirectObject, typeAEList, docList);	if err <> noErr then DeathAlert (0, err);	err := MyGotRequiredParams (theAE);	if err <> noErr then begin		NewErrorAlert (kAlertStopAlert, 0, err);		InternalODOCPDOC := err;		exit (InternalODOCPDOC)		END;	err := AECountItems (docList, numFiles);	if err <> noErr then DeathAlert (0, err);	{ Prendi comunque solo il primo }	err := AEGetNthPtr (docList, 1, typeFSS, kw, typ, @oneFSS, sizeof (oneFSS), sz);	if err <> noErr then DeathAlert (0, err);		{ Dispatch }	IF DoLoadScenario (@OneFSS) THEN BEGIN		LoadIcons;		ThereIsDocOpen;		IF (refCon = kPrintTheseRefcon) THEN			DoPrintWindow;		END;	err := AEDisposeDesc (docList);	if err <> noErr then DeathAlert (0, err);	InternalODOCPDOC := noErrEND;{$S UtilInit}PROCEDURE InstallOneHandler (eventClass, eventID: DescType;	routine: AEEventHandlerProcPtr;	refConToUse: Integer);VAR	myHandler: AEEventHandlerUPP;	err: OSErr;BEGIN	myHandler := NewAEEventHandlerProc (routine);	err := AEInstallEventHandler (eventClass, eventID, myHandler, refConToUse, FALSE);END;{$S UtilInit}PROCEDURE InitAEStuff;BEGIN	InstallOneHandler(kCoreEventClass, kAEOpenApplication,@InternalOAPP, 0);	InstallOneHandler(kCoreEventClass, kAEOpenDocuments,		@InternalODOCPDOC, kOpenTheseRefcon);	InstallOneHandler(kCoreEventClass, kAEPrintDocuments,		@InternalODOCPDOC, kPrintTheseRefcon);	InstallOneHandler(kCoreEventClass, kAEQuitApplication,		@InternalQUIT, 0);END;{$S UtilInit}PROCEDURE IOInit;BEGIN	{ Init motore di stampa }	gPrinterRecord := THPrint(NewHandle(SizeOF(TPrint))); {alloc print record}	IF gPrinterRecord <> NIL THEN BEGIN {if we're successful then setup the													 default settings}		PrOpen; {open the record }		PrintDefault(gPrinterRecord); { load in default settings }		PrClose { close it up }	END; { if }		{ Init eventi apple }	InitAEStuff;END;END. { Unit }