Unit SMResources;INTERFACEUSES	Types,	QuickDraw,	OSUtils,	SegLoad,	{ List 3 - needs List 1/2 types }	Files,				{ needs OSUtils, SegLoad }		BinIO,		SMDialogs;VAR	dreamDB: MyFile;PROCEDURE InitSMResources;{Low level cannon fodder }Function GetLongintFromRes (VAR scanner: Ptr): Longint;Function GetIntegerFromRes (VAR scanner: Ptr): integer;Function GetByteFromRes (VAR scanner: Ptr): byte;Function GetStringFromRes (VAR scanner: Ptr): String;Function GetWBFromRes (VAR scanner: Ptr): BitsInWord;Function GetBBFromRes (VAR scanner: Ptr): BitsInByte;PROCEDURE LoadScenarioInfo;{ Da chiamare all'atto del caricamento di uno scenario }PROCEDURE SaveScenarioInfo;{ Da chiamare subito prima di chiudere uno scenario }FUNCTION LoadBoxInfo (objID: Integer; VAR objName: Str255): rect;{ Restituisce un rettangolo, ridimensionato in pixel, atto a rappresentare un Box 3D }PROCEDURE LoadBoxList (listID: Integer);{ Carica nelle variabili globali tutti i dati su tutti i box 3D di questo place 3D }PROCEDURE SaveBoxList (listID: Integer); { Stessa cosa, ma per le fonti di luce }PROCEDURE LoadLightInfo (objID: Integer; VAR light: TBoxInfo);PROCEDURE LoadLightList (listID: Integer);PROCEDURE SaveLightList (listID: Integer); PROCEDURE SavePlaceResource;{ Da chiamare quando l'utente sceglie Save dal menu Places }{ Parametri impliciti: placeName, placeID, placW, placeH eccetera }{ Parametri impliciti: Connesso alla refcon 3 della main window si trova una struttura aggiuntiva con i valori al contorno }FUNCTION LoadPlaceResource (placeRef: Integer; plotIt: Boolean): Boolean;{ Carica nella struttura dati in memoria tutti i dati di un place.Se plotIt è TRUE, genera un offscreen GWorld con la mappa.Restituisce true se c'è riuscito. }PROCEDURE SaveArenaResource;FUNCTION LoadArenaResource (arenaRef: Integer; plotIt: Boolean): Boolean;{ Stessa cosa per le arene }PROCEDURE SaveTextResource (theTextWin: WindowPtr);PROCEDURE LoadTextResource;{ Stessa cosa per il testo - ma a molteplicità infinita }PROCEDURE CrunchPlaceIcons;FUNCTION ResourceIsMissing (theType: ResType; theID: Integer): Boolean;Function MyGetResource (resKind: ResType; ref: INTEGER;	isFatal: boolean; isScenario: boolean): Handle;IMPLEMENTATIONUSES	Appearance,	Controls,	Errors,	Events,	Fonts,	Icons,	Memory,	Menus,	Resources,	QDOffscreen,	TextEdit,	TextUtils,	Aliases,			{ (3.2) needs Memory }	Lists,				{ needs Controls, Memory }	Windows,			{ needs Events, Controls }	{ List 4 - needs List 1/2/3 types }	Dialogs,			{ needs TextEdit, Windows }	StandardFile,		{ (3.2) needs Aliases }		Cilindro,	Lista3,	TaskMaster3,		SMErrors,	Windoid,	SMMenus;CONST	resPlace = 'Plac';	resArena = 'Aren';	resIconInfo = 'SMkr';	res3DMap = 'SqMp';	res3DEnv = '3DEn';	kIconInfoID = 128;	kMaxPlacesInScenario = 100;TYPE	BBPtr = ^BitsInByte;	WBPtr = ^BitsInWord;(********************** Funzioni di basso livello per LETTURA ***********************){$S MkrProcs}Function MyGetResource (resKind: ResType; ref: INTEGER;	isFatal: boolean; isScenario: boolean): Handle;LABEL	999;VAR	myHandle: handle;	itsSize: Longint;	myErr: INTEGER;BEGIN	{ Is there memory enough to load this resource? }	SetResLoad (FALSE);	{ Load essential data only from disk }	IF isScenario THEN		myHandle := Get1Resource (resKind, ref)	{ Quicker }	ELSE		myHandle := GetResource (resKind, ref);	{ Did we find anything? }	myErr := ResError;	{ Tell resource manager that we are finished doodling }	SetResLoad (TRUE);	{ Check error conditions }	IF (myHandle = NIL) & isFatal THEN		{ errMissingApplRes viene subito prima di errMissingScenRes }		DeathAlert (errMissingApplRes + ORD (isScenario), ResError);	itsSize := GetMaxResourceSize (myHandle);	IF (itsSize > FreeMem - 32767) | (itsSize > MaxBlock) THEN		IF isFatal THEN			DeathAlert (errOutOfMemory, 0)		ELSE BEGIN			NewErrorAlert (kAlertStopAlert, errScenarioTooBig, 0);			Goto 999			END;	IF (myErr <> noErr) THEN		DeathAlert (errScenarioDamaged, myErr);	{ Everything is OK. Do load the data, lock them, then exit }	LoadResource (myHandle);	HLock (myHandle);999:MyGetResource := myHandleEND;{$S MkrProcs}FUNCTION ResourceKindExists (theType: ResType;	VAR idOfResFound: Integer): Boolean;VAR	myHandle: handle;	numEntities: Integer;	result: Boolean;	dummy: Str255;BEGIN	numEntities := Count1Resources(theType);	result := (numEntities > 0);	IF result THEN BEGIN		SetResLoad (FALSE);		myHandle := Get1IndResource(theType,1);		SetResLoad (TRUE);		GetResInfo(myHandle,idOfResFound,theType,dummy);		ReleaseResource (myHandle)		END;	ResourceKindExists := resultEND;{$S MkrProcs}FUNCTION ResourceIsMissing (theType: ResType; theID: Integer): Boolean;VAR	myHandle: handle;	myErr: INTEGER;BEGIN	IF (theID = 0) | ((theID = 10000) & (theType = 'Obj ')) THEN		{ Zero indicates "no reference. As such, we ignore it.		10000 means "impossible to have. }		ResourceIsMissing := FALSE	ELSE BEGIN		SetResLoad (FALSE);		{ Load essential data only }		myHandle := GetResource (theType, theID);		{ Did we find anything? }		myErr := ResError;		{ Tell resource manager that we are finished doodling }		SetResLoad (TRUE);		{ Check error conditions }		ResourceIsMissing := (myHandle = NIL) OR (myErr <> noErr);		ReleaseResource (myHandle)		ENDEND;{$S MkrProcs}Function GetLongintFromRes (VAR scanner: Ptr): Longint;TYPE	LongintPtr = ^Longint;BEGIN	GetLongintFromRes := LongintPtr (scanner)^;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (Longint))END;{$S MkrProcs}Function GetIntegerFromRes (VAR scanner: Ptr): integer;BEGIN	GetIntegerFromRes := IntegerPtr (scanner)^;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (integer))END;{$S MkrProcs}Function GetByteFromRes (VAR scanner: Ptr): byte;VAR	result: Byte;BEGIN	{$R-}	result := scanner^;	IF result >= 0 THEN		GetByteFromRes := result	ELSE		GetByteFromRes := 256 + result;	scanner := Ptr (ord4 (StripAddress(scanner)) + 1) { sizeof (Byte) RESTITUISCE 2!!! }	{$R+}END;{$S MkrProcs}Function GetStringFromRes (VAR scanner: Ptr): String;VAR	temp: String;	length: Integer;BEGIN	length := GetByteFromRes(scanner);	temp[0] := chr (length);	BlockMoveData (scanner, @temp[1], length);	scanner := Ptr (ORD4 (StripAddress(scanner)) + length);	GetStringFromRes := tempEND;{$S MkrProcs}Function GetWBFromRes (VAR scanner: Ptr): BitsInWord;BEGIN	GetWBFromRes := WBPtr (scanner)^;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (BitsInWord))END;{$S MkrProcs}Function GetBBFromRes (VAR scanner: Ptr): BitsInByte;BEGIN	GetBBFromRes := BBPtr (scanner)^;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (BitsInByte))END;(******************* Funzioni di basso livello per SCRITTURA *******************){$S MkrProcs}PROCEDURE PutIntegerIntoRes (i: INTEGER; VAR scanner: Ptr);BEGIN	IntegerPtr(scanner)^:= i;	scanner := Ptr (Ord4 (StripAddress(scanner)) + sizeof (integer))END;{$S MkrProcs}PROCEDURE PutByteIntoRes (b: Byte; VAR scanner: Ptr);BEGIN	{$R-}	scanner^:= b;	scanner := Ptr (Ord4 (StripAddress(scanner)) + 1)	{$R+}END;{$S MkrProcs}PROCEDURE PutStringIntoRes (s: String; VAR scanner: Ptr);VAR	len: Integer;BEGIN	len := length(s)+1;	BlockMoveData (@s, scanner, len);	scanner := Ptr (ORD4 (StripAddress(scanner)) + len);END;{$S MkrProcs}PROCEDURE PutWBIntoRes (w: BitsInWord; VAR scanner: Ptr);BEGIN	WBPtr(scanner)^:= w;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (BitsInWord))END;{$S MkrProcs}PROCEDURE PutBBIntoRes (b: BitsInByte; VAR scanner: Ptr);BEGIN	BBPtr(scanner)^:= b;	scanner := Ptr (ord4 (StripAddress(scanner)) + sizeof (BitsInByte))END;(******************* Manipolazioni di coordinate *************)PROCEDURE DblPoint2Pixel (VAR r: rect);BEGIN	WITH r DO BEGIN		left := Round ((left + 10) * 32 / 20);		right := Round ((right + 10) * 32 / 20);		bottom := (placeH * 32) - Round ((bottom - 10) * 32 / 20);		top := (placeH * 32) - Round ((top - 10) * 32 / 20);		ENDEND;FUNCTION Pixel2DBlPoint (r: rect): rect;VAR	result: Rect;BEGIN	WITH result DO BEGIN		left := Round (r.left * 20 / 32) - 10;		right := Round (r.right * 20 / 32) - 10;		bottom := (placeH * 20) + 10 - Round (r.bottom * 20 / 32);		top := (placeH * 20) + 10 - Round (r.top * 20 / 32);		END;	Pixel2DBlPoint := resultEND;(********************** User interface ***********************){$S UtilInit}PROCEDURE InitSMResources;BEGIN	{ Segnala che il Dream DB file non è ancora stato trovato }	dreamDB.resFork := 0END;{$MkrProcs}PROCEDURE LoadScenarioInfo;VAR	iHandle: IconAttrHdl;	i: Integer;BEGIN	{ Try to read the icon status from the scenario }	iHandle := IconAttrHdl (MyGetResource (resIconInfo, kIconInfoID, FALSE, TRUE));	IF iHandle <> NIL THEN BEGIN		{ Found. Put the data in place }		iconIsImpassable := iHandle^^;		ReleaseResource (Handle(iHandle))		END	ELSE		{ reset all icon chars }		FOR i := kFirstIcon TO kLastIcon DO			iconIsImpassable[i] := FALSE;END;{$MkrProcs}PROCEDURE SaveScenarioInfo;VAR	iHandle: IconAttrHdl;	err: OSErr;BEGIN	IF iconStateWasChanged THEN BEGIN		iHandle := IconAttrHdl(NewHandle (SizeOf (IconAttr)));		err := PtrToHand (@iconIsImpassable, Handle(iHandle), SizeOf (IconAttr));		WriteRes (currentScenario, kIconInfoID, resIconInfo, 'ScenarioMaker', Handle(iHandle));		ReleaseResource (Handle(iHandle))		END;END;{$S MkrProcs}PROCEDURE SaveArenaResource;{ Formato della risorsa: stringa pascal con il nome, due byte di preambolo con ledimensioni x e y della mappa, locazioni. Per la versione 2.1 e seguenti: tre byte a zero, Pstring del nome, x, y, pict e spare (integer), locazioni }CONST	kPreambleLength = 12;	{ Byte nel preambolo + 1 length byte della pstring }VAR	saveArenaHandle: Handle;	scanner: Ptr;	x,	dim: INTEGER;	fakeResource: Handle;	err: OSErr;	replacing: Boolean;BEGIN	saveArenaHandle := NewHandle (length (ArenaName) + kPreambleLength +					SizeOf (ArenaLocation) * ArenaX * ArenaY);	IF saveArenaHandle = NIL THEN		DeathAlert (errOutOfMemory, 0);	{ Stipa i dati nella risorsa }	HLock (saveArenaHandle);	scanner := saveArenaHandle^;	IF arenaPict = 0 THEN BEGIN		{ Usa il vecchio formato }		PutStringIntoRes (arenaName, scanner);		PutByteIntoRes (arenaX, scanner);		PutByteIntoRes (arenaY, scanner);		END	ELSE BEGIN { Usa il formato 2.1 }		PutIntegerIntoRes (0, scanner);		PutByteIntoRes (0, scanner);		PutStringIntoRes (arenaName, scanner);		PutIntegerIntoRes (arenaX, scanner);		PutIntegerIntoRes (arenaY, scanner);		PutIntegerIntoRes (arenaPict, scanner);		PutIntegerIntoRes (0, scanner); { Spare }		END;	dim := Sizeof (ArenaLocation) * arenaY; { Dimensione di una colonna di arena locs }	for x := 1 to arenaX DO BEGIN		BlockMoveData (@arena[x, 1], scanner, dim);		scanner := Ptr (ORD4 (StripAddress(scanner)) + dim)		END;	{ Salva nel file }	{ 1. Se c'era già una risorsa con questo ID, cancellala }	SetResLoad (FALSE);	fakeResource := Get1Resource (resArena, arenaID);	SetResLoad (TRUE);	IF fakeResource <> NIL THEN BEGIN		RemoveResource (fakeResource);		err := ResError;		IF err <> noErr THEN			DeathAlert (errScenarioDamaged, err);		DisposeHandle (fakeResource);		replacing := TRUE		END	ELSE		replacing := FALSE;	{ 2. Metti questa risorsa nel file }	AddResource (saveArenaHandle, resArena, arenaID, arenaName);	err := ResError;	CASE err OF		noErr:;		dskFulErr: BEGIN			NewErrorAlert (kAlertStopAlert, errDiskIsFull, err);			Exit (SaveArenaResource);			END;		OTHERWISE			DeathAlert (errScenarioDamaged, err);		END;	{ Grazie e arrivederci }	ReleaseResource (saveArenaHandle);	gDirty := FALSE;	err := ResError;	IF err <> noErr THEN		DeathAlert (errScenarioDamaged, err);END;{$S MkrProcs}FUNCTION LoadArenaResource (arenaRef: Integer; plotIt: Boolean): Boolean;VAR	myArenaResource: Handle;	x, dim:	Integer;	scanner: Ptr;	result: Boolean;{$UNUSED plotIt}BEGIN	IF arenaRef = 0 THEN		result := FALSE	ELSE BEGIN		result := TRUE;		{ Load Arena res }		myArenaResource := MyGetResource (resArena, arenaRef, FALSE, TRUE);		IF myArenaResource = NIL THEN BEGIN			NewErrorAlert (kAlertStopAlert, errMissingScenRes, arenaRef);			LoadArenaResource := FALSE;			Exit (LoadArenaResource)			END;				{ Scan Arena }		scanner := StripAddress(myArenaResource^);		{ Start reading }		arenaName := GetStringFromRes (scanner);		arenaX := GetByteFromRes (scanner);		arenaY := GetByteFromRes (scanner);				IF arenaY = 0 THEN BEGIN { Arena formato 2.1 - new for DR5 }			arenaName := GetStringFromRes (scanner);			arenaX := GetIntegerFromRes (scanner);			arenaY := GetIntegerFromRes (scanner);			arenaPict := GetIntegerFromRes (scanner);			x := GetIntegerFromRes (scanner); { spare }			END;		{ E ora la mappa }		dim := Sizeof (ArenaLocation) * arenaY; { Dimensione di una colonna di arena locs }		for x := 1 to arenaX DO BEGIN			BlockMoveData (scanner, @arena[x, 1], dim);			scanner := Ptr (ORD4 (StripAddress(scanner)) + dim)			END;		{ Di questa me ne libero, perché è grossa e non servirà più }		ReleaseResource (myArenaResource);		arenaID := arenaRef;		displayingArena := TRUE;	END; { if loading was OK }	LoadArenaResource := resultEND; { LoadArenaResource }{$S MkrProcs}PROCEDURE SavePlaceResource;{ Formato della risorsa Plac: stringa pascal con il nome, sedici byte di preambolo,numero di locazioni nella mappa (byte), locazioni.Formato della risorsa SqMp (mappa degli ambienti 3D): rettangolo con dimensioni,elenco di SqEl.Formato della risorsa 3DEn: arbitrariamente complicato e assurdo. So solo dovesi trovino i 4 campi significativi, e così ne carico un esemplare precotto e ficcodentro a forza i valori che desidero in quei campi }CONST	kPreambleLength = 18;	{ Byte nel preambolo + 1 length byte della pstring +							1 byte per numero locazioni }VAR	savePlaceHandle: Handle;	scanner: Ptr;	x, y: INTEGER;	err: OSErr;	r: rect;		PROCEDURE Save3DPlaceData;	CONST		rGeneric3DEn = 128;	VAR		data: ThreeDHandle;		saveSqMpHandle, threeDEnvironmentHandle: Handle;		sentinel: Integer;		x, y, zero, icon, maxHeightInFloors: INTEGER;				PROCEDURE InsertDataInto3DEn (data, offset: Integer);		BEGIN			scanner := threeDEnvironmentHandle^;			scanner := Ptr (Ord4 (scanner) + offset);			PutIntegerIntoRes (data, scanner);		END;	BEGIN		zero := 0;		{ SqMp - mappa del luogo }		saveSqMpHandle := NewHandle (SizeOf (Rect) + placeW * placeH * SizeOf (Integer));		scanner := saveSqMpHandle^;		{ Size is first }		SetRect (r, 1, 1, placeW, placeH);		BlockMove (@r, scanner, SizeOf (r));		scanner := Ptr (ORD4 (StripAddress(scanner)) + Sizeof (r));		{ SqMp array }		maxHeightInFloors := 0;	{ zero based per semplicità. Aggiungo 1 in fondo }		FOR x := 1 TO placeW DO			FOR y := 1 TO placeH DO BEGIN				icon := placeMap^[x, y].icon;				IF icon MOD 20 = 0 THEN					BlockMoveData (@zero, scanner, Sizeof (Integer))				ELSE BEGIN					BlockMoveData (@icon, scanner, Sizeof (Integer));					{ mentre salvi, calcola l'altezza del più alto edificio }					icon := icon MOD 100;					IF (icon < 60) & (icon DIV 20 > maxHeightInFloors) THEN						maxHeightInFloors := icon DIV 20;					END;				scanner := Ptr (ORD4 (StripAddress(scanner)) + Sizeof (Integer))				END;		{ Salva nel file }		WriteRes (currentScenario, placeID, res3DMap, placeName, saveSqMpHandle);		CASE currentScenario.errore OF			noErr:;			dskFulErr: BEGIN				NewErrorAlert (kAlertStopAlert, errDiskIsFull, currentScenario.errore);				Exit (SavePlaceResource);				END;			OTHERWISE				DeathAlert (errScenarioDamaged, currentScenario.errore);			END;		{ Grazie e arrivederci }		ReleaseResource (saveSqMpHandle);		err := ResError;		IF err <> noErr THEN			DeathAlert (errScenarioDamaged, err);					{ 3DEn - specifiche del luogo }				{ Prendi un esemplare generico da dentro Scenario Maker }		threeDEnvironmentHandle := MyGetResource (res3DEnv, rGeneric3DEn, TRUE, FALSE);		DetachResource (threeDEnvironmentHandle);		{ Infilaci il riferimento alla SqMp. ScenarioMaker assegna sempre lo stesso ID		a tutti i membri della tripletta Place-3D Environment-Square map }		InsertDataInto3DEn (placeID, kOffsetToID);		{ Dimensioni del place }		InsertDataInto3DEn (placeW, kOffsetToX);		InsertDataInto3DEn (placeH, kOffsetToY);		InsertDataInto3DEn (maxHeightInFloors+1, kOffsetToHeight);		{ recupera i dati aggiuntivi specificati tramite la info bar }		data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));		{ Background e weather }		InsertDataInto3DEn (data^^.weather, kOffsetToWeather);		InsertDataInto3DEn (data^^.background, kOffsetToBG);		{ Pavimento  e soffitto }		InsertDataInto3DEn (data^^.floor, kOffsetToFloor);		InsertDataInto3DEn (data^^.roof, kOffsetToRoof);		sentinel := 0;		IF data^^.floor <> 0 THEN sentinel := BOr (sentinel, $8000);		IF data^^.roof <> 0 THEN sentinel := BOr (sentinel, $0080);		InsertDataInto3DEn (sentinel, kOffsetToSentinel);		{ Luce ambientale }		IF placeData [4] THEN BEGIN	{ Underground }			InsertDataInto3DEn (0, kOffsetToAmbientLight);	{ No ambient light }			InsertDataInto3DEn (700, kOffsetToMaxLight);			InsertDataInto3DEn (1000, kOffsetToMedLight);			InsertDataInto3DEn (1500, kOffsetToMinLight);			END		ELSE IF morePlaceData[15] THEN BEGIN { Indoors }			InsertDataInto3DEn (1, kOffsetToAmbientLight);	{ Low ambient light }			InsertDataInto3DEn (750, kOffsetToMaxLight);			InsertDataInto3DEn (1500, kOffsetToMedLight);			InsertDataInto3DEn (2250, kOffsetToMinLight);		END ELSE BEGIN { Outdoors }			InsertDataInto3DEn (3, kOffsetToAmbientLight);	{ Very high ambient light }			InsertDataInto3DEn (MAXINT, kOffsetToMaxLight);			InsertDataInto3DEn (MAXINT, kOffsetToMedLight);			InsertDataInto3DEn (MAXINT, kOffsetToMinLight);			END;		{ More data - new for DR4 }		InsertDataInto3DEn (data^^.startX, kOffsetToStartX);		InsertDataInto3DEn (data^^.startY, kOffsetToStartY);		InsertDataInto3DEn (data^^.startAngle, kOffsetToStartAngle);		{ Ficcalo nello scenario }		WriteRes (currentScenario, placeID, res3DEnv, placeName, threeDEnvironmentHandle);		CASE currentScenario.errore OF			noErr:;			dskFulErr: BEGIN				NewErrorAlert (kAlertStopAlert, errDiskIsFull, currentScenario.errore);				Exit (SavePlaceResource);				END;			OTHERWISE				DeathAlert (errScenarioDamaged, currentScenario.errore);			END;		{ Grazie e arrivederci }		ReleaseResource (threeDEnvironmentHandle);		err := ResError;		IF err <> noErr THEN			DeathAlert (errScenarioDamaged, err);	END;	BEGIN	{ Init variabili }	savePlaceHandle := NewHandle (length (placeName) + kPreambleLength +					SizeOf (MapLocation) * placeW * placeH);	IF savePlaceHandle = NIL THEN		DeathAlert (errOutOfMemory, 0);	{ Stipa i dati nella risorsa }	HLock (savePlaceHandle);	scanner := savePlaceHandle^;	PutStringIntoRes (placeName, scanner);	PutIntegerIntoRes (placeW, scanner);	PutIntegerIntoRes (placeH, scanner);	{ Per motivi storici, l'identificativo di uno special place si trova in placeTime }	IF placeData [2] THEN		PutIntegerIntoRes (ord(placeKind), scanner)	ELSE		PutIntegerIntoRes (placeTime, scanner);	PutIntegerIntoRes (placeTEXTin, scanner);	PutIntegerIntoRes (placeTEXTout, scanner);	PutIntegerIntoRes (placePICTin, scanner);	PutIntegerIntoRes (placeViewPict, scanner);	PutBBIntoRes (placeData, scanner);	PutWBIntoRes (morePlaceData, scanner);	{ New for v 1.4 }	FOR y := 1 TO placeH DO		FOR x := 1 TO placeW DO BEGIN			BlockMoveData (@placeMap^[x, y], scanner, Sizeof (MapLocation));			scanner := Ptr (ORD4 (StripAddress(scanner)) + Sizeof (MapLocation))			END;	{ Salva nel file }	WriteRes (currentScenario, placeID, resPlace, placeName, savePlaceHandle);	CASE currentScenario.errore OF		noErr:;		dskFulErr: BEGIN			NewErrorAlert (kAlertStopAlert, errDiskIsFull, currentScenario.errore);			Exit (SavePlaceResource);			END;		OTHERWISE			DeathAlert (errScenarioDamaged, currentScenario.errore);		END;	{ Grazie e arrivederci }	ReleaseResource (savePlaceHandle);	gDirty := FALSE;	err := ResError;	IF err <> noErr THEN		DeathAlert (errScenarioDamaged, err);			IF placeKind = threeD THEN BEGIN		{ New for 3D DR1 - Sqmp }		Save3DPlaceData;		{ New for DR5 - BoxL }		SaveBoxList (placeID);		{ New for DR6 - Light sources }		SaveLightList (placeID);		END;END;{$S MkrProcs}FUNCTION LoadPlaceResource (placeRef: Integer; plotIt: Boolean): Boolean;VAR	myPlaceResource: Handle;	x, y:	Integer;	scanner: Ptr;	result: Boolean;		PROCEDURE Load3DPlaceData;	VAR		data: ThreeDHandle;		threeDEnvironmentHandle: Handle;		correctWeatherItem: Integer;		theControl : ControlHandle;		FUNCTION FetchDataFrom3DEn (offset: Integer): Integer;		{ Gotcha: must not move memory }		VAR			scanner: Ptr;		BEGIN			scanner := threeDEnvironmentHandle^;			scanner := Ptr (Ord4 (scanner) + offset);			FetchDataFrom3DEn := GetIntegerFromRes (scanner);		END;	BEGIN		{ I luoghi 3D creati prima di SM3D non usano le icone speciali (900-999)		Avviso l'utente della peculiarità }		IF (placeMap^[1, 1].icon > 999) AND plotIt { bug fix DR6 } THEN			NewErrorAlert (kAlertCautionAlert, errPeculiar3DPlace, 0);		ThreeDTools (TRUE); { Questo istanzia la ThreeDHandle }		{ Recupero le informazioni sul luogo 3D salvate in precedenza }		data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));		threeDEnvironmentHandle := MyGetResource (res3DEnv, placeRef, FALSE, TRUE);		IF myPlaceResource = NIL THEN BEGIN			NewErrorAlert (kAlertCautionAlert, errMissing3DEn, placeRef);			{ The default values for the 3d place will have to do }			Exit (Load3DPlaceData)			END;		{ Leggo dal 3DEn i dati al contorno (sfondo etc) }		data^^.startX := FetchDataFrom3DEn (kOffsetToStartX);		data^^.startY := FetchDataFrom3DEn (kOffsetToStartY);		data^^.startAngle := FetchDataFrom3DEn (kOffsetToStartAngle);		data^^.background := FetchDataFrom3DEn (kOffsetToBG);		data^^.floor := FetchDataFrom3DEn (kOffsetToFloor);		data^^.roof := FetchDataFrom3DEn (kOffsetToRoof);		data^^.weather := FetchDataFrom3DEn (kOffsetToWeather);		{ Setta correttamente il visual del popup }		CASE data^^.weather OF			0: correctWeatherItem := 1;			kRainyWeather: correctWeatherItem := 2;			kSnowyWeather: correctWeatherItem := 3;			OTHERWISE correctWeatherItem := 4;			END;		theControl := ControlHandle (TMGetWRefCon (mainWindow, 4));		SetControlValue (theControl, correctWeatherItem);		{ Tutto il resto era calcolato da SM3D e lo sarà di nuovo se le modifiche vengono salvate }		{ Grazie e arrivederci }		ReleaseResource (threeDEnvironmentHandle)	END;	BEGIN	IF placeRef = 0 THEN		result := FALSE	ELSE BEGIN		result := TRUE;		{ Load place res }		myPlaceResource := MyGetResource (resPlace, placeRef, FALSE, TRUE);		IF myPlaceResource = NIL THEN BEGIN			NewErrorAlert (kAlertStopAlert, errMissingScenRes, placeRef);			LoadPlaceResource := FALSE;			Exit (LoadPlaceResource)			END;					{ Allocate memory for map }		IF placeMap <> NIL THEN			DeathAlert (0, 666);		placeMap := MapPtr (NewPtr (SizeOf (Map)));		IF placeMap = NIL THEN			DeathAlert (errOutOfMemory, 666);				{ Scan place }		scanner := myPlaceResource^;		{ Start reading }		placeName := GetStringFromRes (scanner);		placeW := GetIntegerFromRes (scanner);		placeH := GetIntegerFromRes (scanner);		placeTime := GetIntegerFromRes (scanner);		placeTEXTIn := GetIntegerFromRes (scanner);		placeTEXTout := GetIntegerFromRes (scanner);		placePICTin := GetIntegerFromRes (scanner);		placeViewPict := GetIntegerFromRes (scanner);		placeData := GetBBFromRes (scanner);		placeID := placeRef;		morePlaceData := GetWBFromRes (scanner);		{ Nella v 1.0 qui stava width*height-1. Puliamo }		FOR x := 14 DOWNTO 0 DO			morePlaceData[x] := FALSE;		{ E ora la mappa }		FOR y := 1 TO placeH DO			FOR x := 1 TO placeW DO BEGIN				BlockMoveData (scanner, @placeMap^[x, y], Sizeof (MapLocation));				{ Questo serve perché una beta non azzerava il bit "già conosciuto" }				placeMap^[x, y].characteristics[0] := FALSE;				scanner := Ptr (ORD4 (StripAddress(scanner)) + Sizeof (MapLocation))				END;		{ Di questa me ne libero, perché è grossa e non servirà più }		ReleaseResource (myPlaceResource);				{ Se è un posto speciale, normalizziamo le variabili }		IF placeData [2] THEN BEGIN			{ Per risparmiare spazio (e per motivi storici), nel caso di posti speciali			trovo dati aggiuntivi in placeTime. Quindi… }			placeKind := SpecialPlace (placeTime);			placeTime := 1;			END		ELSE IF placeData[3] THEN			{ is shop }			placeKind := Shop		ELSE			placeKind := Standard;				IF placeKind = threeD THEN			Load3DPlaceData;				IF plotIt THEN			result := PlotPlaceGWorld;				END; { if loading was OK }	LoadPlaceResource := resultEND; { LoadPlaceResource }{$S MkrProcs}PROCEDURE SaveTextResource (theTextWin: WindowPtr);VAR	itsExclusiveID: Integer;	itsName: Str255;BEGIN	itsExclusiveID := TMGetWRefCon (theTextWin, kRefconForID);	GetWTitle (theTextWin, itsName);	TMSaveTextToRes (theTextWin, itsExclusiveID, itsName);	TMDisposeWindow (theTextWin);END;{$S MkrProcs}PROCEDURE LoadTextResource;VAR	chosenID: Integer;	textName: Str255;	dummyHandle: Handle;	dummyType: ResType;	TEXTWindow: WindowPtr;BEGIN	chosenID := LoadWhat (rChooseTextStr, 0, 'TEXT');	IF chosenID <> 0 THEN BEGIN		{ Crea nuova finestra… }		TEXTWindow := GetNewCWindow(rTextWindowPrototype+ord(gHasThemes)*1000, nil, nil);		if TEXTWindow = nil then			DeathAlert (errMissingApplRes, resNotFound);		TMNewWindow (TEXTWindow,			fContainsTextEdit+fGrow+fRScroll+fInfoBar,			chosenID,				{ ref con }			12, 300,			1024, 640,			200, 300,			12, 48, 0, 0, 			20,										{ Info bar height }			DrawPopUpMenus, NIL);		{ Trova il nome risorsa }		SetResLoad (FALSE);		dummyHandle := Get1Resource('TEXT', chosenID);		SetResLoad (TRUE);		GetResInfo(dummyHandle, chosenID, dummyType, textName);		ReleaseResource (dummyHandle);		{ Salva il nome risorsa }		SetWTitle (TEXTWindow, textName);		{ Salva lo ID risorsa }		TMSetWRefCon (TEXTWindow, kRefconForID, chosenID);		{ Crea i menu a scomparsa per il text editing }		InitPopUpMenus (TEXTWindow);		{ Infilaci dentro il testo e lo stile }		TMLoadTextFromRes (TEXTWindow, chosenID);		ShowWindow (TEXTWindow);		TMSelectWindow (TEXTWindow);		END;END;{$S MkrProcs}FUNCTION LoadBoxInfo (objID: Integer; VAR objName: Str255): rect;VAR	myBoxResource: Handle;	dummyType: ResType;	scanner: Ptr;	result: Rect;BEGIN	myBoxResource := MyGetResource (res3DObject, objID, TRUE, TRUE);	scanner := myBoxResource^;	{ Trova il nome risorsa }	GetResInfo (myBoxResource, objID, dummyType, objName);	{ Carico il rect e lo trasformo da coordinate DblPt a pixel }	WITH result DO BEGIN		bottom := GetIntegerFromRes (scanner);		left := GetIntegerFromRes (scanner);		top := GetIntegerFromRes (scanner);		right := GetIntegerFromRes (scanner);		{ Spostamento a topleft zero (utile con box creati fuori da MMM) }		OffsetRect (result, -result.left, -result.top);		{ Trasformazione DblPt in pixel }		right := Round (right * 32 / 20);		bottom := Round (bottom * 32 / 20);		END;	ReleaseResource (myBoxResource);	LoadBoxInfo := resultEND;{$S MkrProcs}PROCEDURE LoadLightInfo (objID: Integer; VAR light: TBoxInfo);VAR	myLightResource: Handle;	dummyType: ResType;	scanner: Ptr;	dummy, widthCode, width, padding: Integer;	objName: Str255;BEGIN	WITH light DO BEGIN		boxID := objID; { As a courtesy to the caller }				myLightResource := MyGetResource (res3DLight, objID, TRUE, TRUE);		scanner := myLightResource^;		{ Trova il nome risorsa }		GetResInfo (myLightResource, objID, dummyType, objName);		BlockMove (@objName, @boxName, SizeOf (boxName));		IF length (objName) > SizeOf (boxName) THEN			boxName[0] := Chr (SizeOf (boxName)-1);		{ Calcolo il rect }		dummy := GetIntegerFromRes (scanner); { ID, inutile }		widthCode := GetIntegerFromRes (scanner); { width, in fractions of 20 double points }		width := 32 DIV widthCode;		padding := (32 - width) DIV 2;  { spazio da aggiungere a sx }		dummy := GetIntegerFromRes (scanner); { animation }		dummy := GetIntegerFromRes (scanner); { reserved }		WITH boxPos DO BEGIN			bottom := 32;			left := padding;			top := 0;			right := padding + width;			END;		{ Prendo l'icona }		iconID := GetIntegerFromRes (scanner); { reserved }		ReleaseResource (myLightResource)		END { with }END;{$S MkrProcs}PROCEDURE LoadBoxList (listID: Integer);VAR	boxlHandle: handle;	scanner: Ptr;	formatVersion, i: Integer;	dummy: rect;	buffer: Str255;BEGIN	WITH g3DBoxesHere DO BEGIN		boxlHandle := MyGetResource (res3DBoxList, listID, FALSE, TRUE);		IF boxlHandle = NIL THEN			numBoxes := 0		ELSE BEGIN { boxes found }			scanner := boxlHandle^;			formatVersion := GetIntegerFromRes (scanner);			IF formatVersion <> 1 THEN BEGIN				NewErrorAlert (kAlertNoteAlert, errBoxlWrongFormat, formatVersion);				numBoxes := 0				END			ELSE BEGIN { Ok, good format, go ahead }				numBoxes := 1 + GetIntegerFromRes (scanner); { Zero based on disk }				FOR i := 1 TO numBoxes DO WITH boxes [i] DO BEGIN					boxID := GetIntegerFromRes (scanner);					WITH boxPos DO BEGIN						{ Coordinate DblPt}						top := GetIntegerFromRes (scanner);						left := GetIntegerFromRes (scanner);						bottom := GetIntegerFromRes (scanner);						right := GetIntegerFromRes (scanner);						END; { rect }					{  -> Pixel.  }					DblPoint2Pixel (boxPos);					{ Nome }					dummy := LoadBoxInfo (boxID, buffer);					BlockMove (@buffer, @boxName, SizeOf (boxName));					IF length (buffer) > 31 THEN boxName[0] := chr (31);					END { for each box }				END; { good format, do load }			ReleaseResource (boxlHandle)			END { boxes found }		END { with }END;{$S MkrProcs}PROCEDURE SaveBoxList (listID: Integer);CONST	kBoxLHeaderSize = 4; { Versione + Number of boxes }VAR	saveBoxLHandle: Handle;	scanner: Ptr;	i: Integer;	rectInDblPoint: rect;BEGIN	WITH g3DBoxesHere DO BEGIN		IF numBoxes = 0 THEN EXIT (SaveBoxList); { Side effect: if there were boxes, and now there are none, the old BoxL stays }		saveBoxLHandle := NewHandle (kBoxLHeaderSize + SizeOf (TBoxInfo) * numBoxes);		IF saveBoxLHandle = NIL THEN			DeathAlert (errOutOfMemory, 0);		HLock (saveBoxLHandle);		scanner := saveBoxLHandle^;		{ Stipa i dati nella risorsa }		PutIntegerIntoRes (1, scanner); { Versione del formato }		PutIntegerIntoRes (numBoxes-1, scanner); { zero based on disk }		FOR i := 1 TO numBoxes DO WITH boxes[I] DO BEGIN			PutIntegerIntoRes (boxID, scanner); { res Id della risorsa Box associata }			rectInDblPoint := Pixel2DBlPoint (boxPos); { Pixel -> DblPoint }			WITH rectInDblPoint DO BEGIN				PutIntegerIntoRes (top, scanner);				PutIntegerIntoRes (left, scanner);				PutIntegerIntoRes (bottom, scanner);				PutIntegerIntoRes (right, scanner);				END { rect del box }			END { for boxes }		END; { with }	WriteRes (currentScenario, listID, res3DBoxList, placeName, saveBoxLHandle);	IF currentScenario.errore = noErr THEN		ReleaseResource (saveBoxLHandle)	ELSE		DisposeHandle (saveBoxLHandle)END;{$S MkrProcs}PROCEDURE LoadLightList (listID: Integer);VAR	boxlHandle: handle;	scanner: Ptr;	i, reserved, x, y: Integer;BEGIN	WITH g3DLightsHere DO BEGIN		boxlHandle := MyGetResource (res3DLightsList, listID, FALSE, TRUE);		IF boxlHandle = NIL THEN			numBoxes := 0		ELSE BEGIN { boxes found }			scanner := boxlHandle^;			reserved := GetIntegerFromRes (scanner);			numBoxes := 1 + GetIntegerFromRes (scanner); { Zero based on disk }			FOR i := 1 TO numBoxes DO WITH boxes [i] DO BEGIN				{ Load data from list }				y := GetIntegerFromRes (scanner);				x := GetIntegerFromRes (scanner);				boxID := GetIntegerFromRes (scanner);				reserved := GetIntegerFromRes (scanner);				{ Load data from resource }				LoadLightInfo (boxID, boxes [i]);				{ LoadLightInfo mi dà le coordinate locali. Spostalo a destinazione }				OffsetRect (boxPos, BSL (x, 5)-32, BSL (y, 5)-32);				END; { for each box }			ReleaseResource (boxlHandle)			END { boxes found }		END { with }END;{$S MkrProcs}PROCEDURE SaveLightList (listID: Integer);CONST	kBoxLHeaderSize = 4; { reserved + Number of boxes }VAR	saveBoxLHandle: Handle;	scanner: Ptr;	i: Integer;	rectInDblPoint: rect;BEGIN	WITH g3DLightsHere DO BEGIN		IF numBoxes = 0 THEN EXIT (SaveLightList); { Side effect: if there were boxes, and now there are none, the old BoxL stays }		saveBoxLHandle := NewHandle (kBoxLHeaderSize + SizeOf (TBoxInfo) * numBoxes);		IF saveBoxLHandle = NIL THEN			DeathAlert (errOutOfMemory, 0);		HLock (saveBoxLHandle);		scanner := saveBoxLHandle^;		{ Stipa i dati nella risorsa }		PutIntegerIntoRes (0, scanner);		PutIntegerIntoRes (numBoxes-1, scanner); { zero based on disk }		FOR i := 1 TO numBoxes DO WITH boxes[I] DO BEGIN			WITH rectInDblPoint DO BEGIN				PutIntegerIntoRes (top DIV 32 + 1, scanner);				PutIntegerIntoRes (left DIV 32 + 1, scanner);				END; { rect del box }			PutIntegerIntoRes (boxID, scanner); { res Id della risorsa SqOb associata }			PutIntegerIntoRes (0, scanner);		{ reserved }			END { for boxes }		END; { with }	WriteRes (currentScenario, listID, res3DLightsList, placeName, saveBoxLHandle);	IF currentScenario.errore = noErr THEN		ReleaseResource (saveBoxLHandle)	ELSE		DisposeHandle (saveBoxLHandle)END;{$S MkrProcs}PROCEDURE CrunchPlaceIcons;VAR	searchLoop, goodID, idOfResFound: Integer;	myHandle: handle;	{ If ICN# exists, its handle is here }	theType: ResType;	resName, dummy: Str255;	FUNCTION ResourceExists (kind: ResType): Boolean;	{ Checks existence, and puts handle inside myHandle }	VAR		myErr: INTEGER;	BEGIN		myHandle := GetResource (kind, searchLoop);		{ Did we find anything? }		myErr := ResError;		{ Check error conditions }		ResourceExists := (myHandle <> NIL) AND (myErr = noErr);	END;BEGIN	{ Load essential data only }	SetResLoad (FALSE);	goodID := 999;	FOR searchLoop := 1000 TO 1999 DO BEGIN		{ Esiste una icona numero searchLoop? }		IF ResourceExists ('ICN#') THEN BEGIN			goodID := goodID+1;			{ Se si, va cambiata di numero? }			IF searchLoop <> goodID THEN BEGIN				{ OK, comincia a spostare lei stessa }				GetResInfo(myHandle,idOfResFound,theType,resName);				SetResInfo(myHandle,goodID,resName);				ReleaseResource (myHandle);				{ Se ci sono icl4 e icl8, cambia anche queste }				IF ResourceExists ('icl4') THEN BEGIN					GetResInfo(myHandle,idOfResFound,theType,dummy);					SetResInfo(myHandle,goodID,resName);					ReleaseResource (myHandle)					END;				IF ResourceExists ('icl8') THEN BEGIN					GetResInfo(myHandle,idOfResFound,theType,dummy);					SetResInfo(myHandle,goodID,resName);					ReleaseResource (myHandle)					END;				END { if ID must be changed }			ELSE				{ No need to change ID. Get rid of resource }				ReleaseResource (myHandle)			END; { If resource exists }		END; { Loop }	{ Tell resource manager that we are finished doodling }	SetResLoad (TRUE);	{ Update windoid }	RadiusPivotEND;END.