Unit Windoid;InterfaceUses	Types,	QuickDraw,		{ List 2 - only require List 1 types }	Memory,	{ List 3 }	Aliases,			{ (3.2) needs Memory }	{ List 4 }	StandardFile,		{ (3.2) needs Aliases }	BinIO;CONST	{ Icons for places }	kFirstIcon = 1000;	kLastIcon = 9999;	{ File signatures }	fileTypeScenario = 'ADSc';	fileTypeScenario3D = 'AD3D';	fileTypeCreator = 'Drim';TYPE	IconAttrHdl = ^IconAttrPtr;	IconAttrPtr = ^IconAttr;	IconAttr = PACKED ARRAY [kFirstIcon..kLastIcon] OF Boolean;	ThreeDHandle = ^ThreeDPtr;	ThreeDPtr = ^ThreeDPlaceAttributes;	ThreeDPlaceAttributes = RECORD		startX, startY, startAngle,		floor, roof, background, weather: Integer;		END;	SpecialPlace = (Temple, Shop, Bar, Brothel,		Bank, MageTower, Shrine, Prison,		Standard,		ThreeD {New for v2,0}		);VAR	{ Scenario che viene editato (serve a GrabIcons) }	currentScenario: MyFile;	{ File dello scenario. Salvato da SMMain,								Usato in SaveScenarioInfo }	{ "memoria" di quali icone rappresentano un ostacolo e quali	rappresentano un posto di transito. Mantenuta da	Load/SaveScenarioInfo }	iconIsImpassable: IconAttr;	iconStateWasChanged,	{ True se viene fatto doppio clic su una o più icone }	displayingPlace,	displayingArena,	gStructure: BOOLEAN;	{ True se mostro la struttura anziché le icone }	placeKind: SpecialPlace;PROCEDURE WindoidInit;{ Inizializza la unit, carica il windoid.}PROCEDURE LoadIcons;{ Da chiamare quando si apre un nuovo scenario }PROCEDURE ThreeDTools (on: BOOLEAN);{ Da chiamare quando si ativano o disattivano gli strumenti per lavoraresu un luogo 3D (cioè quando si apre un luogo 3D, lo si chiude, lo si cambiada 2D a 3D o viceversa) }PROCEDURE ResetWindoid;{ Da chiamare quando lo scenario si chiude }PROCEDURE SelectIcon (clickPoint: Point); { Da chiamare in risposta a un click sul windoid }PROCEDURE SelectMaterial (clickPoint: Point); { Da chiamare in risposta a un click sul windoid dei materiali }PROCEDURE PlotOneIcon (x, y, icon: Integer; win: WindowPtr);{ Procedura chiamata internamente dal windoid per disegnare una icona.Gestisce le icone speciali usate per i luoghi 3D. Pubblicata dimodo che possa venire usata anche dal codice che gestisce la finestraprincipale }FUNCTION GetSelectedIconID: INTEGER;{ Restituisce lo ID della icona selezionata, o zero se nessuna icona è selezionata }PROCEDURE RedrawSelectedIcon;{ Ridisegna l'icona selezionata. Da chiamare quando è stato cambiato il suo attributoiconIsAImpassable }PROCEDURE ShowHideStructure;{ Da chiamare quando lo stato di "structure" va invertito. Modifica la globalegStructure e aggiorna il windoid }PROCEDURE GrabIcons;{ Ruba a un altro scenario le sue icone e le inserisce in quello corrente }PROCEDURE RadiusPivot;{ Ricalcola il numero di icone che ci stanno in una colonna, e ridimensiona ilwindoid. Da chiamare quando il pivot viene ruotato. }Procedure CursorInit;Procedure CursorAnimate;ImplementationUses	Appearance,	Controls,	Events,	Icons,	LowMem,	Menus,	QuickDrawText,	Resources,	Script,	Windows,	Cilindro,	TaskMaster3,		SMErrors;CONST	{ Icons for 3D }	kFirst3DIcon = 900;	kLast3DIcon = 999;	{ Square elements for 3D }	kFirstMaterial = 600;	rWindoid = 129; 	{ WIND del windoid }	rMaterials = 130;{ All'interno di ogni windoid:	refcon 1: riservato al main	refcon 2: numero di icone per riga (numero di colonne)	refcon 3: numero dell'icona selzionata, one based (zero per "nessuna")	refcon 4: numero di icone complessivo}	kRefconIconsPerRow = 2;	kRefconSelectedIcon = 3;	kRefconNumIcons = 4;VAR	myWindoid,			{ la finestra windoid delle icone }	myMaterials : WindowPtr;{------------------------------------------------------}{ Codice di basso livello per la gestione del cursore  }{------------------------------------------------------}const	rFirstCursor = 989;	rLastCursor = 996;var	animatedCursor: integer;	theTick: longint;{$S MkrProcs}Procedure CursorInit;var	c: CCrsrHandle;begin	theTick := TickCount;	animatedCursor := rFirstCursor;	c := GetCCursor (animatedCursor);	SetCCursor (c)end;{$S MkrProcs}Procedure CursorAnimate;var	c: CCrsrHandle;	now: longint;begin	now := TickCount;	if theTick + 20 < now then begin		if animatedCursor = rLastCursor then			animatedCursor := rFirstCursor		else			animatedCursor := animatedCursor + 1;		c := GetCCursor (animatedCursor);		SetCCursor (c);		theTick := now		endend;{$S MkrProcs}FUNCTION Serial2BoundsRect (num: INTEGER; w: WindowPtr): Rect;{ Trasforma il numero seriale di una icona nel rettangolo che la contiene }VAR	r: Rect;	iconsPerRow: Integer;BEGIN	iconsPerRow := TMGetWRefCon (w, kRefconIconsPerRow);	num := pred (num);	{ Porta nel raggio 0..numIcons-1 }	WITH r DO BEGIN		left := (num MOD iconsPerRow) * 33 + 1;		top := (num DIV iconsPerRow) * 33 + 1;		right := left + 32;		bottom := top + 32		END; { with }	Serial2BoundsRect := rEND;PROCEDURE InternalRedrawOneIcon (whichWindow: WindowPtr; whichIcon: Integer);{ Chiamato internamente quando va ridisegnata una icona in un windoid per qualsiasimotivo. Garantisce il corretto ridisegno del rettangolo di selezione.GOTCHA: cambia il port corrente }VAR	result: Rect;BEGIN	SetPort (whichWindow);	result := Serial2BoundsRect (whichIcon, whichWindow);	InsetRect (result, -1, -1); { Includi il bordo di selezione }		{ Garantisci la sparizione del bordo di selezione }	ForeColor (whiteColor);	FrameRect (result);	ForeColor (blackColor);		TMInvalRect (result)END;{$S MkrProcs}FUNCTION Serial2ID (num: INTEGER; w: WindowPtr): INTEGER;{ trasforma un numero seriale (1..numIcons) nel resID dell'icona }BEGIN	IF w = myWindoid THEN		IF placeKind = threeD THEN			Serial2ID := num+kFirst3DIcon-1		ELSE			Serial2ID := num+kFirstIcon-1	ELSE IF w = myMaterials THEN		Serial2ID := kFirstMaterial + (num-1) * 100;END;{$S MkrProcs}FUNCTION Point2Serial (p: Point; w: WindowPtr): INTEGER;{ Trasforma un punto del windoid nel numero della icona che vi si trova.Restituisce zero se non c'è alcuna icona lì }VAR	result: INTEGER;	iconsPerRow, numIcons: Integer;BEGIN	iconsPerRow := TMGetWRefCon (w, kRefconIconsPerRow);	numIcons := TMGetWRefCon (w, kRefconNumIcons);	{ Trova le coordinate topleft del rettangolo contenente }	p.v := p.v DIV 33;	p.h := p.h DIV 33;	{ Calcola }	result := p.h + p.v * iconsPerRow + 1;	IF (placeKind <> threeD) AND (result > numIcons) THEN		Point2Serial := 0	ELSE		Point2Serial := resultEND;{$S MkrProcs}PROCEDURE ShowHideStructure;VAR	hostPort: GrafPtr;BEGIN	GetPort (hostPort);	{ Non dovrebbe servire }	gStructure := NOT gStructure;	SetPort (myWindoid);	InvalRect (myWindoid^.portRect);	SetPort (hostPort)END;{$S MkrProcs}PROCEDURE PlotOneIcon (x, y, icon: Integer; win: WindowPtr);VAR	xp, yp, iconToPlot, height: Integer;	r: Rect;BEGIN	IF win = myWindoid THEN BEGIN		xp := x * 33;	{ lascia il bordo }		yp := y * 33;		END	ELSE BEGIN		xp := BSL (x, 5);		yp := BSL (y, 5);		END;	SetRect(r,xp-32,yp-32,xp,yp);	{ Disegna l'icona. Nel caso di luogo 3D, inserisci anche l'altezza }	IF displayingPlace & (placeKind = threeD) THEN BEGIN		{ Tutte le icone 3D di forma xxyy sono mappate sulle icone 9yy.		Le icone 0..19 si ripetono nelle icone 20..39 e 40..59, usate per		indicare una altezza superiore }		iconToPlot := icon MOD 100;		height := iconToPlot DIV 20 + 1; { Quanti piani rappresenta l'icona? }		IF iconToPlot < 60 THEN iconToPlot := iconToPlot MOD 20;		iconToPlot := iconToPlot + kFirst3DIcon;		{ esegui plotting }		IF icon <> 0 THEN BEGIN			IF PlotIconID (r, atNone, ttNone, iconToPlot) <> noErr THEN				FillRect (r, qd.ltGray);			{ Aggiungi numerillo per il piano }			IF (height < 4) AND (iconToPlot MOD 20 <> 0) THEN BEGIN	{ Scrivi l'altezza in piani }				MoveTo (r.left + 2, r.top + 9);				DrawChar (Chr (Ord ('0') + height))				END {height should be seen }			END { icon <> 0 }		END { three d }	ELSE		IF PlotIconID (r, atNone, ttNone, icon) <> noErr THEN			FillRect (r, qd.ltGray);END;{$S DefProcs}PROCEDURE DrawMaterials (myWin: WindowPtr);{ defProc del windoid dei materiali }VAR	selectedIcon,	numMaterials,	idToDraw, i: Integer;	r: Rect;	grandeHandle: CIconHandle;BEGIN	selectedIcon := TMGetWRefCon (myWin, kRefconSelectedIcon);	numMaterials := TMGetWRefCon (myWin, kRefconNumIcons);	idToDraw := kFirstMaterial;	FOR i := 1 TO numMaterials DO BEGIN		r := Serial2BoundsRect (i, myWin);		grandeHandle := GetCIcon (idToDraw);		IF grandeHandle <> NIL THEN BEGIN			PlotCicon (r, grandeHandle);			DisposeCicon (grandeHandle);			END		ELSE FillRect (r, qd.ltGray);		{ If it is selected, show it }		IF i = selectedIcon THEN BEGIN			{RGB}ForeColor ({hilite}redColor);			InsetRect (r, -1, -1);			PenSize (2, 2);			FrameRect (r);			PenSize (1, 1);			ForeColor (blackColor);			END;				idToDraw := idToDraw + 100;		END;END;{$S DefProcs}PROCEDURE DrawIcons (myWin: WindowPtr);{ defProc del windoid }CONST	rIconImpassable = 10997;VAR	i, howManyIconsToDraw,	selectedIcon,	iconsPerRow, x, y: INTEGER;	r: Rect;	err: OSErr;BEGIN	{LMGetHiliteRGB (hiliteColor);}	TextSize (9);	howManyIconsToDraw := TMGetWRefCon (myWin, kRefconNumIcons);	iconsPerRow := TMGetWRefCon (myWin, kRefconIconsPerRow);	selectedIcon := TMGetWRefCon (myWin, kRefconSelectedIcon);	IF howManyIconsToDraw = 0 THEN BEGIN		{ Per il caso in cui non ci siano icone, e per il caso in cui		ci siano bordi di selezione da cancellare }		r := myWin^.portRect;		EraseRect (myWin^.portRect);		END;	{ Draw icons }	FOR i := 1 TO howManyIconsToDraw DO BEGIN		x := (i-1) MOD iconsPerRow + 1;		y := (i-1) DIV iconsPerRow + 1;		PlotOneIcon (x, y, Serial2ID (i, myWin), myWin);		{ If it is impassable and we are showing the structure, show it }		WITH r DO BEGIN			right := x * 33;			bottom := y * 33;			top := bottom - 32;			left := right - 32;			END;		IF gStructure & (placeKind <> threeD) & iconIsImpassable[Serial2ID(i, myWin)] THEN			err := PlotIconID (r, atNone, ttNone, rIconImpassable);		{ If it is selected, show it }		IF i = selectedIcon THEN BEGIN			{RGB}ForeColor ({hilite}redColor);			InsetRect (r, -1, -1);			PenSize (2, 2);			FrameRect (r);			PenSize (1, 1);			ForeColor (blackColor);			END;		END { for }END;{$S MkrProcs}PROCEDURE LoadIcons;{ In effetti non carica nulla. Si limita a contare le icone }{ L'etichetta large1BitMask per 'ICN#' è definita in Icons.p }CONST	kMaxNumRows = 4;VAR	leftOffset,					{ Distanza dal bordo sx dello schermo alla prima icona }	numRows, numRowsOnScreen,	numIcons, iconsPerRow,	windoidFrameBits: Integer;	{ How many columns of icons? }	theFont: Longint;BEGIN	iconStateWasChanged := FALSE;	{ Recupera il windoid dalle risorse }	IF gHasThemes THEN BEGIN		leftOffset := 15;	{ Sto usando la finestra con barra a sx }		myWindoid := GetNewCWindow (rWindoid+1000, NIL, WindowPtr (-1)) { New Mac OS 8 look }		END	ELSE BEGIN		leftOffset := 0;		myWindoid := GetNewCWindow (rWindoid, NIL, WindowPtr (-1));		END;	IF myWindoid = NIL THEN		DeathAlert (errMissingApplRes, ResError);	{ Calcola quante icone ci sono }	iconsPerRow := (qd.screenBits.bounds.right - 16 - leftOffset) DIV 33; { 16 per la scrollbar }	numIcons := 0;	WHILE Get1Resource(large1BitMask,kFirstIcon+numIcons) <> NIL DO		numIcons := succ (numIcons);	{ Calcola quante righe di dati dobbiamo fare }	numRows := (numIcons-1) DIV iconsPerRow + 1;	IF numRows > kMaxNumRows THEN BEGIN		windoidFrameBits := fRScroll+fIsWindoid;		numRowsOnScreen := kMaxNumRows		END	ELSE BEGIN		windoidFrameBits := fIsWindoid;		numRowsOnScreen := numRows		END;	{ Esegui }	SetPort (myWindoid);	theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);	TextFont (HiWrd (theFont));	TextSize (LoWrd (theFont));	MoveWindow(myWindoid, leftOffset, qd.screenBits.bounds.bottom - 33 * numRowsOnScreen, TRUE);	TMNewWindow (myWindoid, windoidFrameBits, kWindoidRefCon { refCon },			numRows * 33, iconsPerRow*33, 			numRowsOnScreen*33 - 1, iconsPerRow*33 - 1, 			numRowsOnScreen*33 + 1, iconsPerRow*33 + 1, 			33, 33,			33, 33,			0, NIL, DrawIcons);	TMSizeWindow (myWindoid, numRowsOnScreen*33 + 1, iconsPerRow*33 + 1, TRUE);	{ Salva parametri }	TMSetWRefCon (myWindoid, kRefconNumIcons, numIcons);	TMSetWRefCon (myWindoid, kRefconSelectedIcon, 0);	TMSetWRefCon (myWindoid, kRefconIconsPerRow, iconsPerRow);	{ Fa apparire il windoid }	ShowWindow (myWindoid)END;{$S MkrProcs}PROCEDURE LoadMaterials;VAR	matToTest, numMaterials: Integer;		FUNCTION MaterialExists: Boolean;	CONST		kABrickType = 'SqEl';	VAR		fakeHandle: Handle;	BEGIN		fakeHandle := NIL;		fakeHandle := Get1Resource (kABrickType, matToTest);		IF fakeHandle <> NIL THEN BEGIN			MaterialExists := TRUE;			ReleaseResource (fakeHandle);			END		ELSE			MaterialExists := FALSE;	END;BEGIN	IF gHasThemes THEN		{ Spazio per la title bar del windoid. Riecheggia il codice in		LoadIcons }		MoveWindow (myWindoid, 15, qd.screenBits.bounds.bottom - 4 * 33, FALSE)	ELSE		MoveWindow (myWindoid, 0, qd.screenBits.bounds.bottom - 4 * 33, FALSE);	{ Materiali }	SetResLoad (FALSE);	numMaterials := (900 - kFirstMaterial) DIV 100 + 1;	{ Materiali incorporati }	matToTest := 1001;	WHILE MaterialExists DO BEGIN		matToTest := matToTest + 100;		numMaterials := numMaterials + 1;		END;	SetResLoad (TRUE);	{ Inizializza i refcon }	TMSetWRefCon (myMaterials, kRefconIconsPerRow, 1);	TMSetWRefCon (myMaterials, kRefconSelectedIcon, 1);	TMSetWRefCon (myMaterials, kRefconNumIcons, numMaterials);	TMNewWindow (myMaterials, fIsWindoid, kMaterialsRefCon { refCon },			numMaterials*33 - 1, 32,			numMaterials*33 + 1, 34, 			numMaterials*33 - 1, 32,			33, 33,			33, 33,			0, NIL, DrawMaterials);	TMSizeWindow (myMaterials, 34, 33 * numMaterials + 1, TRUE);		ShowWindow (myMaterials);END;{$S MkrProcs}PROCEDURE ThreeDTools (on: BOOLEAN); { versione DR 2 }CONST kWeatherPopUp = 138;	rStandardFloor = 505;	rStandardBackground = 505;VAR	theFont: Longint;	theFontID,	windoidFrameBits: INTEGER;	mh: MenuHandle;	thePopUpHandle: ControlHandle;	data: ThreeDHandle;BEGIN	mh := GetMenuHandle (kPlaceMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);			IF on THEN BEGIN		{ Menu }		EnableItem (mh, kChooseFloor);		EnableItem (mh, kChooseRoof);		{ Extended data }		data := ThreeDHandle (NewHandle (SizeOf (ThreeDPlaceAttributes)));		data^^.floor := rStandardFloor;		data^^.roof := 0;		data^^.background := rStandardBackground;		data^^.weather := 0;		TMSetWRefCon (mainWindow, 3, Longint (data));		{ Barra degli strumenti }		SetPort (mainWindow);		theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);		theFontID := HiWrd (theFont);		TextFont (theFontID);		TextSize (LoWrd (theFont));		thePopUpHandle := GetNewControl (kWeatherPopup, mainWindow);		TMSetWRefCon (mainWindow, 4, Longint (thePopUpHandle));		{ mostra le meta-icone da costruzione }		windoidFrameBits := fRScroll+fIsWindoid;		TMNewWindow (myWindoid, windoidFrameBits, kWindoidRefCon { refCon },			5*33-1, 20*33-1, 			4*33+1, 20*33+1, 			4*33+1, 20*33+1, 			33, 33,			33, 33,			0, NIL, DrawIcons);		TMSetWRefCon (myWindoid, kRefconIconsPerRow, 20);		TMSetWRefCon (myWindoid, kRefconNumIcons, 100);		TMSetWRefCon (myWindoid, kRefconSelectedIcon, 1);		LoadMaterials;		END	ELSE BEGIN		{ Menu }		DisableItem (mh, kChooseFloor);		DisableItem (mh, kChooseRoof);		{ Extended data }		data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));		DisposeHandle (Handle (data));		TMSetWRefCon (mainWindow, 3, 0); { You never know }		{ Barra degli strumenti }		thePopUpHandle := ControlHandle (TMGetWRefCon (mainWindow, 4));		TMSetWRefCon (mainWindow, 4, 0); { You never know }		DisposeControl (thePopUpHandle);		{ Windoid }		if myWindoid <> NIL THEN TMDisposeWindow (myWindoid); { sarà ricreato subito }		LoadIcons;		HideWindow (myMaterials);		END;	{ Ridisegna il contenuto }	SetPort (myWindoid);	InvalRect (myWindoid^.portRect);END;{$S MkrProcs}PROCEDURE ResetWindoid;BEGIN	TMDisposeWindow (myWindoid);	HideWindow (myMaterials);END;{$S MkrProcs}PROCEDURE SelectMaterial (clickPoint: Point);VAR	oldSelectedMaterial, newSelectedMaterial: Integer;BEGIN	oldSelectedMaterial := TMGetWRefCon (myMaterials, kRefconSelectedIcon);	{ deseleziona la vecchia icona selezionata }	IF oldSelectedMaterial > 0 THEN		InternalRedrawOneIcon (myMaterials, oldSelectedMaterial);	{ trova la nuova icona selezionata }	newSelectedMaterial := Point2Serial (clickPoint, myMaterials);	{ mostra la nuova icona selezionata }	IF newSelectedMaterial > 0 THEN		InternalRedrawOneIcon (myMaterials, newSelectedMaterial);	{ Salva la selezione }	TMSetWRefCon (myMaterials, kRefconSelectedIcon, newSelectedMaterial);END;{$S MkrProcs}FUNCTION GetSelectedIconID: INTEGER;VAR	selectedIcon, selectedMaterial, result: Integer;BEGIN	selectedIcon := TMGetWRefCon (myWindoid, kRefconSelectedIcon);	IF selectedIcon > 0 THEN		IF placeKind = threeD THEN BEGIN			selectedMaterial := TMGetWRefCon (myMaterials, kRefconSelectedIcon);			result := kFirstMaterial + (selectedMaterial - 1) * 100 + selectedIcon MOD 100 - 1;			{ A Rakku non piacciono i numeri x20 e x40. Io li trasformo in x00 }			IF result MOD 20 = 0 THEN				result := result DIV 100 * 100;			GetSelectedIconID := result			END			ELSE			GetSelectedIconID := Serial2ID (selectedIcon, myWindoid)	ELSE		GetSelectedIconID := 0END;{$S MkrProcs}PROCEDURE RedrawSelectedIcon;VAR	selectedIcon: Integer;BEGIN	selectedIcon := TMGetWRefCon (myWindoid, kRefconSelectedIcon);	InternalRedrawOneIcon (myWindoid, selectedIcon)END;{$S MkrProcs}PROCEDURE SelectIcon (clickPoint: Point);VAR	oldSelectedIcon, newSelectedIcon: Integer;BEGIN	oldSelectedIcon := TMGetWRefCon (myWindoid, kRefconSelectedIcon);	{ deseleziona la vecchia icona selezionata }	IF oldSelectedIcon > 0 THEN		InternalRedrawOneIcon (myWindoid, oldSelectedIcon);	{ trova la nuova icona selezionata }	newSelectedIcon := Point2Serial (clickPoint, myWindoid);	{ mostra la nuova icona selezionata }	IF newSelectedIcon > 0 THEN		InternalRedrawOneIcon (myWindoid, newSelectedIcon);	{ Salva la selezione }	TMSetWRefCon (myWindoid, kRefconSelectedIcon, newSelectedIcon);END;{$S MkrProcs}PROCEDURE WindoidInit;BEGIN	{ Windoid delle icone }	gStructure := FALSE;	myWindoid := NIL;	{ Windoid dei materiali }	myMaterials := GetNewCWindow (rMaterials+ord(gHasThemes)*1000, NIL, WindowPtr (-1));	IF myMaterials = NIL THEN		DeathAlert (errMissingApplRes, ResError);	TMNewWindow (myMaterials, fIsWindoid, kMaterialsRefCon { refCon },		33, 33, 		33, 33, 		33, 33, 		0, 33,		0, 33,		0, NIL, DrawMaterials);END;{$S MkrProcs}PROCEDURE RadiusPivot;BEGIN	ResetWindoid;	LoadIconsEND;{$S MkrProcs}PROCEDURE GrabIcons;var	myFileList: SFTypeList;	myReply: StandardFileReply;	scenarioToRob: MyFile;	wasFound: BOOLEAN;	numIcons,	iconToRob: Integer;	iconData: Handle;		PROCEDURE DoGrabIcon (whatKind: ResType);	BEGIN		iconData := Get1Resource (whatKind, iconToRob);		IF iconData <> NIL THEN BEGIN			DetachResource (iconData);			WriteRes (currentScenario, 1000+numIcons,						whatKind, '', iconData);			ReleaseResource (iconData)			END	END;	BEGIN{1. Chiedi all'utente uno scenario donde trarre le icone }	{ Specify filetypes which I can read }	myFileList[0] := fileTypeScenario;	myFileList[1] := fileTypeScenario3D;	StandardGetFile (nil, 2, @myFileList, myReply);	wasFound := myReply.sfGood;			{ If user cancelled, then no hope }	{ Do open it. }	IF wasFound THEN BEGIN{2. Apri questo nuovo scenario. Anche se è aperto per ultimo,WriteRes di BinIO funzionerà correttamente, aggiungendole icone allo scenario in costruzione }		ResetRByFSS (scenarioToRob, myReply.sfFile);		IF scenarioToRob.errore <> noErr THEN			NewErrorAlert (kAlertStopAlert, errChooseAnother, scenarioToRob.errore)		ELSE BEGIN{ 3. Leggi, una ad una, tutte le icone dallo scenario aperto,a aggiungile allo scenario in costruzione. Ricordiamo chelo scenario in costruzione possiede per ora numIcons icone,e quindi vanno usati gli ID da 1000+numIcons in poi. }			CursorInit;			iconToRob := 1000;			numIcons := TMGetWRefCon (myWindoid, kRefconNumIcons);			REPEAT				DoGrabIcon (large8BitData);				DoGrabIcon (large4BitData);				DoGrabIcon (large1BitMask);				numIcons := numIcons + 1;				iconToRob := iconToRob + 1;				CursorAnimate			UNTIL (iconData = NIL);{ 4. Chiudi lo scenario dal quale abbiamo letto }			Close (scenarioToRob);			InitCursor;{ 5. Aggiorna il windoid, di modo che le nuove iconeappaiano e siano utilizzabili. }			ResetWindoid;			LoadIcons		END { scenario was correctly opened }	END { if scenario was found }END;END.