PROGRAM ScenarioMaker;USES	Types,	QuickDraw,	{ List 2 - only require List 1 types }	Appearance,	AppleEvents,	Controls,	EPPC,	Events,	Errors,	Icons	,Memory	,Menus,	OSUtils,	QDOffscreen,	QuickdrawText,	Resources,	Script,	SegLoad	,TextEdit,	TextUtils	,ToolUtils	{ List 3 - needs List 1/2 types }	,Aliases			{ (3.2) needs Memory }	,Windows			{ needs Events, Controls }	{ List 4 - needs List 1/2/3 types }	,Dialogs			{ needs TextEdit, Windows }	,Palettes			{ needs windows }	,StandardFile		{ (3.2) needs Aliases }	,TaskMaster3,	BinIo,	Cilindro,	DialogLord4,		SMErrors,	Windoid,	SMMenus,	SMDialogs,	SMResources,	MakerIO,	SMUtilities;VAR	evento: wmTaskRec;	{ Globale, di modo che resti vivo il campo wmClickCount }{$S MkrProcs}PROCEDURE DoClosePlace;VAR	allButtons: Family;BEGIN	IF gDirty THEN BEGIN { Changes done and not saved. Save? }		ClearFamily (allButtons);		allButtons[kYesSave] := TRUE;		allButtons[kCancelSave] := TRUE;		allButtons[kNoSave] := TRUE;		CASE AlertLord (rSaveChangesAlert, kNumItemsInChangeAlert, allButtons) OF			kYesSave: SavePlaceResource;			kCancelSave: Exit (DoClosePlace);			{ kNoSave:; }			END;		END;	IF placeKind = threeD THEN BEGIN		placeKind := Standard; { Provoca la ricomparsa delle icone di scenario }		ThreeDTools (FALSE);		END;	HideWindow(mainWindow);	DisposePtr (Ptr(placeMap));	DisposeGWorld (world);	placeMap := NIL;	displayingPlace := FALSE;	WindowIsClosed (kPlaceMenu)END;{$S MkrProcs}PROCEDURE DoCloseArena;VAR	allButtons: Family;BEGIN	IF gDirty THEN BEGIN { Changes done and not saved. Save? }		ClearFamily (allButtons);		allButtons[kYesSave] := TRUE;		allButtons[kCancelSave] := TRUE;		allButtons[kNoSave] := TRUE;		CASE AlertLord (rSaveChangesAlert, kNumItemsInChangeAlert, allButtons) OF			kYesSave: SaveArenaResource;			kCancelSave: Exit (DoCloseArena);			{ kNoSave:; }			END;		END;	HideWindow(mainWindow);;	displayingArena := FALSE;	WindowIsClosed (kArenaMenu)END;{$S MkrProcs}PROCEDURE DoCloseText (theWin: WindowPtr);VAR	allButtons: Family;BEGIN	ClearFamily (allButtons);	allButtons[kYesSave] := TRUE;	allButtons[kCancelSave] := TRUE;	allButtons[kNoSave] := TRUE;	CASE AlertLord (rSaveChangesAlert, kNumItemsInChangeAlert, allButtons) OF		kYesSave: SaveTextResource (theWin);			{ Fa anche il dispose }		kCancelSave: Exit (DoCloseText);		kNoSave: TMDisposeWindow (theWin)		END;END;{$S MkrProcs}FUNCTION CloseWindowEtAl: Boolean;{ Restituisce TRUE se la chiusura dello scenario può continuare }BEGIN	{ Se non c'è nulla di aperto, prosegui }	IF currentScenario.resFork = 0 THEN BEGIN		CloseWindowEtAl := TRUE;		Exit (CloseWindowEtAl)		END;	IF displayingPlace THEN		DoClosePlace;	IF displayingArena THEN		DoCloseArena;	{ Se l'utente ha cambiato idea a questo punto, DoClosePlace o		DoCloseArena non hanno agito, e quindi displayingPlace o		displayingArena sono rimasti TRUE. }	IF displayingPlace OR displayingArena THEN BEGIN		CloseWindowEtAl := FALSE;		Exit (CloseWindowEtAl);		END;			{ Salva il setup delle icone (passable/impassable) }	SaveScenarioInfo;	{ Pulisci il windoid }	ResetWindoid;	{ Chiudi il file }	Close (currentScenario);	CloseWindowEtAl := TRUE;END;{$S UtilInit}Procedure SMMainInit;CONST	rMenuBar = 128;VAR	theFont: longint;	err: OSErr;BEGIN	{ Initialize all the needed managers. }	StandardInitialization (10);	IF gHasThemes THEN BEGIN		StandardMenuSetup (rMenuBar+1000, kAppleMenu); { Mac OS 8 look }		err := SetMenuItemModifiers (GetMenuHandle(kFileMenu), kCheckScenario, kMenuOptionModifier);		END	ELSE		StandardMenuSetup (rMenuBar, kAppleMenu);	{ Test the computer to be sure we can do color.  If not we would crash. 	Test also for System 7, and other needed features. }	if gSystemVersion < $700 then		DeathAlert (errNeedSys7, 0);	if gQDVersion = kQDOriginal THEN		DeathAlert (errNeedColor, 0);	InitPalettes;	{ 						}	{ initialize TaskMaster	}	{ 						}	InitTaskMaster (taskMiddlePriority);		{ Init globals }	currentScenario.resFork := 0;	{ Carica la finestra }	mainWindow := GetNewCWindow (rMainWindow+ord(gHasThemes)*1000, NIL, WindowPtr(-1));	IF mainWindow = NIL THEN		DeathAlert (errMissingApplRes, ResError);	{ Informa TaskMaster della sua esistenza }	TMNewWindow (mainWindow, fGrow+fBScroll+fRScroll,		kMainWindowRefcon,	{ refCon }		0, 0,						{ data height & width }				96*32, 96*32,			{ max height & width }		32, 32,					{ Min height & width }		32, 32,					{ scrollver & scrollhor }		0, 0,						{ pagever, pagehor }		0, NIL, DrawWindow);	SetPort (mainWindow);	theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);	TextFont (HiWrd (theFont));	TextSize (LoWrd (theFont));END;	{ SMMainInit }{$S Main}PROCEDURE FillWindow (everywhere: Boolean);VAR	x, y, icn: Integer;	r: rect;BEGIN	icn := GetSelectedIconID;	IF icn <> 0 THEN BEGIN		SetPort (mainWindow);		IF displayingPlace THEN BEGIN			FOR x := 1 TO placeW DO				FOR y := 1 TO placeH DO					IF (placeMap^[x, y].icon = 0) OR everywhere THEN BEGIN						{ Metti qui l'icona che stiamo usando }						placeMap^[x, y].icon := icn;						{ Setta anche la caratteristica passable/impassable }						IF placeKind <> threeD THEN							placeMap^[x, y].characteristics[7] := iconIsImpassable[icn];						SetRect(r,BSL(y-1, 5),BSL(x-1,5),BSL(y,5),BSL(x,5));						END; { do fill }			RedrawGWorld			END { place }		ELSE			{ Arena }			FOR y := 1 TO arenaY DO				FOR x := 1 TO arenaX DO					IF arena[x, y].icon = 0 THEN BEGIN						{ Metti qui l'icona che stiamo usando }						arena[x, y].icon := icn;						{ Setta anche la caratteristica passable/impassable }						arena[x, y].specs[7] := iconIsImpassable[icn];						SetRect(r,BSL(y-1, 5),BSL(x-1,5),BSL(y,5),BSL(x,5));						END { do fill }		END; { if there is an icon selected }	gDirty := TRUE;	SetPort (mainWindow);	InvalRect (mainWindow^.portRect)END;{$S Main}FUNCTION DragRect (p: Point; r: Rect): Point;{ Tecnica descritta nella Nota Tecnica TB.WMgrPort }VAR	sourceRectRgn, originalVisRgn: RgnHandle;	everywhere: rect;	resultPoint: longint;	finalResult, puttanadelreggimento: Point;	guestPort: GrafPtr;	totalPort: GrafPort;begin	GetPort (guestPort);	{ Porta i param in globali }	LocalToGlobal (r.topLeft);	LocalToGlobal (r.botRight);	puttanadelreggimento := p;	LocalToGlobal (puttanadelreggimento);		{ Crea una regione che contenga il rettangolo }	sourceRectRgn := NewRgn;	CloseRgn (sourceRectRgn);	RectRgn (sourceRectRgn, r);		{ Crea un nuovo GrafPort nel quale disegnare }	OpenPort(@totalPort);	originalVisRgn := totalPort.visRgn;	totalPort.visRgn := GetGrayRgn;	everywhere := totalPort.visRgn^^.rgnBBox;	totalPort.portRect := everywhere;	{ Usual grafPort gimmick }	SetPort (@totalPort);		{ Chiedi al toolbox di fare il lavoro }	resultPoint :=		DragGrayRgn (sourceRectRgn, puttanadelreggimento,		everywhere, everywhere,		noConstraint, NIL);	{ Il risultato è il delta, quindi… }	finalResult.v := HiWrd (resultPoint) + p.v;	finalResult.h := LoWrd (resultPoint) + p.h;	{ GrafPrt again }	SetPort (guestPort);	totalPort.visRgn := originalVisRgn;	ClosePort(@totalPort);	SetPort (guestPort);	{ Lo so che non dovrebbe servire, ma… }			{ Restituisci il risultato }	DragRect := finalResult;		{ Liberati della memoria allocata }	DisposeRgn (sourceRectRgn)end;{$S Main}PROCEDURE HandleInfoClick (theWin: WindowPtr; pt: Point);VAR	iconClicked, result: Integer;	data: ThreeDHandle;	r: Rect;		PROCEDURE HandleBoxInsertion;	CONST		rBoxAddedConfirm = 131;	VAR		okButton: Family;		dummy: Str255;		dummyButton: Integer;	BEGIN		ClearFamily (okButton);		okButton [kStdOkItemIndex] := TRUE;		WITH g3DBoxesHere DO			IF numBoxes = kMaxBoxesIn3D THEN				NewErrorAlert (kAlertStopAlert, errTooManyBoxes, 0)			ELSE BEGIN				result := LoadWhat (rChooseBoxStr, 0, res3DObject);				IF result <> 0 THEN BEGIN					{ Mettilo nella struttura dati }					numBoxes := succ (numBoxes);					WITH boxes[numBoxes] DO BEGIN						boxID := result;						boxPos := LoadBoxInfo (result, dummy);						BlockMove (@dummy, @boxName, SizeOf (boxName));						IF length (dummy) >= SizeOf (boxName) THEN							boxName[0] := chr (SizeOf (boxName)-1);						END; { fill box data }					IF gStructure THEN						{ E' visibile, fallo apparire }						TMInvalRect (boxes[numBoxes].boxPos)					ELSE						{ Avvisa che è stato aggiunto e va posizionato }						dummyButton := AlertLord (rBoxAddedConfirm, kStdOkItemIndex, okButton);					END { did not cancel }			END { if free boxes }	END; { proc }		PROCEDURE HandleLightsInsertion;	CONST		rLightAddedConfirm = 138;	VAR		okButton: Family;		dummyButton: Integer;	BEGIN		ClearFamily (okButton);		okButton [kStdOkItemIndex] := TRUE;		WITH g3DLightsHere DO			IF numBoxes = kMaxBoxesIn3D THEN				NewErrorAlert (kAlertStopAlert, errTooManyLights, 0)			ELSE BEGIN				result := LoadWhat (rChooseLightSource, 0, res3DLight);				IF result <> 0 THEN BEGIN					{ Mettilo nella struttura dati }					numBoxes := succ (numBoxes);					LoadLightInfo (result, boxes[numBoxes]);					IF gStructure THEN						{ E' visibile, fallo apparire }						TMInvalRect (boxes[numBoxes].boxPos)					ELSE						{ Avvisa che è stato aggiunto e va posizionato }						dummyButton := AlertLord (rLightAddedConfirm, kStdOkItemIndex, okButton);					END { did not cancel }			END { if free boxes }	END; { proc }BEGIN	SetPort (theWin);	GlobalToLocal (pt);	IF theWin = mainWindow THEN BEGIN		data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));		{ Luogo 3D, click su una icona }		iconClicked := pt.h DIV 32;		CASE iconClicked OF			0: IF NOT placeData [4] THEN BEGIN	{ If underground, no background }				result := LoadWhat (rBackgroundPrompt, data^^.background, 'PICT');				IF result <> 0 THEN BEGIN					data^^.background := result; { 505 as default - white BG }					gDirty := TRUE;					END				END;			1: BEGIN				result := LoadWhat(rChooseFloorStr, data^^.floor, 'cicn');				IF result <> 0 THEN BEGIN					data^^.floor := result; { Leave 505 as default - 3D Engine needs a floor }					gDirty := TRUE;					END				END;			2: BEGIN				result := LoadWhat(rChooseRoofStr, data^^.roof, 'cicn');				data^^.roof := result;				gDirty := TRUE;				END;			3: HandleBoxInsertion;			4: HandleLightsInsertion;			5: Do3DPlaceStartDialog;			OTHERWISE ; { Don't touch gDirty }			END;		{ Ridisegna icone per caratterizzare lo status }		SetRect (r, 0, 0, MAXINT, 32);		Invalrect (r)		END;END;{$S Main}PROCEDURE HandleClickInMainWinPopup;VAR	data: ThreeDHandle;	theWeatherResource, newWeather: Integer;	theControl: ControlHandle;BEGIN	data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));	{ OK, cosa ha scelto? }	theControl := ControlHandle (TMGetWRefCon (mainWindow, 4));	newWeather := GetControlValue (theControl);	CASE newWeather OF		1: theWeatherResource := 0; { No weather }		2: theWeatherResource := kRainyWeather;		3: theWeatherResource := kSnowyWeather;		4: BEGIN			theWeatherResource := LoadWhat (rWeatherPrompt, data^^.weather, resWeather);			IF theWeatherResource = 0 THEN { Cancelled }				SetControlValue (theControl, 1); 			END { custom }		END; { case }	data^^.weather := theWeatherResource;	gDirty := TRUEEND;{$S Main}PROCEDURE HandleClick (win: WindowPtr; globalPointClicked: Point; kind: integer);{ Kind vale 1 per click semplice, 2 per doppio click, 3 per triplo click… }VAR	selectedIcon: integer;		port: CGrafPtr; gdh: GDHandle;	localPointClicked, coordOfIconClicked: Point;		FUNCTION Point2Coord (p: point): Rect;	{ trasforma il punto di una icona (per esempio 1,1) nelle coordinate che essa occupa	nella finestra (per esempio 32,32) }	VAR result: rect;	BEGIN		WITH result, p DO BEGIN			bottom := BSL (v, 5); { x 32 }			right := BSL (h, 5);			top := bottom - 32;			left := right - 32			END;		Point2Coord := result	END;		PROCEDURE ClickOnStructure;	CONST		resMoveCursor = 129;	VAR		wholePlaceBounds, newPosForBox: Rect;		serialOfClickedBox: Integer;				PROCEDURE MoveBox (VAR boxArray: T3DBoxes; boxSerial: Integer; chunky: Boolean);		{ SE chunky è true muove di 32 pixel minimo }		VAR			loop: Integer;			localPointMouseUp, delta: Point;		BEGIN			WITH boxArray DO BEGIN				SetCursor (GetCursor (resMoveCursor)^^);				localPointMouseUp := DragRect (localPointClicked, boxes[boxSerial].boxPos);				TMPhysicalToLogical (localPointMouseUp);				InitCursor; { back to arrow }				{ Bounds for good final position }				WITH wholePlaceBounds DO BEGIN					longint (topLeft) := 0;					bottom := placeH * 32;					right := placeW * 32					END;				{ Position after move for box }				newPosForBox := boxes[boxSerial].boxPos; 				WITH delta, newPosForBox DO BEGIN					IF chunky THEN BEGIN						localPointMouseUp.v := BSR (localPointMouseUp.v, 5);						localPointClicked.v := BSR (localPointClicked.v, 5);						localPointMouseUp.h := BSR (localPointMouseUp.h, 5);						localPointClicked.h := BSR (localPointClicked.h, 5);						END;					h := localPointMouseUp.h - localPointClicked.h;					v := localPointMouseUp.v - localPointClicked.v;					IF chunky THEN BEGIN						h := BSL (h, 5);						v := BSL (v, 5)						END;					top := top + v;					bottom := bottom + v;					right := right + h;					left := left + h;					END;				{ Move box position }				IF PtInRect (newPosForBox.topLeft, wholePlaceBounds) OR PtInRect (newPosForBox.botRight, wholePlaceBounds)THEN BEGIN					TMInvalRect (boxes[boxSerial].boxPos);					TMInvalRect (newPosForBox);					boxes[boxSerial].boxPos := newPosForBox;					END { moved inside place }				ELSE BEGIN { moved out of place }					{ delete it! }					numBoxes := numBoxes - 1;					FOR loop := boxSerial TO numBoxes DO						boxes[loop] := boxes[loop+1];					TMInvalRect (boxes[boxSerial].boxPos);					END; { moved out of place }				gDirty := TRUE { Place modificato }			END		END;			BEGIN		{ Trova se ha cliccato sopra un box }		serialOfClickedBox := 1;		WITH g3DBoxesHere DO BEGIN			WHILE (serialOfClickedBox <= numBoxes) & NOT PtInRect (localPointClicked, boxes[serialOfClickedBox].boxPos) DO				serialOfClickedBox := succ (serialOfClickedBox);			IF serialOfClickedBox <= numBoxes THEN BEGIN				MoveBox (g3DBoxesHere, serialOfClickedBox, FALSE);				Exit (ClickOnStructure)				END;			END;		{ Trova se ha cliccato sopra una fonte di luce }		serialOfClickedBox := 1;		WITH g3DLightsHere DO BEGIN			WHILE (serialOfClickedBox <= numBoxes) & NOT PtInRect (localPointClicked, boxes[serialOfClickedBox].boxPos) DO				serialOfClickedBox := succ (serialOfClickedBox);			IF serialOfClickedBox <= numBoxes THEN MoveBox (g3DLightsHere, serialOfClickedBox, TRUE);			END;	END;		PROCEDURE SingleClickOnPlaceMap;	CONST		resCrossCursor = 128;	VAR		localPointMouseUp, coordOfIconMouseUp: Point;		pastRect, drawnRect, winRectDaInvalidare, r1, r2: Rect;		baseIcon, x, y: Integer;		cycleDone: Boolean;				PROCEDURE SetAndPlotIcon (x, y, theIcon: Integer);		BEGIN			placeMap^[x, y].icon := theIcon;			PlotOneIcon (x, y, theIcon, mainWindow);		END;	BEGIN		{ localPointClicked è il punto di mouseDown,		serve un'altra variabile per il punto di mouseUp }		localPointMouseUp := localPointClicked;			{ Costruzione di edifici con un sol colpo di mouse - gestione dragging }		IF placekind = threeD THEN BEGIN			{ Prepara il ciclo di controllo dello stato del mouse }			drawnRect.topLeft := localPointClicked;			TMLogicalToPhysical (drawnRect.topLeft);			SetRect (pastRect, 0, 0, -1, -1);			PenMode (srcXor);			cycleDone := FALSE;			{ Lascia trascinare il mouse per tracciare un rect }			WHILE StillDown DO BEGIN				IF NOT cycleDone THEN BEGIN { Prima volta che ci entro }					SetCursor (GetCursor (resCrossCursor)^^);					cycleDone := TRUE;					END;				GetMouse (drawnRect.botRight); { locale }				{ mouse moved }				IF Longint (pastRect.botRight) <> Longint (drawnRect.botRight) THEN BEGIN					{ Cancella il rect precedente }					FrameRect (pastRect);					{ Disegna il rect attuale }					FrameRect (drawnRect);					{ Memorizza il rect disegnato }					pastRect := drawnRect					END; { mouse moved }				END;			IF cycleDone THEN BEGIN				InitCursor;				{ Cancella l'ultimo rect disegnato, riportando la finestra alla condizione originale }				FrameRect (pastRect);				{ Restituisci il punto in cui è terminato il trascinamento }				localPointMouseUp := pastRect.botRight;				TMPhysicalToLogical (localPointMouseUp); { Disegno direttamente a video, e la magia di TaskMaster…}				END; { cycleDone }			END; { if 3D }			{ Trasforma la coppia di coordinate (pixel) in coppia di coordinate (per icone) }		coordOfIconMouseUp := localPointMouseUp;		WITH coordOfIconMouseUp DO BEGIN			v := BSR(v, 5) + 1; { DIV 32 }			h := BSR(h, 5) + 1;			END;			SetGWorld (world, NIL);		IF LockPixels (world^.portPixMap) THEN			{ Mouse cliccato e rilasciato nello stesso punto? }			IF (coordOfIconClicked.v < coordOfIconMouseUp.v) AND (coordOfIconClicked.h < coordOfIconMouseUp.h) THEN BEGIN				{ Si, ha tracciato un rettangolo }				{ Ricava da selectedIcon il numero dell'icona base (stesso materiale, stessa altezza }				baseIcon := selectedIcon DIV 20 * 20;				{ Rispetto a baseIcon, disegna il rettangolo }				SetAndPlotIcon (coordOfIconClicked.h, coordOfIconClicked.v, baseIcon+6);				SetAndPlotIcon (coordOfIconClicked.h, coordOfIconMouseUp.v, baseIcon+5);				SetAndPlotIcon (coordOfIconMouseUp.h, coordOfIconClicked.v, baseIcon+3);				SetAndPlotIcon (coordOfIconMouseUp.h, coordOfIconMouseUp.v, baseIcon+4);				FOR x := (coordOfIconClicked.h + 1) TO (coordOfIconMouseUp.h - 1) DO BEGIN					SetAndPlotIcon (x, coordOfIconClicked.v, baseIcon+1);					SetAndPlotIcon (x, coordOfIconMouseUp.v, baseIcon+1);					END; { ciclo su sopra e sotto }				FOR y := (coordOfIconClicked.v + 1) TO (coordOfIconMouseUp.v - 1) DO BEGIN					SetAndPlotIcon (coordOfIconClicked.h, y, baseIcon+2);					SetAndPlotIcon (coordOfIconMouseUp.h, y, baseIcon+2);					END; { ciclo sui lati }				{ Trova cosa vada ridisegnato }				r1 := Point2Coord (coordOfIconClicked);				r2 := Point2Coord (coordOfIconMouseUp);				winRectDaInvalidare.topLeft := r1.topLeft;				winRectDaInvalidare.botRight := r2.botRight;				END			ELSE BEGIN { Ha indicato un singolo punto }				{ Metti qui l'icona che stiamo usando }				SetAndPlotIcon (coordOfIconClicked.h, coordOfIconClicked.v, selectedIcon);				winRectDaInvalidare := Point2Coord (coordOfIconClicked);				gDirty := TRUE;				{ Setta anche la caratteristica passable/impassable }				IF placeKind <> threeD THEN					placeMap^[coordOfIconClicked.h, coordOfIconClicked.v].characteristics[7] := iconIsImpassable[selectedIcon];				END;				UnlockPixels (world^.portPixMap);		SetGWorld (port,gdh);		TMInvalRect (winRectDaInvalidare); { Ridisegna a video - non posso plottare perché in modo struttura... }	END;BEGIN	GetGWorld(port,gdh);	SetPort (win);	selectedIcon := GetSelectedIconID;	localPointClicked := globalPointClicked;	GlobalToLocal (localPointClicked);	{ Trova le coordinate dell'icona cliccata - trasforma da (16, 30) a (1, 1) }	coordOfIconClicked := localPointClicked;	WITH coordOfIconClicked DO BEGIN		v := BSR (v, 5) + 1;		h := BSR (h, 5) + 1;		END;	{ Is this the windoid ? }	CASE TMGetWRefCon (win, 1) OF		kWindoidRefCon: BEGIN			IF kind = 1 THEN				SelectIcon (localPointClicked)			ELSE IF (placeKind <> threeD) & (selectedIcon > 0) THEN BEGIN				iconIsImpassable[selectedIcon] := NOT iconIsImpassable[selectedIcon];				iconStateWasChanged := TRUE;				RedrawSelectedIcon				END			END { windoid }		kMaterialsRefCon: SelectMaterial (localPointClicked);		kMainWindowRefcon: IF selectedIcon > 0 THEN BEGIN			{ processa tutti i casi possibili }			IF displayingPlace THEN BEGIN				IF kind = 1 { click } THEN					IF gStructure AND (placeKind = threeD) THEN						ClickOnStructure					ELSE						SingleClickOnPlaceMap				ELSE { doppio click }					DoPlaceLocDialog (coordOfIconClicked.h, coordOfIconClicked.v, globalPointClicked);				END { if displaying place }			ELSE BEGIN				IF kind = 1 { click } THEN BEGIN					{ Metti qui l'icona che stiamo usando }					arena[coordOfIconClicked.h, coordOfIconClicked.v].icon := selectedIcon;					gDirty := TRUE;					{ Setta anche la caratteristica passable/impassable }					arena[coordOfIconClicked.h, coordOfIconClicked.v].specs[7] := iconIsImpassable[selectedIcon];					{ Ridisegna a video - non posso plottare perché in modo struttura... }					TMInvalRect (Point2Coord (coordOfIconClicked))					END				ELSE { doppio click }					DoArenaLocDialog (coordOfIconClicked.h, coordOfIconClicked.v);				END { if displaying arena }			END { caso mainWindow }	END { case }END; { proc }{$S AboutBox}PROCEDURE CustomAbout (thePict: INTEGER);LABEL 998, 999;CONST	rAboutDLOG = 129;VAR	laFinestra: WindowPtr; { Old grafport save }	h :PicHandle;	picR, animR, srcRect, lineR: Rect;	d: DialogPtr;	myUpdateRgn: RgnHandle; { Per scrollrect }	{ Per il ciclo di ritardo }	ticks: longint;		oldPort: CGrafPtr;	oldGdev: GDHandle;	aboutWorld: GWorldPtr;	BEGIN	GetPort (laFinestra);	{ Recupera dal ramo risorse la finestra e la picture }	h := GetPicture (thePict);	if h = nil THEN BEGIN		NewErrorAlert (kAlertStopAlert, errMissingApplRes, resNotFound);		exit (CustomAbout)		END;	{ Inizializza le variabili:		picR: rettangolo che ingloba l'intera picture }	picR := h^^.picFrame;	{ Check to be sure that the rect has top = 0, left = 0 }	OffsetRect (picR, -picR.left, -picR.top);	{ Load dialog }	d := GetNewDialog (rAboutDLOG, nil, WindowPtr (-1));	if d = nil THEN BEGIN		NewErrorAlert (kAlertCautionAlert, errMissingApplRes, resNotFound);		exit (CustomAbout)		END;	{ Size & show it }	SizeWindow(d,picR.right,d^.portRect.bottom,FALSE);	SetPort (d);	ShowWindow (d);	{ Metti uno sfondo nero... }	FillRect (picR, qd.black);	{ Inizializza le variabili:		animR: rettangolo in cui avviene lo scrolling		lineR: ultima riga del rettangolo }	{ Crea uno offscreen bitmap. Abbonda sulle dimensioni orizzontali,	per il caso in cui	la larghezza della bitmap non sia un multiplo esatto di otto. Lo	spazio in memoria richiesto è relativamente ingente, quindi se siamo in	condizioni di ristrettezza libera un po' di spazio swappando il segmento codice	più grande. Sarà automaticamente ricaricato all'uscita. }	{$IFC MAC68K}	if MaxBlock < 65537 THEN		UnloadSeg (@HandleClick);	{$ENDC}		(* USANDO GWORLD *)	if NewGWorld (aboutWorld, 8 { bit per pixel }, picR, NIL, NIL, 0) <> noErr	THEN GOTO 999;	GetGWorld (oldPort, oldGdev);	SetGWorld (aboutWorld, NIL);	if not LockPixels (aboutWorld^.portPixMap) then		goto 998;	EraseRect (aboutWorld^.portRect);		ClipRect (picR);	DrawPicture (h, picR);	IF QDError <> noErr THEN GOTO 998;	{ Ecco fatto. Ora torniamo al dialogo }	SetGWorld (oldPort, oldGdev);	{ calcola quanto spazio lasciare tra il bordo della finestra e quello della PICT }	SetRect (animR, 0, 5, picR.right, 205);	{ Visto che usiamo ScrollRect per aumentare la velocità dell'animazione, prepara	un secondo rettangolo, ad uso di CopyBits, che comprende solo una riga, l'ultima,	che sarà l'unica a venire effettivamente disegnata – le altre sono scrolled }	lineR := animR; lineR.top := lineR.bottom - 1;			{ Setta la clipping region al rettangolo anim, di modo che i disegni non sconfinino }	ClipRect (animR);	{ Inizializza il rettangolo sorgente che deve		• Avere le stesse dimensioni di animRect (verticale 1, orizzontale come la pict)		• Avere left = 0 }	SetRect (srcRect, 0, 0, picR.right, 1);	{ Prepara gli altri parametri per Scrollrect }	myUpdateRgn := NewRgn;	if myUpdateRgn = nil THEN GOTO 998;	GetClip (myUpdateRgn);	{ Animazione! }	ticks := TickCount + 6; { Una riga ogni sei tick = 10 righe al secondo }	HideCursor;	REPEAT		ScrollRect (animR, 0, -1, myUpdateRgn);		IF srcRect.bottom <= picR.bottom THEN			CopyBits(bitmapptr(aboutWorld^.portPixMap^)^, qd.thePort^.portBits, srcRect, lineR, srcCopy, nil)				ELSE BEGIN			{ A black line will fill the void }			MoveTo (0, lineR.top);			LineTo (lineR.right, lineR.top);			END;		OffsetRect (srcRect, 0, 1);		{ Rallentiamolo sulle macchine più veloci }		WHILE ticks > TickCount DO			;	 { Wait one more second }		ticks := TickCount + 6;		{ Fine ciclo di ritardo }		IF srcRect.bottom = picR.bottom + 200 THEN			SetRect (srcRect, 0, 0, picR.right, 1);	UNTIL Button;	InitCursor;	{ Liberiamoci dell'offscreen bitmap e del port extra }	DisposeRgn (myUpdateRgn);998:	UnlockPixels (aboutWorld^.portPixMap);	DisposeGWorld (aboutWorld);999:	ReleaseResource (Handle (h));	{ liberiamoci del dialogo }	SetPort (laFinestra);	DisposeDialog (d)END;{$S MkrProcs}PROCEDURE CreateNewScenario;VAR	myReply: StandardFileReply;	aFile: MyFile;	untitled, createAs: String;BEGIN	untitled := GetString(rUntitled)^^;	createAs := GetString(rCreateScenarioAs)^^;	StandardPutFile (createAs, untitled, myReply);	IF myReply.sfGood THEN BEGIN		{ Lasciamo fare tutto a TextIo2, è più semplice }		RewriteRByFSS (aFile, myReply.sfFile, fileTypeScenario3D, fileTypeCreator);		Close (aFile);		IF DoLoadScenario (@aFile.FSS) THEN BEGIN			LoadIcons;			ThereIsDocOpen;			END		ENDEND;{$S Main}PROCEDURE DoClose (w: WindowPtr);BEGIN	CASE TMGetWRefCon (w, 1) OF		-2: { Log }			TMDisposeWindow (w);		-1: { is windoid, makes no sense }			;		0: { E' la finestra principale }			IF displayingPlace THEN				DoClosePlace			ELSE				DoCloseArena		OTHERWISE { E' una finestra di testo }			DoCloseText (w)		END;END;{$S Main}PROCEDURE ScegliMenu(EventoMenu: wmTaskRec);{ restituisce true se l'utente sceglie di uscire }VAR	menu, voce: integer;		BEGIN			menu := HiWrd(EventoMenu.wmTaskData);			voce := LoWrd(EventoMenu.wmTaskData);			CASE menu OF				kAppleMenu: BEGIN							CustomAbout (128);							{ Free memory. This won't be needed often... }							{$IFC MAC68K}							UnloadSeg (@CustomAbout)							{$ENDC}						END;				kFileMenu:					case voce of						kNewScenario: CreateNewScenario;						kOpenScenario:							IF DoLoadScenario (NIL) THEN BEGIN								LoadIcons;								ThereIsDocOpen								END;						kCheckScenario: CheckScenario;						kGrabIcons: GrabIcons;						kCloseScenario: IF CloseWindowEtAl THEN BEGIN							Close (currentScenario);							ThereIsNoDocOpen							END;						kClose: DoClose (TMFrontWindow);						kPageSetup:							DoPageSetup;						kPrint:							IF displayingPlace OR displayingArena THEN								DoPrintWindow;						kQuit: IF CloseWindowEtAl THEN							gQuit := true					end; { case File menu }				kEditMenu: CASE voce OF					kGridlines: BEGIN						gGridlines := NOT gGridlines;						DoCheckItem (menu, voce, gGridlines);						IF displayingPlace OR displayingArena THEN							InvalRect (mainWindow^.portRect)						END;					kShowPict: BEGIN						gShowPICT := NOT gShowPICT;						DoCheckItem (menu, voce, gShowPICT);						InvalRect (mainWindow^.portRect)						END;					END; { keditMenu }				kArenaMenu: CASE voce OF					kNewArena : IF DoNewArena THEN BEGIN						DoWindow;						WindowIsOpen (kArenaMenu, FALSE)						END;					kOpenArena : IF LoadArenaResource (LoadWhat(rChoosePlaceStr, 0, 'Aren'), TRUE) THEN BEGIN						DoWindow;						WindowIsOpen (kArenaMenu, FALSE);						END;					kCloseArena : DoCloseArena;					kSaveArena : SaveArenaResource;					kArenaInfo : IF DoArenaInfoDialog THEN						SetWTitle (mainWindow, ArenaName);					kShowArenaStructure: BEGIN						ShowHideStructure;						SetPort (mainWindow);						InvalRect (mainWindow^.portRect);						DoCheckItem (kArenaMenu, kShowArenaStructure, gStructure);						END;					END;				kPlaceMenu: CASE voce OF					kNewPlace : IF DoNewPlace THEN BEGIN						DoWindow;						WindowIsOpen (kPlaceMenu, placeData[1])						END;					kOpenPlace: IF LoadPlaceResource (LoadWhat(rChoosePlaceStr, 0, 'Plac'), TRUE) THEN BEGIN						IF placeKind = threeD THEN BEGIN							LoadBoxList (placeID); { Non lo faccio dentro LoadPlaceResource perché quella chiamata viene anche fatta da CheckScenario }							LoadLightList (placeID)							END; { if }						DoWindow;						WindowIsOpen (kPlaceMenu, placeData[1]);						END;					kClosePlace : DoClosePlace;					kSavePlace : SavePlaceResource;					kPlaceInfo : IF DoPlaceInfoDialog (FALSE) THEN						SetWTitle (mainWindow, placeName);					kShowPlaceStructure: BEGIN						ShowHideStructure;						InvalRect (mainWindow^.portRect);						DoCheckItem (kPlaceMenu, kShowPlaceStructure, gStructure);						END;					kCrunchPlaceIcons: CrunchPlaceIcons;					END; { place menu }				kSpecialMenu: CASE voce OF					kNewTEXT: DoNewText;					kReadTEXT: LoadTextResource;					END; { special menu }				end; { case barra dei menu }				HiliteMenu (0);		end;{$S Main}PROCEDURE HandleActivation (whose: WindowPtr; activate: Boolean);VAR	fileMenuHandle: MenuHandle;BEGIN	{ Mantieni aggiornato lo status del menu }	fileMenuHandle := GetMenuhandle (kFileMenu);	IF NOT activate AND (TMGetWRefCon (whose, 2) = 1) THEN { Could be closed }		DisableItem (fileMenuHandle, kClose);	IF activate AND (TMGetWRefCon (whose, 2) = 1) THEN { Can be closed }		EnableItem (fileMenuHandle, kClose);END;{$S Main}PROCEDURE MainEventLoop;var	err: OSErr;	theKey: Char;begin	repeat		evento.wmTaskMask := tmEverything;		SetPort (mainWindow);      CASE TaskMaster(everyEvent, NIL, evento) OF      	nullEvent: IF evento.wmTaskData = wTextEditChange THEN      		{ TaskMaster ha modificato il testo. wmTaskData4 contiene il WindowPtr }      		TextWasChanged (WindowPtr (evento.wmTaskData4));			activateEvt:				HandleActivation (WindowPtr (evento.wmTaskData), LoWrd (evento.wmTaskdata2)=1);			wInContentRgn: { Premuta una icona? }				HandleClick (WindowPtr(evento.wmTaskData),					evento.wmWhere,					evento.wmClickCount);			wInInfo: HandleInfoClick (WindowPtr(evento.wmTaskData), evento.wmWhere);			wInControl: { Selezione di uno dei menu della finestra }				IF evento.wmTaskData = longint (mainWindow) THEN					HandleClickInMainWinPopup				ELSE { È una finestrella di testo }					HandleClickInTextInfoBar (ControlHandle (evento.wmTaskData2),						WindowPtr (evento.wmTaskData));			wInGoAwayRgn: { Vuol chiudere una finestra }				DoClose (WindowPtr (evento.wmTaskData));			wSuspend: BEGIN				InitCursor;				gInBackground := true				END;         wResume: BEGIN				InitCursor;				gInBackground := false				END;			keyDown: IF displayingPlace OR displayingArena THEN BEGIN				theKey := chr(BAnd(evento.wmTaskData, charCodeMask));				CASE theKey OF					'F', 'f', 'ƒ': FillWindow (theKey = 'ƒ');					'R', 'r': RadiusPivot					END { case }				END;			wInSpecial,			wInMenuBar:				ScegliMenu(evento);			kHighLevelEvent: begin				err := AEProcessAppleEvent (evento.eventRecord);				if err <> noErr then					NewErrorAlert (kAlertNoteAlert, 0, err)				end		END;	until gQuit;end;VAR	dummy: Boolean;BEGIN { Main }	MaxApplZone; { expand the heap so code segments load at the top }	SMMenusInit;	SMDialogsInit;	InitSMResources;	SMMainInit;	WindoidInit;	{ Windoid richiede TaskMaster }	IOInit;	{$IFC MAC68K}	UnloadSeg(@SMDialogsInit);	{$ENDC}	InitCursor;		REPEAT		MainEventLoop	UNTIL gQuit;	dummy := IOShutdown;END.