UNIT SMUtilities;INTERFACEUSES	Types,	QuickDraw,		Memory,	Resources,	Windows,		SMResources;	FUNCTION BuildClutFor3DPlace (placeID: Integer): CTabHandle;{ Esamina un luogo 3D completato (di cui passiamo l'ID del 3DEn).Costruisce la miglior CTab con i colori richiesti, e la restituisce.ScenarioMaker salverà la risorsa CLUT nello scenario e la assegnerà al 3DEn }PROCEDURE CheckScenario;IMPLEMENTATIONUSES	Appearance,	Errors,	Files,	PictUtils,	StandardFile,	TextEdit,	TextUtils,		BinIO,	Cilindro,	TaskMaster3,		SMErrors,	Windoid,	SMDialogs;	VAR	finestraLog: WindowPtr;	gUsedIcons: IconAttrHdl;FUNCTION BuildClutFor3DPlace (placeID: Integer): CTabHandle;VAR	myPictInfoID: PictInfoID;	myPict: PicHandle;	myPixMapHandle: PixMapHandle;	err: OSErr;		PROCEDURE InitializeClutSubunit;	VAR		err: OSErr;	BEGIN		err := NewPictInfo (myPictInfoID, returnColorTable,			254, popularMethod, 0);		IF err <> noErr THEN BEGIN			BuildClutFor3DPlace := NIL;			Exit (BuildClutFor3DPlace)			END	END;	FUNCTION CloseClutSubunitAndFindResult: CTabHandle;	VAR		result: PictInfo;		err: OSErr;	BEGIN		err := RetrievePictInfo (myPictInfoID, result, 254);		IF err = noErr THEN			CloseClutSubunitAndFindResult := result.theColorTable		ELSE			CloseClutSubunitAndFindResult := NIL;		err := DisposePictInfo (myPictInfoID)	END;BEGIN	{ 0. Inizializzati }	InitializeClutSubunit;		{ 1. Carica il 3DEn. Lo scenario è già aperto. MyGetResource è disponibile. }	{ 2. Carica una per una tutte le picture che verranno mostrate	nel 3DEn, (background, tetto, pavimenti, NPC… )	Per ciascuna di esse - avendo in myPict una PicHandle - chiama: }	err := RecordPictInfo (myPictInfoID, myPict);	{ Se hai delle cicn da aggiungere, inizializzele e passa la loro PixMap: }	err := RecordPixMapInfo (myPictInfoID, myPixMapHandle);		{ 3. Alla fine avrai }	BuildClutFor3DPlace := CloseClutSubunitAndFindResultEND;(*** Check scenario & friends ***){$S MkrProcs}PROCEDURE AddToLog (r: ResType; id: Integer;					own:ResType; ownid, err:Integer);CONST	rErrCodes = 128;	rReferredFrom = 130;VAR	buffer, referredFrom, resCodeAsString: Str255;BEGIN	referredFrom := GetString (rReferredFrom)^^;	resCodeAsString[0] := chr(4); { get ready to create fake 4-char string }	{ Pur error message in window }	GetIndString (buffer, rErrCodes, err);	TEAppendTextRun (finestraLog, buffer);	{ Put bad resource after message }	BlockMoveData (@r, @resCodeAsString[1], 4);	buffer := Concat ('. ', resCodeAsString, ' ', IToS (id));	{ If there's a bad container, add it. }	IF ownId <> 0 THEN BEGIN		BlockMoveData (@own, @resCodeAsString[1], 4);		buffer := Concat (buffer, referredFrom, resCodeAsString, ' ', IToS (ownId));		END;	buffer := Concat (buffer, '.', chReturn); { a capo }	{ Aggiungi la specifica, in corsivo }	TEAppendTextRun (finestraLog, buffer);END; { proc }{$S MkrProcs}PROCEDURE CheckPlaces; { New for v1.3 }TYPE	PlaceInfoHdl = ^PlaceInfoPtr;	PlaceInfoPtr = ^PlaceInfo;	PlaceInfo = RECORD		enclosingPlace,		placeID: Integer;		exists,						{ Was actually found }		connected: Boolean;		{ Another place provides entry }		nextPlace: PlaceInfoHdl		END;VAR	myHandle: handle;	numEntities, i, resID, x, y: INTEGER;	dummy: Str255;	theType: ResType;	root, h: PlaceInfoHdl;		PROCEDURE Enqueue (id, fromID: Integer; forConnection: Boolean);	{ Se si scopre che un place esiste, chiamare Enqueue (id, 0, FALSE).	Se si trova il riferimento a un place, chiamare	Enqueue (idDelPlaceRiferito, idDelPlaceCheNeFaUso, TRUE) }	VAR		scorri, scorriPrec: PlaceInfoHdl;	BEGIN		{ Crealo }		h := PlaceInfoHdl (NewHandle (SizeOf (PlaceInfo)));		WITH h^^ DO BEGIN			placeID := ID;			enclosingPlace := fromID;			IF forConnection THEN BEGIN				connected := TRUE;				exists := FALSE				END			ELSE BEGIN				connected := FALSE;				exists := TRUE				END;			nextPlace := NIL			END;		{ Caso uno. Lista vuota }		IF root = NIL THEN			root := h		{ Caso due. Inserimento in testa }		ELSE IF root^^.placeID >= id THEN BEGIN			IF root^^.placeID = id THEN BEGIN				IF forConnection THEN					root^^.connected := TRUE				ELSE					root^^.exists := TRUE;				DisposeHandle (Handle (h))				END { In testa, c'era }			ELSE BEGIN				h^^.nextPlace := root;				root := h				END { In testa, non c'era }			END { Inserimento in testa }		ELSE BEGIN			scorriPrec := root;			scorri := root^^.nextPlace;			WHILE (scorri <> NIL) & (scorri^^.placeID < id) DO BEGIN				scorriPrec := scorri;				scorri := scorri^^.nextPlace				END; { scorrimento }			IF (scorri <> NIL) & (scorri^^.placeID = id) THEN BEGIN				{ Trovato }				IF forConnection THEN					scorri^^.connected := TRUE				ELSE					scorri^^.exists := TRUE;				DisposeHandle (Handle (h))				END { Trovato }			ELSE { Non c'è, metticelo }				IF scorri = NIL THEN					{ Inserimento in coda }					scorriPrec^^.nextPlace := h				ELSE BEGIN					{ Inserimento nel mezzo }					scorriPrec^^.nextPlace := h;					h^^.nextPlace := scorri					END { Inserimento nel mezzo }			END { List is not empty }	END; { Enqueue }BEGIN	gUsedIcons := IconAttrHdl(NewHandleClear (SizeOf (IconAttr)));  { Deallocata in CheckArenas }	root := NIL;	{ Per Enqueue }	numEntities := Count1Resources('Plac');	FOR i := 1 TO numEntities DO BEGIN		myHandle := Get1IndResource('Plac', i);		IF myHandle <> NIL THEN BEGIN			GetResInfo(myHandle,resID,theType,dummy);			{ Register its existence, if it's not the root }			IF resID <> 1000 THEN				Enqueue (resID, 0, FALSE);			IF LoadPlaceResource (resID, FALSE) THEN BEGIN				{ Checking begins - text and picture for places }				IF (placeTEXTIn <> 0) & ResourceIsMissing ('TEXT', placeTEXTIn) THEN					AddToLog ('TEXT', placeTEXTIn, 'Plac', resID, ckNoTextForPlac);				IF (placeTEXTout <> 0) & ResourceIsMissing ('TEXT', placeTEXTout) THEN					AddToLog ('TEXT', placeTEXTout, 'Plac', resID, ckNoTextForPlac);				IF (placePICTin <> 0) & ResourceIsMissing ('PICT', placePICTin) THEN					AddToLog ('PICT', placePICTin, 'Plac', resID, ckNoPictForPlac);				IF placeData [1] & ResourceIsMissing ('PICT', placeViewPict) THEN					AddToLog ('PICT', placeViewPict, 'Plac', resID, ckNoPictForPlac);				{ If it's a shop, does the Shop description exists? }				IF (placeKind = Shop) & ((ResourceIsMissing ('Shop', placeTime)) | (placeTime = 0)) THEN					AddToLog ('Shop', placeTime, 'Plac', resID, ckNoShopForPlac);				{ If there are wandering monsters, are there the Wndr and Aren }				IF placeData[5] THEN BEGIN					IF ResourceIsMissing ('Wndr', resID) THEN						AddToLog ('Wndr', resID, 'Plac', resID, ckNoWndrForPlac);					IF ResourceIsMissing ('Aren', resID) THEN						AddToLog ('Aren', resID, 'Plac', resID, ckNoArenForPlac);					END;				{ For all place locations }				FOR y := 1 TO placeH DO BEGIN					CursorAnimate;					FOR x := 1 TO placeW DO WITH placeMap^[x,y] DO BEGIN						{ Bug fix DR4 }						IF (placeKind <> threeD) THEN BEGIN							IF (icon >= kFirstIcon) AND (icon <= kLastIcon) THEN								gUsedIcons^^[icon] := TRUE							ELSE								AddToLog ('ICN#', icon, 'Plac', resID, ckWrongID)							END;						{ Qui sotto i test <> 0 sono inutili, ma velocizzano						perché evitano una chiamata di procedura che avverrebbe						quasi sempre }						IF (textToShow <> 0) & ResourceIsMissing ('TEXT', textToShow) THEN							AddToLog ('TEXT', textToShow, 'Plac', resID, ckNoTextForLoc);						IF (itemNeeded <> 0) & ResourceIsMissing ('Obj ', itemNeeded) THEN							AddToLog ('Obj ', itemNeeded, 'Plac', resID, ckNoObjForLoc);						IF characteristics[3] THEN BEGIN { New for DR4 }							IF (encounter = 0) | ResourceIsMissing ('Talk', encounter) THEN								AddToLog ('Talk', encounter, 'Plac', resID, ckNoTalkForLoc)							END						ELSE IF characteristics[5] THEN BEGIN							IF (encounter = 0) | ResourceIsMissing ('Trap', encounter) THEN								AddToLog ('Trap', encounter, 'Plac', resID, ckNoTrapForLoc)							END						ELSE IF characteristics[4] THEN BEGIN							IF (encounter = 0) | ResourceIsMissing ('Ridl', encounter) THEN								AddToLog ('Ridl', encounter, 'Plac', resID, ckNoRidlForLoc)							END						ELSE IF (encounter <> 0) & ResourceIsMissing ('Nctr', encounter) THEN							AddToLog ('Nctr', encounter, 'Plac', resID, ckNoNctrForLoc);						{ Brings to what? }						IF bringsTo > 0 THEN							Enqueue (bringsTo, resID, TRUE); { Found a reference to the place }						CursorAnimate						END; { For all place locations }					END; { for y }				DisposePtr (Ptr(placeMap));				placeMap := NIL;				END; { Place resource was loaded }			END; { Place was found }		ReleaseResource (myHandle);		CursorAnimate		END;		{ OK, now check that all places are accounted for }	WHILE root <> NIL DO BEGIN		IF not root^^.connected THEN			AddToLog ('Plac', root^^.placeID, '    ', 0, ckPlacNotUsed);		IF not root^^.exists THEN			AddToLog ('Plac', root^^.placeID, 'Plac', root^^.enclosingPlace, ckNoPlacForPlac);		h := root^^.nextPlace;		DisposeHandle (Handle (root));		root := h		END; { ScorriLista and check }END;{$S MkrProcs}PROCEDURE CheckArenas;VAR	i, x, y, numEntities, resID: Integer;	theType: ResType;	dummy: Str255;	myHandle: Handle;BEGIN	numEntities := Count1Resources('Aren');	FOR i := 1 TO numEntities DO BEGIN		SetResLoad (FALSE);		myHandle := Get1IndResource('Aren', i);		SetResLoad (TRUE);		IF myHandle <> NIL THEN BEGIN			GetResInfo(myHandle,resID,theType,dummy);			IF LoadArenaResource (resID, FALSE) THEN				FOR x := 1 TO arenaX DO					FOR y := 1 TO arenaY DO						WITH arena[x, y] DO							IF (icon >= kFirstIcon) AND (icon <= kLastIcon) THEN								gUsedIcons^^[icon] := TRUE							ELSE								AddToLog ('ICN#', icon, 'Aren', resID, ckWrongID)			END; { found }		END; { for }	{ And check that all icons are used }	i := kFirstIcon;	x := 0;	REPEAT		{ Trova la prima icona non usata }		WHILE gUsedIcons^^[i] DO			i := succ (i);		IF ResourceIsMissing ('ICN#', i) THEN			x := 1		ELSE BEGIN			AddToLog ('ICN#', i, '    ', 0, ckUnusedIcon);			i := succ (i)			END;	UNTIL x <> 0;	DisposeHandle (Handle (gUsedIcons)) { Allocata in CheckPlaces }END;{$S MkrProcs}PROCEDURE OpenAllResAndDoThis (theType: resType; PROCEDURE	This (theHandle: Handle; theID: Integer));VAR	myHandle: handle;	numEntities,	i, resID: INTEGER;	dummy: Str255;BEGIN	numEntities := Count1Resources(theType);	FOR i := 1 TO numEntities DO BEGIN		myHandle := Get1IndResource(theType, i);		IF myHandle <> NIL THEN BEGIN			GetResInfo(myHandle,resID,theType,dummy);			This (myHandle, resID);			END;		ReleaseResource (myHandle);		CursorAnimate		END;END;{$S MkrProcs}PROCEDURE CheckIcl8 (theIcon: Handle; iconID: Integer);BEGIN	{$UNUSED theIcon}	IF ResourceIsMissing ('ICN#', iconID) THEN		AddToLog ('icl8', iconID, '    ', 0, ckNoICN);END;{$S MkrProcs}PROCEDURE CheckIcl4 (theIcon: Handle; iconID: Integer);BEGIN	{$UNUSED theIcon}	IF ResourceIsMissing ('ICN#', iconID) THEN		AddToLog ('icl4', iconID, '    ', 0, ckNoICN);END;{$S MkrProcs}PROCEDURE CheckWndrAndMstr (theWndr: Handle; wndrID: Integer);VAR	wndrScanner: Ptr;	numItems, id, i: Integer;BEGIN	wndrScanner := StripAddress(theWndr^);	{ la prima cosa nella risorsa è il numero dei mostri. Si conta da 0}	numItems := GetIntegerFromRes (wndrScanner);	{ OK, cominciamo la lettura }	FOR i := 0 TO numItems DO BEGIN		id := GetIntegerFromRes (wndrScanner);		IF ResourceIsMissing ('Mstr', id) THEN			AddToLog ('Mstr', id, 'Wndr', wndrID, ckNoMstrForWndr);		END; { Ciclo lettura }END;{$S MkrProcs}PROCEDURE CheckShopsAndObjs (theShop: Handle; shopID: Integer);{ Basato su DoLoadShop di GraphEngine 1.1d13 }VAR	shopScanner: Ptr;	numItemsForSell, id, i: Integer;BEGIN	shopScanner := StripAddress(theShop^);	{ la prima cosa nella risorsa è il numero degli oggetti in vendita. Si conta da 0}	numItemsForSell := GetIntegerFromRes (shopScanner);	{ OK, cominciamo la lettura }	FOR i := 0 TO numItemsForSell DO BEGIN		id := GetIntegerFromRes (shopScanner);		IF ResourceIsMissing ('Obj ', id) THEN			AddToLog ('Obj ', id, 'Shop', shopID, ckNoObjForShop);		END; { Ciclo lettura oggetti }END;{$S MkrProcs}PROCEDURE CheckAddb (theAddb: Handle; abbdID: Integer);CONST	kNumResTypesToCheck = 7;VAR	addbScanner: Ptr;	numItems, i, id: Integer;	theType: ResType;		correctResTypes: ARRAY [1..kNumResTypesToCheck] OF ResType;		FUNCTION IsResTypeUnacceptable (whichOne: ResType): Boolean;	VAR		result : Boolean; i: Integer;	BEGIN		result := TRUE;		FOR i := 1 TO kNumResTypesToCheck DO			IF whichOne = correctResTypes[i] THEN				result := FALSE;		IsResTypeUnacceptable := result	END;BEGIN	correctResTypes[1] := 'Mstr';	correctResTypes[2] := 'Obj ';	correctResTypes[3] := 'Spel';	correctResTypes[4] := 'ICN#';	correctResTypes[5] := 'icl4';	correctResTypes[6] := 'icl8';	correctResTypes[7] := 'MDeL';	addbScanner := StripAddress(theAddb^);	{ la prima cosa nella risorsa è il numero degli item. Si conta da 0}	numItems := GetIntegerFromRes (addbScanner);	{ OK, cominciamo la lettura }	FOR i := 0 TO numItems DO BEGIN		theType := ResType (GetLongintFromRes (addbScanner));		id := GetIntegerFromRes (addbScanner);		IF ResourceIsMissing (theType, id) THEN			AddToLog (theType, id, 'AdDB', abbdID, ckNoRsrcForAdDB);		IF IsResTypeUnacceptable (theType) THEN			AddToLog (theType, id, 'AdDB', abbdID, ckUnacceptableAdDB);		END; { Ciclo lettura oggetti }END;{$S MkrProcs}PROCEDURE CheckMdel (theMdel: Handle; mdelID: Integer);{ Basato sulla definizione di Mdel as of 1.1d13 }VAR	mdelScanner: Ptr;	numItems, direct, indirect, i: Integer;	action: Char;	spare: Byte;BEGIN	mdelScanner := StripAddress(theMdel^);	{ la prima cosa nella risorsa è il numero degli item. Si conta da 0}	numItems := GetIntegerFromRes (mdelScanner);	{ OK, cominciamo la lettura }	FOR i := 0 TO numItems DO BEGIN		spare := GetByteFromRes (mdelScanner);		action := Chr (GetByteFromRes (mdelScanner));		direct := GetIntegerFromRes (mdelScanner);		indirect := GetIntegerFromRes (mdelScanner);		CASE action OF			'0'..'9', 'I': IF (direct <> 0) OR (indirect <> 0) THEN				AddToLog ('move', i, 'MDeL', MdelID, ckParamMustBe0);			'S':  BEGIN				IF ResourceIsMissing ('TEXT', direct) THEN					AddToLog ('TEXT', direct, 'MDeL', MdelID, ckNoTEXTForMDeL);				IF ResourceIsMissing ('Snd ', indirect) THEN					AddToLog ('Snd ', indirect, 'MDeL', MdelID, ckNoSndForMDeL);				END; { S }			'K': BEGIN				IF ResourceIsMissing ('Spel', direct) THEN					AddToLog ('Spel', direct, 'MDeL', MdelID, ckNoSpelForMDeL);				IF (direct < 0) OR (direct > 100) THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamUncorrect)				END;			'F': BEGIN				IF (direct < 0) OR (direct > 31) THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamUncorrect);				IF indirect <> 0 THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamMustBe0);				END;			'M': BEGIN				IF (direct < 0) OR (direct > 99) THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamUncorrect);				IF indirect <> 0 THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamMustBe0);				END;			'?': IF (direct < 0) OR (indirect < 0) THEN					AddToLog ('move', i, 'MDeL', MdelID, ckParamUncorrect);			OTHERWISE AddToLog ('move', i, 'MDeL', MdelID, ckUnknownAction);			END; { case }		END; { Ciclo lettura }END;{$S MkrProcs}PROCEDURE CheckObjIconsAndMore (theObj: Handle; objID: Integer);VAR	iconID, spellID, specifics: Integer;	objScanner: Ptr;BEGIN	objScanner := StripAddress(theObj^);	iconID := GetIntegerFromRes (objScanner);	IF ResourceIsMissing ('ICN#', iconID) THEN		AddToLog ('ICN#', iconID, 'Obj ', objID, ckNoIconForObj);	{ If it's a magic item... }	specifics := GetIntegerFromRes (objScanner);	spellID := GetIntegerFromRes (objScanner);	IF BAnd (specifics, $8020) = $8020 THEN		{ Scroll. Check that the related spell exists }		IF ResourceIsMissing ('Spel', spellID) THEN			AddToLog ('Spel', spellID, 'Obj ', objID, ckNoSpellForScroll);END;{$S MkrProcs}PROCEDURE CheckTrap (theTrap: Handle; trapID: Integer);VAR	trapScanner: Ptr;	id, i: Integer;BEGIN	trapScanner := StripAddress(theTrap^);	{ I primi sei byte non mi interessano }	id := GetIntegerFromRes (trapScanner);	id := GetIntegerFromRes (trapScanner);	id := GetIntegerFromRes (trapScanner);	{ Segue: num incantesimo correlato, testo associato 1 e 2 }	id := GetIntegerFromRes (trapScanner);	IF ResourceIsMissing ('Spel', id) THEN		AddToLog ('Spel', id, 'Trap', trapID, ckNoSpelForTrap);	FOR i := 1 TO 2 DO BEGIN		id := GetIntegerFromRes (trapScanner);		IF ResourceIsMissing ('TEXT', id) THEN			AddToLog ('TEXT', id, 'Trap', trapID, ckNoTextForTrap)		ENDEND;{$S MkrProcs}PROCEDURE CheckRiddle (theRidl: Handle; ridlID: Integer);VAR	ridlScanner: Ptr;	id, i: Integer;	buffer: Str255;BEGIN	ridlScanner := StripAddress(theRidl^);	{ I primi due byte non mi interessano }	id := GetIntegerFromRes (ridlScanner);	{ Né le tre stringhe seguenti }	FOR i := 1 TO 3 DO		buffer := GetStringFromRes (ridlScanner);	{ Segue: 3 encounter id }	FOR i := 1 TO 3 DO BEGIN		id := GetIntegerFromRes (ridlScanner);		IF ResourceIsMissing ('Nctr', id) THEN			AddToLog ('Nctr', id, 'Ridl', ridlID, ckNoNctrForRidl)		ENDEND;{$S MkrProcs}PROCEDURE CheckMstrIcons (theObj: Handle; objID: Integer);TYPE	IntPtr = ^Integer;CONST	kOffsetToNameField = $000E;	kOffsetToIconField = $000F;VAR	id: Integer;	j: Byte;BEGIN	{ Trova la lunghezza del nome }	j := Ptr(Longint(theObj^) + kOffsetToNameField)^;	{ L'icona sta dopo il nome }	id := IntPtr(Longint(theObj^) + kOffsetToIconField + j)^;	IF ResourceIsMissing ('ICN#', id) THEN		AddToLog ('ICN#', id, 'Mstr', objID, ckNoIconForMstr);END;{$S MkrProcs}PROCEDURE CheckSpells (theSpel: Handle; spelID: Integer);TYPE	IntPtr = ^Integer;CONST	kOffsetToCompField = $000D;	kOffsetToNameField = $0011;	kOffsetToIconField = $0012;	{ Da DreamTypes 1.1d13 }	kItmHolyWater = 128;	kItmAmber = 129;	kItmBatGuano = 130;	kItmGlassLens = 132;	kItmMagnet = 133;	kItmMushRoom = 134;	kItmQuickSilver = 135;	kItmMirror = 136;	kItmIronRations = 138;	kItmRations = 200;	kItmCurePotion = 201;VAR	id: Integer;	j: Byte;	setCompMat: SET OF kItmHolyWater..kItmCurePotion;BEGIN	{ Ricorda quali sono i componenti materiali standard }	setCompMat := [kItmHolyWater, kItmAmber, kItmBatGuano,		kItmGlassLens, kItmMagnet, kItmMushRoom, kItmQuickSilver,		kItmMirror, kItmIronRations, kItmRations, kItmCurePotion];	{ Trova il componente materiale }	id := IntPtr(Longint(theSpel^) + kOffsetToCompField)^;	{ Se non è uno di quelli standard e non esiste incazzati }	IF (id <> 0) & NOT (id IN setCompMat) & ResourceIsMissing ('Obj ', id) THEN		AddToLog ('Obj ', id, 'Spel', spelID, ckNoObjForSpel);	{ Trova la lunghezza del nome }	j := Ptr(Longint(theSpel^) + kOffsetToNameField)^;	{ L'icona sta dopo il nome }	id := IntPtr(Longint(theSpel^) + kOffsetToIconField + j)^;	IF ResourceIsMissing ('ICN#', id) THEN		AddToLog ('ICN#', id, 'Spel', spelID, ckNoIconForSpel)END;{$S MkrProcs}PROCEDURE CheckEncounters (theNctr: Handle; nctrID: Integer);{ Basato su SetupEncounter di FightingSystem 1.1d13 }VAR	nctrPtr: Ptr;	numItems, id, i, j: Integer;	nctrIsVersion2: Boolean;BEGIN	nctrPtr := StripAddress(theNctr^);	{ Is this a version 1.1, and following, encounter type? }	j := GetByteFromRes (nctrPtr);	nctrIsVersion2 := BTst (j, 7);	{ Is some item necessary? }	id := GetIntegerFromRes (nctrPtr);	IF id <> 0 THEN		IF ResourceIsMissing ('Obj ', id) THEN			AddToLog ('Obj ', id, 'Nctr', nctrID, ckNoObjForNctr);	{ L'arena }	id := GetIntegerFromRes (nctrPtr);	IF ResourceIsMissing ('Aren', id) THEN		AddToLog ('Aren', id, 'Nctr', nctrID, ckNoArenForNctr);	{ Il formato della risorsa qui cambia nel caso di Dream 1.1 e	successivi. }	numItems := GetIntegerFromRes (nctrPtr);	IF nctrIsVersion2 THEN		FOR i := 0 TO numItems DO BEGIN			id := GetIntegerFromRes (nctrPtr); { Monster res ID }			IF ResourceIsMissing ('Mstr', id) THEN				AddToLog ('Mstr', id, 'Nctr', nctrID, ckNoMstrForNctr);			j := GetIntegerFromRes (nctrPtr); { x, y }			j := GetIntegerFromRes (nctrPtr); { tactics, nr }			id := GetIntegerFromRes (nctrPtr); { MDeL ID }			IF ResourceIsMissing ('MDeL', id) THEN				AddToLog ('MDeL', id, 'MDeL', nctrID, ckNoMDeLForNctr);			END	ELSE		FOR i := 0 TO numItems DO BEGIN			id := GetIntegerFromRes (nctrPtr); { Monster res ID }			IF ResourceIsMissing ('Mstr', id) THEN				AddToLog ('Mstr', id, 'Nctr', nctrID, ckNoMstrForNctr);			j := GetIntegerFromRes (nctrPtr); { nr, spare }			END;	j := GetIntegerFromRes (nctrPtr);	{ treasure in GP }	{ Ora il tesoro che questo incontro ci riserva.}	numItems := GetIntegerFromRes (nctrPtr);	FOR i := 0 TO numItems DO BEGIN		id := GetIntegerFromRes (nctrPtr); { Monster res ID }		IF ResourceIsMissing ('Obj ', id) THEN			AddToLog ('Obj ', id, 'Nctr', nctrID, ckNoObjForNctr);		END;	{ In fondo c'è lo ID del testo da far apparire. }	id := GetIntegerFromRes (nctrPtr);	IF ResourceIsMissing ('TEXT', id) THEN		AddToLog ('TEXT', id, 'Nctr', nctrID, ckNoTextForNctr);END;{$S MkrProcs}PROCEDURE DoDiagnostics;CONST	nothing = '    ';VAR	i: Integer;	theType: ResType;	PROCEDURE OpenDreamDB;	CONST		customGetFileDITL = 250;		resDreamDB = 250;	{ Stringa 'Dream DB' }	VAR		dreamDBName: Str255;		myFileList: SFTypeList;		myReply: StandardFileReply;		p: point;		dreamDBFSS: FSSpec;	BEGIN		{ Se già aperto, esci senza fare nulla }		IF dreamDB.resFork <> 0 THEN			Exit (OpenDreamDB);		{ Chiudi temporaneamente lo scenario di modo che il dream db sia solo		il penultimo res file nella catena delle risorse }		CloseResFile (currentScenario.resFork);			{ OK, trova e apri }		dreamDBName := GetString(resDreamDB)^^;		IF FsMakeFSSpec (0, 0, dreamDBName, dreamDBFSS) <> noErr THEN BEGIN			myFileList[0] := 'ADdb';			p.v := -1; p.h := -1;			CustomGetFile (nil, 1, @myFileList, myReply,				customGetFileDITL, p,				NIL, NIL, NIL, NIL, NIL);				IF myReply.sfGood THEN					dreamDBFSS := myReply.sfFile				ELSE					DeathAlert (errNeedDreamDB, 0)			END;		ResetRByFss (dreamDB, dreamDBFSS);		{ Riapri lo scenario }		WITH currentScenario DO			resFork := FSpOpenResFile (FSS, fsCurPerm)		END;	PROCEDURE CheckIDs (resHdl: Handle; resID: Integer);	BEGIN		{$UNUSED resHdl}		IF resID < 1000 THEN			IF (theType <> 'vers') AND (theType <> 'SMkr') THEN				AddToLog (theType, resID, nothing, 0, ckOverride);		IF resID > 10000 THEN			AddToLog (theType, resID, nothing, 0, ckWrongID)	END;BEGIN	CursorInit;	{numErrors := 0;}	OpenDreamDB;	{ Info }	IF ResourceIsMissing ('Info', 1000) THEN		AddToLog ('Info', 1000, nothing, 0, ckNoInfo);	{ v 1.1 or following? }	(* OBSOLETED FOR V2.0	IF (ResourceKindExists ('MDeL', idOfResFound)) THEN		AddToLog ('MDeL', idOfResFound, nothing, 0, ckContainsV11Data);	IF (ResourceKindExists ('AdDB', idOfResFound)) THEN		AddToLog ('AdDB', idOfResFound, nothing, 0, ckContainsV11Data);	IF (ResourceKindExists ('Trap', idOfResFound)) THEN		AddToLog ('Trap', idOfResFound, nothing, 0, ckContainsV11Data);	IF (ResourceKindExists ('Ridl', idOfResFound)) THEN		AddToLog ('Ridl', idOfResFound, nothing, 0, ckContainsV11Data);	IF (ResourceKindExists ('Menu', idOfResFound)) THEN		AddToLog ('Menu', idOfResFound, nothing, 0, ckContainsV11Data);	IF (ResourceKindExists ('Char', idOfResFound)) THEN		AddToLog ('Char', idOfResFound, nothing, 0, ckContainsV11Data);	*)	{ Is there a place, ID 1000? }	IF ResourceIsMissing ('Plac', 1000) THEN		AddToLog ('Plac', 1000, '    ', 0, ckNoPlace1000);	{ About text & pict }	IF ResourceIsMissing ('TEXT', 1128) THEN		AddToLog ('TEXT', 1128, '    ', 0, ckNoAboutText);	IF ResourceIsMissing ('PICT', 1128) THEN		AddToLog ('PICT', 1128, '    ', 0, ckNoAboutPict);	{ The objects listed for the shops exist? }	OpenAllResAndDoThis ('Shop', CheckShopsAndObjs);	{ The monsters and treasures listed for the encounters exist? }	OpenAllResAndDoThis ('Nctr', CheckEncounters);	{ Are all IDs correct? }	FOR i := 1 TO Count1Types DO BEGIN		Get1IndType(theType, i);		OpenAllResAndDoThis (theType, CheckIDs);		END;	{ Are there the icons for the objects?	If the object is a scroll, does there exist the related spell? }	OpenAllResAndDoThis ('Obj ', CheckObjIconsAndMore);	{ And for the monsters? }	OpenAllResAndDoThis ('Mstr', CheckMstrIcons);	{ The monsters listed for the random encounters exist? }	OpenAllResAndDoThis ('Wndr', CheckWndrAndMstr);	{ All right within the traps? }	OpenAllResAndDoThis ('Trap', CheckTrap);	{ What about the riddles? }	OpenAllResAndDoThis ('Ridl', CheckRiddle);	{ Are there B/W icons for all color icons? }	OpenAllResAndDoThis ('icl8', CheckIcl8);	OpenAllResAndDoThis ('icl4', CheckIcl4);	{ Place check }	IF NOT displayingPlace AND NOT displayingArena THEN BEGIN		CheckPlaces;		CheckArenas		END;	{ That's all, folks }	InitCursor;END;{$S MkrProcs}PROCEDURE CheckScenario;BEGIN	IF displayingPlace OR displayingArena THEN		NewErrorAlert (kAlertNoteAlert, errCloseWindowBeforeCheck, 0)	ELSE BEGIN		{ Crea nuova finestra… }		finestraLog := GetNewCWindow(rTextWindowPrototype+ord(gHasThemes)*1000, nil, nil);		if finestraLog = nil then			DeathAlert (errMissingApplRes, resNotFound);		TMNewWindow (finestraLog,			fContainsTextEdit+fGrow+fRScroll,			kLogfileRefcon,				{ ref con }			12, 300,			1024, 640,			200, 300,			12, 48, 0, 0, 			0,										{ Info bar height }			NIL, NIL);		DoDiagnostics;		TMSelectWindow (finestraLog);		ShowWindow (finestraLog);		END; { if check can be done }END;END.