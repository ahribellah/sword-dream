Unit SMDialogs;INTERFACEUSES	Types,	QuickDraw,	QDOffscreen,	Dialogs,	Lists,		Lista3;CONST	kMaxBoxesIn3D = 256;	rSaveChangesAlert = 134;		kYesSave = 1;		kCancelSave = 2;		kNoSave = 3;		kNumItemsInChangeAlert = 3;	rMainWindow = 128;TYPE	{ Servono anche a SMResources }	BitsInByte = PACKED ARRAY [0..7] OF Boolean;	BitsInWord = PACKED ARRAY [0..15] OF Boolean;	TBoxInfo = RECORD		boxID, iconID: Integer; { iconID non è usato per i box, ma solo per le light }		boxPos: rect;	{ Internamente salvato in pixel (coordinate video)							{ Su disco diverranno coordinate DblPt }		boxName: Str31		END;	T3DBoxes = RECORD		numBoxes: 0..kMaxBoxesIn3D;		boxes: ARRAY [1..kMaxBoxesIn3D] OF TBoxInfo		END;VAR	g3DBoxesHere, g3DLightsHere: T3DBoxes;	world: GWorldPtr; { GWorld per i place }	currentWorldDepth: Integer;	{ Depth (in bits per pixel) of the place }	worldBoundsInPixel: Rect; { Current size of the GWorld }	{ DEFINIZIONE di place }CONST	{ Maximum size of a place }	kMaxWorldH = 95;	kMaxWorldW = 95;TYPE	MapLocation = PACKED RECORD		icon: integer;		bringsTo: integer;		encounter: integer;		characteristics: BitsInByte;			{ [7] is impassable,			[6] search is required to have the encounter			[5] is trapped			[4] has riddle			[3] has dialog (new for v2)			[0] is known to group }		spare: Byte;		textToShow: Integer;		itemNeeded: Integer;		END;	Map =  PACKED ARRAY [1..kMaxWorldW, 1..kMaxWorldH] of MapLocation;	MapPtr = ^Map;{ IMPLEMENTAZIONE di place }VAR	placeID: INTEGER;			{ Res ID of place }	placeMap: MapPtr;			{ The map of the place where the group is }	placeName: Str255;			{ WARNING! MUST BE 30 CHARS OR LESS! }	placeW, placeH: integer;	{ Should be byte, but… }	placeTime: integer;			{ Time to move one unit }	placeTEXTIn,	placeTEXTout,	placePICTin,	placeViewPict: integer;	placeData: BitsInByte;		{ [7] must be saved on exit		[6] light is needed here		[5] has wandering monsters		[4] is underground		[3] is shop		[2] is special		[1] Use Pict instead of icons to represent		[0] Show all immediately upon entry }	morePlaceData: BitsInWord;		{ [15]: is indoors 		[14] Use small icon for group		[13] Use custom music (same ID as place) - NEW for v2.1 }	{ RESOURCE CONVENTION:		If place is shop, then placeTime is shop item list resID.		If place is special (shrine, temple, etc) then placeTime is kind of			place (that is, ord(SpecialPlace)).		DoLoadPlace, when loading, rationalizes things using the globals:}{ definizione di arena }CONST 	maxLocArena = 140;	maxLocX = 14;	maxLocY = 10;TYPE	ArenaLocation = PACKED RECORD		icon: INTEGER;		specs: BitsInByte;			{ [7] is impassable			[6] is unholy			[5] is holy			[4] slows			[3] is antimagic			}					spare: Byte		END;{ Implementazione di arena }VAR	arenaID,	arenaX, arenaY, arenaPict: Integer;	arenaName: Str255;	arena: ARRAY [1..maxLocX, 1..maxLocY] of ArenaLocation;	l: ListInfoRec;	{ Per DrawList }PROCEDURE SMDialogsInit;{ Inizializza la unit }FUNCTION DoPlaceInfoDialog (placeIsBrandNew: Boolean): BOOLEAN;{ Da chiamare quando l'utente sceglie "Place Info" dal menu Places.Espone il place info dialog. Restituisce TRUE se alla fine l'utente ha premuto OK }PROCEDURE DoPlaceLocDialog (x, y: INTEGER; globalPtClicked: Point);{ Da chiamare quando l'utente fa doppio click sulla icona x, y della mappa }FUNCTION DoNewPlace: Boolean;{ Da chiamare quando l'utente sceglie New dal menu Places.Restituisce true se l'utente ha confermato la creazione del nuovo place }PROCEDURE DoArenaLocDialog (x, y: INTEGER);FUNCTION DoArenaInfoDialog: BOOLEAN;FUNCTION DoNewArena: Boolean;{ Idem cum patatis per le arene }PROCEDURE DoNewText;{ Idem cum patatis per i testi }FUNCTION LoadWhat (prompt, default: Integer; kind: ResType): INTEGER;{ Finestra di dialogo per scegliere quale risorsa caricare. Default è il resID della riorsa da preselezionare }PROCEDURE DrawList (where: DialogPtr; item: INTEGER);{ defproc usata da LoadWhat e pubblicata per il riuso }PROCEDURE Do3DPlaceStartDialog;{ Finestra di dialogo che consente di definire le posizioni di partenza del giocatore }PROCEDURE DoWindow;{ Fa apparire la finestra. Da chiamare dopo aver creato un nuovo place conDoNewPlace o DoNewArena; oppure dopo averne caricato uno pre-esistente conLoadPlaceResource o LoadArenaResource }PROCEDURE DrawWindow (myWin: WindowPtr);{ Procedura che definisce la finestra. Esportata per il codice di stampa }FUNCTION HasColor (bitsPerPixel: Byte): boolean;FUNCTION MakeGWorld: Boolean;{ Crea un GWorld per il place, basato sui valore di placeW e placeH.Restituisce TRUE se tutto è andato bene.Il GWorld è sempre creato in 256 colori }FUNCTION PlotPlaceGWorld: Boolean;{ Chiama MakeGWorld, e lo plotta via RedrawGWorld }PROCEDURE RedrawGWorld;{ Disegna il place dentro il GWorld. Gestisce correttamente anche le locazioniin cui icon = 0 }PROCEDURE PosterizeGWorld;{ Appiattisce il GWorld sul numero di colori supportato dal Mac }IMPLEMENTATIONUSES	Appearance,	Controls,	Drag,	Errors,	Events,	GestaltEqu,	Icons,	Memory,	Menus,	OSUtils,	QuickdrawText,	Resources,	Script,	SegLoad,	TextEdit,	TextUtils,	ToolUtils,	{ List 3 - needs List 1/2 types }	Files,				{ needs OSUtils, SegLoad }	Windows,			{ needs Events, Controls }	{ List 4 - needs List 1/2/3 types }		Cilindro,	BinIo,	DialogLord4,	TaskMaster3,		SMErrors,	SMMenus,	Windoid;CONST	kEventIcon = 10992;	kDialogIcon = 10993;	kRiddleHereIcon = 10994;	kKeyIcon = 10995;	kTrapHereIcon = 10996;	kTextMarkIcon = 10998;	kEncounterMarkIcon = 10999;	kTakesToMarkIcon = 11000;VAR	myLightGrey, myDarkGrey: PixPatHandle;{$S MkrProcs}PROCEDURE DrawList (where: DialogPtr; item: INTEGER);BEGIN	Ridisegna (l);END;{$S MkrProcs}VAR whatToPreview: Integer; { parametro implicito alle procedure di preview }PROCEDURE DrawPreviewPict (where: DialogPtr; item: INTEGER);VAR	myRect, pictRect: Rect;	mySpace, pictSpace: Point;	scaleX, scaleY, myScale: Real;	myHandle: PicHandle;BEGIN	if whatToPreview <> 0 THEN BEGIN		myHandle := PicHandle (Get1IndResource('PICT', whatToPreview)); { Non posso usare getpicture, che vuole lo ID }		{ Get info on available space and rect proper size }		GetItemRect (where, item, myRect);		EraseRect (myRect);		pictRect := myHandle^^.PicFrame;		WITH mySpace, myRect DO BEGIN			h := right - left;			v := bottom - top;			END;		WITH pictSpace, pictRect DO BEGIN			h := right - left;			v := bottom - top;			END;		{ Choose which scale to use }		scaleX := pictSpace.h / mySpace.h;		scaleY := pictSpace.v / mySpace.v;		myScale := scaleX;		IF scaleY > myScale THEN myScale := scaleY;		IF myScale < 1 THEN myScale := 1; { Se la PICT è piccola... }		{ Scale the pict to size }		WITH pictSpace, myRect DO BEGIN			right := left + Round (h / myScale);			bottom := top + Round (v / myScale)			END;		{ Draw the picture in the scaled size }		DrawPicture (myHandle, myRect);		ReleaseResource (Handle (myHandle));	ENDEND;PROCEDURE DrawPreviewText (where: DialogPtr; item: INTEGER);CONST	myType = 'TEXT';VAR	myRect: Rect;	theTextSize, theFont: Longint;	textHandle: Handle;	oldFont, oldSize: Integer;BEGIN	if whatToPreview <> 0 THEN BEGIN		textHandle := Get1IndResource(myType, whatToPreview);		HLock (textHandle);		theTextSize := GetHandleSize (textHandle);		GetItemRect (where, item, myRect);		oldFont := where^.txFont;		oldSize := where^.txSize;		theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);		TextFont (HiWrd (theFont));		TextSize (LoWrd (theFont));		TETextBox (textHandle^, theTextSize, myRect, teFlushDefault);		TextFont (oldFont);		TextSize (oldSize);		ReleaseResource (textHandle);	ENDEND;{$S MkrProcs}PROCEDURE DrawPreviewCicn (where: DialogPtr; item: INTEGER);CONST	myType = 'cicn';VAR	myRect: Rect;	dummyHandle: Handle;	iconID: Integer;	iconName: Str255;	iconType: ResType;	grandeHandle: CIconHandle;BEGIN	if whatToPreview <> 0 THEN BEGIN		{ Find space }		GetItemRect (where, item, myRect);		myRect.bottom := myRect.top + 64;		myRect.right := myRect.left + 64;		EraseRect (myRect); { In caso la mask non sia piena }		{ Find ID }		SetResLoad (FALSE);		dummyHandle := Get1IndResource (myType, whatToPreview);	{ Preload resource }		GetResInfo (dummyHandle, iconID, iconType, iconName); { Find its resource ID }		ReleaseResource (dummyHandle);		SetResLoad (TRUE);		{ Get icon }		grandeHandle := GetCIcon (iconID);		IF grandeHandle <> NIL THEN BEGIN			PlotCicon (myRect, grandeHandle);			DisposeCicon (grandeHandle);			END { icona trovata }		END { should preview }END;{$S MkrProcs}FUNCTION LoadWhat (prompt, default: Integer; kind: ResType): INTEGER;CONST	rLoadWhatDialog = 133;	rLoadWhatWithPreview = 134;		kListItem = 4;		kPreviewItem = 7;		kTotalNumItems = 7;VAR	doPreview: Boolean;	s: Str255;	myDialog: DialogPtr;	empty,	finalButtons: Family;	buffer: str255;	e: Eventrecord;	theType: ResType;	numResources, loopResources, theID, serialForDefault, r: INTEGER;	{ Per la lista coi nomi delle risorse }	dummyHandle: Handle;	listaRect: Rect;	c: Cell;BEGIN	{ Setup dialogo }	serialForDefault := 0;	GetIndString(s, rPrompts, prompt);	ParamText (s, '', '', '');	{ Setup preview }	doPreview := (kind = 'TEXT') or (kind = 'cicn') or (kind = 'PICT');	IF doPreview THEN BEGIN { add preview }		myDialog := GetNewDialog (rLoadWhatWithPreview, NIL, WindowPtr(-1));		whatToPreview := 0;		{install draw proc}		CASE Longint (kind) OF			Longint('TEXT'):				SetItemProcedure (myDialog, kPreviewItem, @DrawPreviewText);			Longint ('PICT'):				SetItemProcedure (myDialog, kPreviewItem, @DrawPreviewPict);			Longint ('cicn'):				SetItemProcedure (myDialog, kPreviewItem, @DrawPreviewCicn);			END;		END	ELSE { no preview }		myDialog := GetNewDialog(rLoadWhatDialog,NIL,WindowPtr(-1));	SetPort (myDialog);	DisableDialogItem (myDialog, kStdOkItemIndex); { Until the chooses a resource, no OK }	DefaultButton (myDialog, FALSE);	ClearFamily (empty);	finalButtons := empty;	finalButtons[kListItem] := TRUE;	finalButtons[kStdOkItemIndex] := TRUE;	finalButtons[kStdCancelItemIndex] := TRUE;	{ Set the draw procedures for my user item }	SetItemProcedure (myDialog, kListItem, @DrawList); {install draw proc}	{ setup lista }	GetItemRect (myDialog, kListItem, listaRect);	l := NuovaLista (myDialog, listaRect, 1, WantVScroll+WantAutoScroll,		LOnlyOne + LNoNilHilite);	c.h := 0;		{ Load lista }	numResources := Count1Resources(kind);	{ Se gli item sono parecchi, il ciclo sfarfalla. Quindi		disabilito temporaneamente il ridisegno sulla lista }	LSetDrawingMode (FALSE, l.theList);	{ Evita di caricare tutto l'item per nulla… }	FOR loopResources := 1 TO numResources DO BEGIN		c.v := loopResources - 1;		SetResLoad (FALSE);		dummyHandle := Get1IndResource(kind, loopResources);		SetResLoad (TRUE);		GetResInfo(dummyHandle,theID,theType,buffer);		IF theID = default THEN	{ trovato l'elemento di default }			serialForDefault := loopResources;		{ Aggiungi il numero per maggior chiarezza }		buffer := Concat (IToS(theID), ': ', buffer);		NuovaCella (l, c, @buffer);		ReleaseResource (dummyHandle)		END;	{ Se abbiamo trovato il default, selezionalo }	IF serialForDefault > 0 THEN BEGIN		c.v := serialForDefault-1;		LSetSelect (TRUE, c, l.theList);		LScroll (0, serialForDefault - 5, l.theList); { Metti in vista il default }		END;	{ Disegna correttamente la lista }	LSetDrawingMode (TRUE, l.theList);		{ Dialog }	REPEAT		r := DialogLord (myDialog, kTotalNumItems, empty, empty,			finalButtons, empty, empty, empty, empty, 5, e);		IF r = kListItem THEN			CASE FindList (@l, e, c, NIL) OF				DoubleClick: r := OK;				Click: IF c.v < numResources THEN BEGIN					EnableDialogItem (myDialog, kStdOkItemIndex); { Until the chooses a resource, no OK }					IF doPreview THEN BEGIN						whatToPreview := c.v+1;						GetItemRect (myDialog, kPreviewItem, listaRect);						InvalRect (listaRect)						END { if }					END; { click }				END { case }	UNTIL (r <= kStdCancelItemIndex);	IF (r = kStdOkItemIndex) AND DammiCella (l, c) THEN BEGIN		dummyHandle := Get1IndResource(kind, c.v+1);	{ Preload resource }		GetResInfo(dummyHandle,theID,theType,buffer); { Find its resource ID }		LoadWhat := theID							{ Restituisci risultato }		END	ELSE		LoadWhat := default; { Variante per DR5 }	{ Uccidi lista }	ResetItemProcedure (myDialog, kListItem);	ListaShutdown (l);	{ Uccidi eventuale preview }	IF doPreview THEN ResetItemProcedure (myDialog, kPreviewItem);	{ That's all, folks }	InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog)END;{$S MkrProcs}PROCEDURE HandleHelpButton (myDialog: DialogPtr;	correlatedTE, prompt: Integer;	pickWhat: ResType);{ handle "?" button in dialogs }VAR	buffer: Str255;	id, choice: Integer;BEGIN	{ Leggi default }	GetItemText (myDialog, correlatedTE, buffer);	id := SToI (buffer);	{ Allow picking }	choice := LoadWhat (prompt, id, pickWhat);	{ Put back choice into dialog }	SetItemText (myDialog, correlatedTE, IToS (choice))END;{$S DefProcs}PROCEDURE DrawGridlines;VAR	x, y, x1, y1: INTEGER;BEGIN	ForeColor(whiteColor);	{ In verticale }	x := 32;	y := BSL (placeH, 5);	FOR x1 := 1 TO placeW DO BEGIN		MoveTo (x, 0);		LineTo (x, y);		x := x + 32;		END;	{ In orizzontale }	y := 32;	x := BSL (placeW, 5);	FOR y1 := 1 TO placeH DO BEGIN		MoveTo (0, y);		LineTo (x, y);		y := y + 32;		END;	ForeColor (blackColor)END;{$S DefProcs}PROCEDURE DrawStructure (myWin: WindowPtr);VAR	x, y, icon: INTEGER;	r: Rect;	grandeHandle: CIconHandle;	err: OSErr;BEGIN	{$UNUSED myWin}	{ Init space to passable, no specials }	SetRect (r, 0, 0, BSL (placeW, 5), BSL (placeH, 5));	PenPixPat (myLightGrey);	PaintRect (r);	{ Get ready for impassable }	PenPixPat (myDarkGrey);	FOR x := 1 TO placeW DO		FOR y := 1 TO placeH DO BEGIN			WITH r DO BEGIN				bottom := BSL (y, 5);				right := BSL (x, 5);				top := bottom - 32;				left := right - 32				END;			IF placeKind = threeD THEN BEGIN				icon := placeMap^[x, y].icon;				IF (icon MOD 20 <> 0) OR placeMap^[x, y].characteristics[7] THEN BEGIN					grandeHandle := GetCIcon (icon DIV 100 * 100);					IF grandeHandle <> NIL THEN BEGIN						PlotCicon (r, grandeHandle);						DisposeCicon (grandeHandle);						END { icona materiale trovata }					END { icona piazzata dal designer }				END { three D }			ELSE { non three D }				IF placeMap^[x, y].characteristics[7] THEN					PaintRect (r); { Show it's impassable }			{ Show if special location }			IF (placeMap^[x, y].characteristics[5]) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kTrapHereIcon)			ELSE IF (placeMap^[x, y].characteristics[4]) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kRiddleHereIcon)			ELSE IF (placeMap^[x, y].characteristics[3]) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kDialogIcon)			ELSE IF (placeMap^[x, y].characteristics[2]) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kEventIcon)			ELSE IF (placeMap^[x, y].encounter <> 0) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kEncounterMarkIcon);			IF (placeMap^[x, y].textToShow <> 0) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kTextMarkIcon);			IF (placeMap^[x, y].bringsTo <> 0) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kTakesToMarkIcon);			IF (placeMap^[x, y].itemNeeded <> 0) THEN				err := PlotIconID (r, kAlignNone, kTransformNone, kKeyIcon);			END;	PenNormal;	IF placeKind = threeD THEN BEGIN		ForeColor (redColor);		{ Boxes }		WITH g3DBoxesHere DO			FOR x := 1 TO numBoxes DO WITH boxes[x] DO BEGIN				FrameRect (boxPos);				ClipRect (boxPos); { Impedisci di sforare }				MoveTo (boxpos.left + 1, boxPos.bottom - 2);				DrawString (boxName);				ClipRect (myWin^.portRect);				END; { for each box }		{ light sources }		WITH g3DLightsHere DO			FOR x := 1 TO numBoxes DO WITH boxes[x] DO BEGIN				ClipRect (boxPos); { Impedisci di sforare }				grandeHandle := GetCIcon (iconID);				IF grandeHandle <> NIL THEN BEGIN					err := PlotCIconHandle (boxPos, kAlignHorizontalCenter, kTransformNone, grandeHandle);					IF err < noErr THEN						FrameRect (boxPos);					DisposeCicon (grandeHandle);					END				ELSE BEGIN					FrameRect (boxPos); { probabilmente usa una PICT - tipica porcata di Alex }					MoveTo (boxPos.left + 1, boxPos.bottom - 2);					DrawString (boxName);					END;									ClipRect (myWin^.portRect);				END; { for each box }			ForeColor (blackColor)		END { of 3D }END;{$S DefProcs}PROCEDURE DrawPlace (myWin: WindowPtr);VAR	p: PicHandle;BEGIN	IF gShowPICT AND placeData [1] THEN BEGIN		p := GetPicture (placeViewPict);		IF p = NIL THEN			SysBeep (5)		ELSE			DrawPicture (p, p^^.picFrame)		END	ELSE IF LockPixels (world^.portPixMap) THEN BEGIN			CopyBits(bitmapptr(world^.portPixMap^)^,				myWin^.portBits, worldBoundsInPixel, worldBoundsInPixel,				srcCopy,NIL);						UnlockPixels (world^.portPixMap);			END;END;{$S MkrProcs}FUNCTION HasColor (bitsPerPixel: Byte): boolean;VAR	wideRect: Rect;	maxDevice: GDHandle;BEGIN	SetRect (wideRect, -maxint, -maxint, maxint, maxint);	IF gQDVersion > kQDOriginal THEN BEGIN		maxDevice := GetMaxDevice (wideRect);		HasColor := maxdevice^^.gdPMap^^.pixelSize >= bitsPerPixel		END	ELSE		HasColor := FALSEEND;{$S MkrProcs}FUNCTION MakeGWorld: Boolean;{ Crea un GWorld per il place, basato sui valore di placeW e placeH.Restituisce TRUE se tutto è andato bene }VAR	err: OSErr;	theFont: Longint;	gdh: GDHandle; oldPort: CGrafPtr;BEGIN	SetRect(worldBoundsInPixel,0,0,placeW*32,placeH*32);	currentWorldDepth := 8;	err := NewGWorld (world, currentWorldDepth, worldBoundsInPixel, NIL, NIL, 0);	IF err <> noErr THEN BEGIN		MakeGWorld := FALSE;		DisposePtr (Ptr(placeMap));		placeMap := NIL;		{ Say how much more memory we need }		ParamText (IToS (placeW*placeH - MaxBlock DIV 1024 + 64), '', '', '');		currentWorldDepth := Alert(129,NIL);		END	ELSE BEGIN		GetGWorld(oldPort,gdh);		SetGWorld(world,NIL);		EraseRect (worldBoundsInPixel);		theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);		TextFont (HiWrd (theFont));		TextSize (LoWrd (theFont));		SetGWorld (oldPort,gdh);		MakeGWorld := TRUE		END;END;{$S MkrProcs}PROCEDURE RedrawGWorld;VAR	gdh: GDHandle; oldPort: CGrafPtr;	x, y: Integer;(*		fakeIcon: CIconHandle;	originalPixMap: Handle;		PROCEDURE MyPlotIconID (r: rect; iconID: Integer);	VAR		iconHandle: Handle;	BEGIN		iconHandle := GetResource('icl8',iconID);		IF iconHandle <> NIL THEN BEGIN			HLock (iconHandle);			fakeIcon^^.iconData := iconHandle;			PlotCIcon(r,fakeIcon);			ReleaseResource (iconHandle)			END;	END;*)BEGIN	GetGWorld(oldPort,gdh);	SetGWorld(world,NIL);	IF LockPixels (world^.portPixMap) THEN BEGIN		FOR x := 1 TO placeW DO			FOR y := 1 TO placeH DO				PlotOneIcon (x, y, placeMap^[x, y].icon, mainWindow);		UnlockPixels (world^.portPixMap);		END;	SetGWorld (oldPort,gdh);END;{$S MkrProcs}PROCEDURE PosterizeGWorld;VAR	myCTable: CTabHandle;	flag: GWorldFlags;	gdh: GDHandle; oldPort: CGrafPtr;BEGIN	GetGWorld(oldPort,gdh);	SetGWorld(world,NIL);	WHILE NOT HasColor (currentWorldDepth) DO		currentWorldDepth := currentWorldDepth DIV 2;	myCTable := GetCTable (128);	flag := UpdateGWorld(world,currentWorldDepth,		worldBoundsInPixel,myCTable,NIL,clipPix+ditherPix);	IF BAnd (flag, gwFlagErr) <> 0 THEN		DeathAlert (0, QDError);	SetGWorld(oldPort,gdh);END;{$S MkrProcs}FUNCTION PlotPlaceGWorld: Boolean;BEGIN	{ NEW for v1.1 }	{ CREATE A GWORLD WITH THE MAP. }	IF MakeGWorld THEN BEGIN		displayingPlace := TRUE; { Bug fix 2.0 }		RedrawGWorld;		{ If we don't have 256 colors, posterize it }		(*		IF NOT HasColor (currentWorldDepth) THEN			PosterizeGWorld;		*)		PlotPlaceGWorld := TRUE		END	ELSE		PlotPlaceGWorld := FALSEEND;{$S DefProcs}PROCEDURE DrawArena (myWin: WindowPtr);VAR	x, y: Integer;	r: rect;	err: OSErr;	p: PicHandle;BEGIN	{$UNUSED myWin}		{ New for DR6 - picture }	IF gShowPICT AND (arenaPict <> 0) THEN BEGIN		p := GetPicture (arenaPict);		IF p = NIL THEN			SysBeep (5)		ELSE BEGIN			DrawPicture (p, p^^.picFrame);			ReleaseResource (Handle (p))			END;		Exit (DrawArena)		END;		{ OK, no picture }	IF gStructure THEN		FOR x := 1 TO arenaX DO			FOR y := 1 TO arenaY DO BEGIN				SetRect(r,(x-1)*32,(y-1)*32,x*32,y*32);				IF arena[x, y].specs[7] THEN					FillRect (r, qd.dkGray)				ELSE					FillRect (r, qd.ltGray);				END	ELSE		FOR x := 1 TO arenaX DO			FOR y := 1 TO arenaY DO				IF arena[x, y].icon > 0 THEN BEGIN					SetRect(r,(x-1)*32,(y-1)*32,x*32,y*32);					err := PlotIconID (r, kAlignNone, kTransformNone, arena[x, y].icon);					ENDEND;{$S DefProcs}PROCEDURE DrawInfoBar (myWin: WindowPtr);CONST	rBgIcon = 15000;	rRoofIcon = 15001;	rFloorIcon = 15002;	rBoxIcon = 15003;	rStartIcon = 15004;	rLightsIcon = 15005;			kDeltaToEnabled = 10;	kDeltaToDisabled = 20;VAR	r: rect;	err: Integer;	data: ThreeDHandle;BEGIN	SetRect (r, 0, 0, 32, 32);	data := ThreeDHandle (TMGetWRefCon (myWin, 3));		{ Background }	IF placeData [4] THEN	{ If underground, no background }		err := PlotIconID (r, kAlignNone, kTransformNone, rBgIcon+kDeltaToDisabled)	ELSE IF data^^.background <> 0 THEN		err := PlotIconID (r, kAlignNone, kTransformNone, rBgIcon+kDeltaToEnabled)	ELSE		err := PlotIconID (r, kAlignNone, kTransformNone, rBgIcon);	{ Tetto }	OffsetRect (r, 32, 0);	IF data^^.roof <> 0 THEN		err := PlotIconID (r, kAlignNone, kTransformNone, rRoofIcon+kDeltaToEnabled)	ELSE		err := PlotIconID (r, kAlignNone, kTransformNone, rRoofIcon);		{ Pavimento }	OffsetRect (r, 32, 0);	IF data^^.floor > 999 THEN		err := PlotIconID (r, kAlignNone, kTransformNone, rFloorIcon+kDeltaToEnabled)	ELSE		err := PlotIconID (r, kAlignNone, kTransformNone, rFloorIcon);			{ Box - DR5 }	OffsetRect (r, 32, 0);	err := PlotIconID (r, kAlignNone, kTransformNone, rBoxIcon);	{ Fonti di luce - DR5 }	OffsetRect (r, 32, 0);	err := PlotIconID (r, kAlignNone, kTransformNone, rLightsIcon);	{ Startup pt - DR5 }	OffsetRect (r, 32, 0);	err := PlotIconID (r, kAlignNone, kTransformNone, rStartIcon);END;{$S DefProcs}PROCEDURE DrawWindow (myWin: WindowPtr);BEGIN	IF displayingPlace THEN BEGIN		{ Place content }		IF gStructure THEN			DrawStructure (myWin)		ELSE			DrawPlace (myWin);		{ Place gridlines }		IF gGridLines THEN			DrawGridlines		END	ELSE		{ Arena }		DrawArena (myWin);END;{$S MkrProcs}PROCEDURE DoWindow;CONST	kScrollbarWidth = 15;VAR	winPos: Point;	correctXPosition,	infoBarHeight,	menuBarPlusWindowTitleHeight,	wishList: INTEGER;	maxWinWidth, maxWinHeight: Integer;BEGIN	IF placeKind = threeD THEN BEGIN		infoBarHeight := 32;		IF gHasThemes THEN			correctXPosition := 47 { Spazio per i bordi spessi delle finestre }		ELSE			correctXPosition := 35;		wishList := fGrow+fBScroll+fRScroll+fInfoBar;		END	ELSE BEGIN		infoBarHeight := 0;		correctXPosition := 0;		wishList := fGrow+fBScroll+fRScroll;		END;	IF displayingPlace THEN BEGIN		maxWinWidth := placeW*32;		maxWinHeight := placeH*32;		{ Informa TaskMaster della sua esistenza }		TMNewWindow (mainWindow, wishList,			kMainWindowRefcon,			{ refCon }			maxWinHeight, maxWinWidth,	{ data height & width }					maxWinHeight, maxWinWidth,	{ max height & width }			32, 32,							{ Min height & width }			32, 32,							{ scrollver & scrollhor }			0, 0,								{ pagever, pagehor }			infoBarHeight,			DrawInfoBar, DrawWindow);		SetWTitle (mainWindow, placeName);		END	ELSE BEGIN		maxWinWidth := arenaX*32;		maxWinHeight := arenaY*32;		{ Informa TaskMaster delle nuove caratteristiche }		TMNewWindow (mainWindow, wishList,			kMainWindowRefcon,				{ refCon }			maxWinHeight, maxWinWidth,		{ data height & width }					maxWinHeight, maxWinWidth,		{ max height & width }			32*3, 32*3,							{ Min height & width }			32, 32,								{ scrollver & scrollhor }			0, 0,									{ pagever, pagehor }			0, NIL, DrawWindow);		SetWTitle (mainWindow, arenaName);		END;	ShowWindow (mainWindow);	TMSelectWindow (mainWindow); { Primo piano }	SetPort (mainWindow);	{ Codice rubato a TaskMaster }	winPos := mainWindow^.portRect.topLeft;	LocalToGlobal (winPos);	menuBarPlusWindowTitleHeight := GetMBarHeight +		winPos.v - 1 -		WindowPeek(mainWindow)^.strucRgn^^.rgnBBox.top;	MoveWindow (mainWindow, correctXPosition, menuBarPlusWindowTitleHeight, FALSE);	gDirty := FALSEEND;{$S UtilInit}PROCEDURE SMDialogsInit;CONST	rLightGrey = 128;	rDarkGrey = 129;BEGIN	displayingPlace := FALSE;	displayingArena := FALSE;	gGridlines := FALSE;	gShowPict := FALSE;	{ trova i colori da usare nella struttura - new DR1}	myLightGrey := GetPixPat (rLightGrey);	myDarkGrey := GetPixPat (rDarkGrey);	placeMap := NILEND;{$S DefProcs}PROCEDURE DrawViewpoint (where: DialogPtr; item: INTEGER);CONST	pi = 3.1415926;VAR	data: ThreeDHandle;	r: Rect;	origin, endPoint: Point;	raggio, oldFont, oldSize: Integer;	angolo, seno, coseno: real;	theFont: longint;BEGIN	GetItemRect (where, item, r);	EraseRect (r);	FrameOval (r);	WITH origin, r DO BEGIN		{ Raggio del cerchio }		raggio := (right - left) DIV 2;		{ Origine del cerchio }		h := left + raggio;		v := top + raggio;		END;	data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));	angolo := data^^.startAngle / 180 * pi; { In radianti }	seno := sin (angolo);	coseno := cos (angolo);		endpoint.v := origin.v - Round (coseno * raggio); { Meno, perché non siamo in un piano cartesiano ma informatico }	endpoint.h := origin.h + Round (seno * raggio);	MoveTo (origin.h, origin.v);	LineTo (endpoint.h, endPoint.v);	{ E ora, in numero }	oldFont := where^.txFont;	oldSize := where^.txSize;	theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);	TextFont (HiWrd (theFont));	TextSize (LoWrd (theFont));	MoveTo (r.right - 20, r.bottom - 3);	DrawString (Concat (IToS (data^^.startAngle), '°'));	TextFont (oldFont);	TextSize (oldSize);END;{$S MkrProcs}PROCEDURE Do3DPlaceStartDialog;CONST	rStartPosDialog = 137;		rViewpointUI = 3;		rXposTE = 7;		rYposTE = 8;				kTotalNumItems = rYposTE;VAR	empty,	textEdits,	everything:			Family;	myDialog: DialogPtr;	result, x, y, angle: INTEGER;	e: Eventrecord;	data: ThreeDHandle;	bufferX, bufferY: Str255;	r: rect;BEGIN	{ Setup }	myDialog := GetNewDialog (rStartPosDialog, NIL, WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, TRUE);	ClearFamily (empty);	textEdits := empty;	textEdits[rXposTE] := TRUE;	textEdits[rYposTE] := TRUE;	everything := textEdits;	everything[kStdOkItemIndex] := TRUE;	everything[kStdCancelItemIndex] := TRUE;	everything[rViewpointUI] := TRUE;	SetItemProcedure (myDialog, rViewpointUI, @DrawViewpoint); { install draw proc }	GetItemRect (myDialog, rViewpointUI, r);		{ Fill the dialog fields with the current values }	data := ThreeDHandle (TMGetWRefCon (mainWindow, 3));	SetItemText (myDialog, rXposTE, IToS (data^^.startX));	SetItemText (myDialog, rYposTE, IToS (data^^.startY));	{ Dialog handling }	angle := data^^.startAngle; { memorizza il vecchio valore }	data^^.startAngle := data^^.startAngle * 2; { Alex usa un numero 0..179 }	REPEAT		result := DialogLord (myDialog, kTotalNumItems, empty, empty,			everything, empty,			textEdits, empty, textEdits, 2, e);		{ impedisci di scrivere porcherie come X e Y }		GetItemText (myDialog, rXposTE, bufferX);		x := SToI (bufferX);		GetItemText (myDialog, rYposTE, bufferY);		y := SToI (bufferY);		IF (x > 0) AND (x <= placeW) AND (y > 0) AND (y <= placeH) THEN			EnableDialogItem (myDialog, kStdOkItemIndex)		ELSE			DisableDialogItem (myDialog, kStdOkItemIndex);		{ Gestione useritem }		IF result = rViewpointUI THEN BEGIN			GlobalToLocal (e.where);			PtToAngle (r, e.where, data^^.startAngle);			InvalRect (r);			END;	UNTIL result <= kStdCancelItemIndex;	{ Result reading }	IF result = kStdOkItemIndex THEN BEGIN		data^^.startX := x;		data^^.startY := y;		data^^.startAngle := data^^.startAngle DIV 2; { Alex vuole un numero 0..179 }		gDirty := TRUE;		END	ELSE		data^^.startAngle := angle;	SetPort (mainWindow);	ResetItemProcedure (myDialog, rViewpointUI);	DisposeDialog (myDialog);END;{$S MkrProcs}PROCEDURE DoArenaLocDialog (x, y: INTEGER);CONST	rDialogID = 130;	{ item ID. Come sempre, OK=1 e cancel=2 }	kSlowsCB = 6;	kImpassableCB = 8;	kAntimagicCB = 7;	kHolyRB = 3;	kUnholyRB = 4;	kNeitherRB = 5;	kTotalNumItems = 8;VAR	empty,	finalButtons,	checkboxes,	radios:			Family;	myDialog: DialogPtr;	i, result: INTEGER;	e: Eventrecord;BEGIN	{ Setup }	myDialog := GetNewDialog(rDialogID,NIL,WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, FALSE);	ClearFamily (empty);	finalButtons := empty;	finalButtons[kStdOkItemIndex] := TRUE;	finalButtons[kStdCancelItemIndex] := TRUE;	radios := empty;	FOR i := kHolyRB TO kNeitherRB DO		radios[i] := TRUE;	checkboxes := empty;	FOR i := kSlowsCB TO kImpassableCB DO		checkboxes[i] := TRUE;		{ Fill the dialog fields with the current values }	WITH arena[x,y] DO BEGIN		IF specs[6] THEN			SetRadio (myDialog, kUnHolyRB, kTotalNumItems, radios)		ELSE IF specs [5] THEN			SetRadio (myDialog, kHolyRB, kTotalNumItems, radios)		ELSE			SetRadio (myDialog, kNeitherRB, kTotalNumItems, radios);		SetItemValue (myDialog, kSlowsCB, ord (specs[4]));		SetItemValue (myDialog, kImpassableCB, ord (specs[7]));		SetItemValue (myDialog, kAntimagicCB, ord (specs[3]));		END;		{ Dialog handling }	result := DialogLord (myDialog, kTotalNumItems, radios, empty,		finalButtons, checkboxes, empty, empty, empty, 0, e);	{ Result reading }	IF result = kStdOkItemIndex THEN WITH arena[x,y] DO BEGIN		gDirty := TRUE;		CASE GetRadio (myDialog, kTotalNumItems, radios) OF						kHolyRB: BEGIN				specs[5] := TRUE;				specs[6] := FALSE				END;			kUnholyRB: BEGIN				specs[5] := FALSE;				specs[6] := TRUE				END;			kNeitherRB: BEGIN				specs[5] := FALSE;				specs[6] := FALSE				END;			END; { case }		specs[4] := GetItemValue (myDialog, kSlowsCB) <> 0;		specs[7] := GetItemValue (myDialog, kImpassableCB) <> 0;		specs[3] := GetItemValue (myDialog, kAntimagicCB) <> 0;		END; { if clicked OK }	InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog)END;{$S MkrProcs}PROCEDURE DoPlaceLocDialog (x, y: INTEGER; globalPtClicked: Point);CONST	rDialogID = 132;	{ item ID. Come sempre, OK=1 e cancel=2 }	kMenuEntrance = 3;		mEntranceFreely = 1;		mEntranceItem = 2;		mEntranceImpossible = 3;	kMenuHappening = 4;		mHappeningNothing = 1;		mHappeningTrap = 2;		mHappeningRiddle = 3;		mHappeningDialog = 4;		mHappening3DEvent = 5;		mHappeningEncounter = 6;	kMenuRelocation = 5;		mRelocationNone = 1;		mRelocationExit = 2;		mRelocationEnter = 3;	kHelpEntrance = 6;	kHelpHappening = 7;	kHelpRelocation = 8;	kHelpText = 9;	kMustSearchCB = 10;	kTextTE = 11;	kEntranceTE = 12;	kHappeningTE = 13;	kRelocationTE = 14;		kTotalNumItems = 10;	VAR	empty,	numericTEs,	buttons,	checkboxCharacteristics:			Family;	myDialog:								DialogPtr;	currentHappening,	currentEntrance,	currentRelocation,	i, result:								INTEGER;	buffer:									str255;	e:											Eventrecord;	dialogRect, locationRect:			Rect;	{ Per l'animazione del dialogo che torna locazione }	PROCEDURE ChangedHappening;	BEGIN	IF currentHappening <> mHappeningNothing THEN BEGIN		ShowDialogItem (myDialog, kHappeningTE);		ShowDialogItem (myDialog, kHelpHappening)		END	ELSE BEGIN		HideDialogItem (myDialog, kHappeningTE);		HideDialogItem (myDialog, kHelpHappening)		END;	IF currentHappening = mHappeningEncounter THEN		ShowDialogItem (myDialog, kMustSearchCB)	ELSE		HideDialogItem (myDialog, kMustSearchCB);	END; { ChangedHappening }	PROCEDURE ChangedEntrance;	BEGIN	IF currentEntrance = mEntranceItem THEN BEGIN		ShowDialogItem (myDialog, kEntranceTE);		ShowDialogItem (myDialog, kHelpEntrance)		END	ELSE BEGIN		HideDialogItem (myDialog, kEntranceTE);		HideDialogItem (myDialog, kHelpEntrance)		END;	END; { ChangedEntrance }	PROCEDURE ChangedRelocation;	BEGIN	IF currentRelocation = mRelocationEnter THEN BEGIN		ShowDialogItem (myDialog, kRelocationTE);		ShowDialogItem (myDialog, kHelpRelocation)		END	ELSE BEGIN		HideDialogItem (myDialog, kRelocationTE);		HideDialogItem (myDialog, kHelpRelocation)		END;	END; { ChangedRelocation }	PROCEDURE DisableThreeDItem;	VAR		popupInternals: PopupPrivateDataHandle;		theHappeningsMenu: MenuHandle;		itemType: Integer;		itemHandle: Handle;		itemBox: Rect;	BEGIN		GetDialogItem (myDialog, kMenuHappening,			itemtype, itemHandle, itembox);		popupInternals := PopupPrivateDataHandle (ControlHandle (itemHandle)^^.contrlData);		theHappeningsMenu := popupInternals^^.mHandle;		DisableItem (theHappeningsMenu, mHappening3DEvent)	END; { DisableThreeDItem }	BEGIN	{ Setup }	myDialog := GetNewDialog(rDialogID,NIL,WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, TRUE);	ClearFamily (empty);	buttons := empty;	FOR i := kStdOkItemIndex TO kHelpText DO		buttons[i] := TRUE;	checkboxCharacteristics := empty;	checkboxCharacteristics[kMustSearchCB] := TRUE;	numericTEs := empty;	FOR i := kTextTE TO kRelocationTE DO		numericTEs[i] := TRUE;		{ Fill the dialog fields with the current values }	WITH placeMap^[x,y] DO BEGIN		CASE bringsTo OF			0: { nowhere }				currentRelocation := mRelocationNone;			-1: { pop out }				currentRelocation := mRelocationExit;			OTHERWISE BEGIN				currentRelocation := mRelocationEnter;				SetItemText (myDialog, kRelocationTE, IToS (bringsTo))				END { otherwise }			END; { case }		SetItemText (myDialog, kRelocationTE, IToS (bringsTo));		SetItemValue (myDialog, kMenuRelocation, currentRelocation);		ChangedRelocation;		{ Happening }		SetItemText (myDialog, kHappeningTE, IToS (encounter));		IF characteristics[5] THEN			currentHappening := mHappeningTrap		ELSE IF characteristics[4] THEN			currentHappening := mHappeningRiddle		ELSE IF characteristics[3] THEN			currentHappening := mHappeningDialog		ELSE IF characteristics[2] THEN			currentHappening := mHappening3DEvent		ELSE IF encounter <> 0 THEN			currentHappening := mHappeningEncounter		ELSE currentHappening := mHappeningNothing;		ChangedHappening;		IF placeKind <> threeD THEN			DisableThreeDItem; { Ha senso solo in 3D }		SetItemValue (myDialog, kMenuHappening, currentHappening);				SetItemValue (myDialog, kMustSearchCB, ord (characteristics[6]));		SetItemText (myDialog, kTextTE, IToS (textToShow));				{ Entrance }		SetItemText (myDialog, kEntranceTE, IToS (itemNeeded));		IF characteristics[7] THEN			currentEntrance := mEntranceImpossible		ELSE IF itemNeeded = 0 THEN			currentEntrance := mEntranceFreely		ELSE			currentEntrance := mEntranceItem;		ChangedEntrance;		SetItemValue (myDialog, kMenuEntrance, currentEntrance);		END;	ShowWindow (myDialog);		{ Dialog handling }	REPEAT		result := DialogLord (myDialog, kTotalNumItems, empty, empty,			buttons, checkboxCharacteristics,			numericTEs, empty, numericTEs, 5, e);		CASE result OF			kHelpText: HandleHelpButton (myDialog, kTextTE, rTextForPlaceLoc, 'TEXT');			kHelpEntrance: HandleHelpButton (myDialog, kEntranceTE, rItemForPlaceLoc, 'Obj ');			kHelpRelocation: HandleHelpButton (myDialog, kRelocationTE, rPlaceReachedFromLoc, 'Plac');			kHelpHappening: CASE currentHappening OF				mHappeningTrap: HandleHelpButton (myDialog, kHappeningTE, rTrapForLoc, 'Trap');				mHappeningRiddle: HandleHelpButton (myDialog, kHappeningTE, rRiddleForLoc, 'Ridl');				mHappeningDialog: HandleHelpButton (myDialog, kHappeningTE, rTalkForLoc, 'Talk');				mHappening3DEvent: HandleHelpButton (myDialog, kHappeningTE, rEventForLoc, '3DEv');				mHappeningEncounter: HandleHelpButton (myDialog, kHappeningTE, rEncounterForLoc, 'Nctr');				END; { case happening type }			kMenuEntrance: BEGIN				currentEntrance := GetItemValue (myDialog, kMenuEntrance);				ChangedEntrance;				END;			kMenuHappening: BEGIN				currentHappening := GetItemValue (myDialog, kMenuHappening);				ChangedHappening;				END;			kMenuRelocation: BEGIN				currentRelocation := GetItemValue (myDialog, kMenuRelocation);				ChangedRelocation				END;			END; { case result }	UNTIL result <= kStdCancelItemIndex;	{ Result reading }	IF result = kStdOKItemIndex THEN WITH placeMap^[x,y] DO BEGIN		gDirty := TRUE;		{ relocation }		CASE currentRelocation OF			mRelocationNone:				bringsTo := 0;			mRelocationExit:				bringsTo := -1;			mRelocationEnter: BEGIN				GetItemText (myDialog, kRelocationTE, buffer);				bringsTo := SToI (buffer)				END;			END; { case }		{ Entrance }		characteristics[7] := (currentEntrance = mEntranceImpossible);		CASE currentEntrance OF			mEntranceFreely, mEntranceImpossible:				itemNeeded := 0;			mEntranceItem: BEGIN				GetItemText (myDialog, kEntranceTE, buffer);				itemNeeded := SToI (buffer)				END { item }			END; { case }				{ Happenings }		GetItemText (myDialog, kHappeningTE, buffer);		encounter := SToI (buffer);		FOR i := 2 TO 6 DO			characteristics[i] := FALSE;		CASE currentHappening OF			mHappeningNothing:				encounter := 0;			mHappeningTrap:				characteristics[5] := TRUE;			mHappeningRiddle:				characteristics[4] := TRUE;			mHappeningDialog:				characteristics[3] := TRUE;			mHappening3DEvent:				characteristics[2] := TRUE;			mHappeningEncounter:				characteristics[6] := GetItemValue (myDialog, kMustSearchCB) <> 0;			END; { case }		{ Text on enter }		GetItemText (myDialog, kTextTE, buffer);		textToShow := SToI (buffer)		END; { if clicked OK }	{ Prendi nota di dove appariva il dialogo - new for 1.3 }	dialogRect := myDialog^.portRect;		InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog);	{ Trasforma le coordinate locali in globali }	LocalToGlobal (dialogRect.topLeft);	LocalToGlobal (dialogRect.botRight);		{ Fai apparire una animazione che lo ricorda all'utente }	WITH locationRect DO BEGIN		top := BSL(BSR(globalPtClicked.v,5),5);		bottom := top + 32;		left := BSL(BSR(globalPtClicked.h,5),5);		right := left + 32		(*		{ Da logico a fisico-locale }		TMLogicalToPhysical (topLeft);		TMLogicalToPhysical (botRight);		{ Da fisico-locale a globale }		LocalToGlobal (topLeft);		LocalToGlobal (botRight);		*)		END;	IF GetGestaltResult (gestaltDragMgrAttr) <> 0 THEN		i := ZoomRects (dialogRect, locationRect, 15, zoomDecelerate);		{ Calcola dove appaia la locazione che abbiamo mutato - new for v1.3 }	GlobalToLocal (globalPtClicked);	WITH locationRect DO BEGIN		top := BSL(BSR(globalPtClicked.v,5),5);		bottom := top + 32;		left := BSL(BSR(globalPtClicked.h,5),5);		right := left + 32		END;	{ Invalidalo, perché se eravamo in modo struttura può apparire o	sparire una icona rossa }	TMInvalRect (locationRect);END;FUNCTION ResourceIsMissing (theType: ResType; theID: Integer): Boolean;EXTERNAL; { Definita in SMResources }{$S MkrProcs}FUNCTION DoPlaceInfoDialog (placeIsBrandNew: Boolean): BOOLEAN;CONST	rStringsForParamText = 130;		rStrCommonVariant = 1;		rStrShopVariant = 2;	rDialogID = 131;	{ item ID. Come sempre, OK=1 e cancel=2 }	kMustBeSavedCB = 3;	kNeedLightCB = 4;	kHasWanderMonstersCB = 5;	kFullySeenCB = 6;	kHasPICTCB = 7;	kUseSmallIconCB = 8;	kCustomMusicCB = 9;	kHelpTextEnterPlace = 10;	kHelpPictEnterPlace = 11;	kHelpShop = 12;	kHelpPictMapPlace = 13;		kPlaceKindMenu = 14;	kLocationMenu = 15;	kPlaceNameTE = 16;	kPlaceWidthTE = 17;	kPlaceHeightTE = 18;	kPlaceTimePerMoveTE = 19;	kPlaceTEXTinTE = 20;	kPlacePICTinTE = 21;	kPlaceViewPictTE = 22;	kPlaceIDTE = 23;		kShopOrStepST = 27;		kTotalNumItems = kPlaceKindMenu;VAR	empty,	numberOnlyTEs,	finalButtons,	characteristicsCheckBoxFamily:			Family;	myDialog: DialogPtr;	i, result, oldPlaceW, oldPlaceH: INTEGER;	oldPlaceKind: SpecialPlace;	buffer: str255;	e: Eventrecord;		PROCEDURE DoResizePlace;	VAR		emptyLocation: MapLocation;		x, y: Integer;		oldPlaceBoundsRect: Rect;		pt: Point;	BEGIN		WITH emptyLocation DO BEGIN			icon := 0; bringsTo := 0; encounter := 0; spare := 0;			textToShow := 0; itemNeeded := 0;			FOR x := 7 DOWNTO 0 DO				characteristics[x] := FALSE;			END;		SetRect(oldPlaceBoundsRect,1,1,oldPlaceW+1,oldPlaceH+1);		FOR x := 1 TO placeW DO			FOR y := 1 TO placeH DO BEGIN				SetPt(pt,x,y);				IF NOT ptInRect (pt, oldPlaceBoundsRect) THEN					placeMap^[x,y] := emptyLocation;				END;		{ Ricrea il GWorld con mappa differente }		DisposeGWorld (world);		IF PlotPlaceGWorld THEN			{ Informa TM delle nuove dimensioni del content }			DoWindow		ELSE DeathAlert (errOutOfMemory, 0)	END;	BEGIN	{ Try and remember the old values. This will be	useful if the user changes those. }	oldPlaceW := placeW;	oldPlaceH := placeH;	oldPlaceKind := placeKind;	{ Setup }	myDialog := GetNewDialog(rDialogID,NIL,WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, TRUE);	ClearFamily (empty);	finalButtons := empty;	finalButtons[kStdOkItemIndex] := TRUE;	finalButtons[kStdCancelItemIndex] := TRUE;	finalButtons[kHelpTextEnterPlace] := TRUE;	finalButtons[kHelpPictEnterPlace] := TRUE;	finalButtons[kHelpShop] := TRUE;	finalButtons[kHelpPictMapPlace] := TRUE;	finalButtons[kPlaceKindMenu] := TRUE; { Quando cambia da shop a std… }	characteristicsCheckBoxFamily := empty;	FOR i := kMustBeSavedCB TO kCustomMusicCB DO		characteristicsCheckBoxFamily[i] := TRUE;	IF ResourceIsMissing ('Musi', placeID) THEN		DisableDialogItem (myDialog, kCustomMusicCB)	ELSE		EnableDialogItem (myDialog, kCustomMusicCB); { C'è un "Musi" }	numberOnlyTEs := empty;	FOR i := kPlaceWidthTE TO kPlaceIDTE DO		numberOnlyTEs[i] := TRUE;		{ Fill the dialog fields with the current values }	IF placeData [4] THEN		result := 3 { under }	ELSE IF morePlaceData [15] THEN		result := 2 { in }	ELSE result := 1; { out }	SetItemValue (myDialog, kLocationMenu, result);	SetItemValue (myDialog, kPlaceKindMenu, ord (placeKind)+1); { Gli enumerati sono zero-based }	IF placeKind = Shop THEN		GetIndString(buffer, rStringsForParamText, rStrShopVariant)	ELSE BEGIN		GetIndString(buffer, rStringsForParamText, rStrCommonVariant);		HideDialogItem (myDialog, kHelpShop);		END;	SetItemText (myDialog, kShopOrStepST, buffer);	SetItemText (myDialog, kPlaceIDTE, IToS (placeID));	SetItemText (myDialog, kPlaceNameTE, placeName);	SetItemText (myDialog, kPlaceWidthTE, IToS (placeW));	SetItemText (myDialog, kPlaceHeightTE, IToS (placeH));	SetItemText (myDialog, kPlaceTimePerMoveTE, IToS (placeTime));	SetItemText (myDialog, kPlaceTEXTinTE, IToS (placeTEXTIn));	SetItemText (myDialog, kPlacePICTinTE, IToS (placePICTin));	SetItemText (myDialog, kplaceViewPictTE, IToS (placeViewPict));	{ Checkboxes }	SetItemValue (myDialog, kMustBeSavedCB, ord (placeData[7]));	SetItemValue (myDialog, kNeedLightCB, ord (placeData[6]));	SetItemValue (myDialog, kHasWanderMonstersCB, ord (placeData[5]));	SetItemValue (myDialog, kFullySeenCB, ord (placeData[0]));	SetItemValue (myDialog, kHasPICTCB, ord (placeData[1]));	SetItemValue (myDialog, kUseSmallIconCB, ord (morePlaceData[14]));	SetItemValue (myDialog, kCustomMusicCB, ord (morePlaceData[13]));		ShowWindow (myDialog);	REPEAT		{$PUSH}		{$R-}		{ Dialog handling }		result := DialogLord (myDialog, kTotalNumItems, empty, empty,			finalButtons, characteristicsCheckBoxFamily, 			numberOnlyTEs, empty, numberOnlyTEs, 5, e);		{$POP}				CASE result OF			kHelpTextEnterPlace: HandleHelpButton (myDialog, kPlaceTEXTinTE, rTextDescribingPlace, 'TEXT');			kHelpPictEnterPlace: HandleHelpButton (myDialog, kPlacePICTinTE, rPictDescribingPlace, 'PICT');			kHelpPictMapPlace: HandleHelpButton (myDialog, kplaceViewPictTE, rPictForPlaceMap, 'PICT');			kHelpShop: HandleHelpButton (myDialog, kPlaceTimePerMoveTE, rShopForPlace, 'Shop');			kPlaceKindMenu: BEGIN				placeKind := SpecialPlace (GetItemValue (myDialog, kPlaceKindMenu)-1); { Gli enumerati sono zero-based }				IF placeKind = Shop THEN BEGIN					GetIndString(buffer, rStringsForParamText, rStrShopVariant);					ShowDialogItem (myDialog, kHelpShop);					END				ELSE BEGIN					HideDialogItem (myDialog, kHelpShop);					GetIndString(buffer, rStringsForParamText, rStrCommonVariant);					END;				SetItemText (myDialog, kShopOrStepST, buffer);				END;			END;	UNTIL result <= kStdCancelItemIndex;	{ Result reading }	IF result = kStdOKItemIndex THEN BEGIN		DoPlaceInfoDialog := TRUE;		gDirty := TRUE;				{ Read the dialog for responses }		CASE GetItemValue (myDialog, kLocationMenu) OF			3 { under }: BEGIN				placeData [4] := TRUE;				morePlaceData[15] := TRUE				END;			2 { in }: BEGIN				placeData [4] := FALSE;				morePlaceData[15] := TRUE				END;			1 { out }: BEGIN				placeData [4] := FALSE;				morePlaceData[15] := FALSE				END;			END; { case }		GetItemText (myDialog, kPlaceIDTE, buffer);		placeID := SToI (buffer);		GetItemText (myDialog, kPlaceNameTE, placeName);		{ Controllo sulla lunghezza del placeName }		IF length (placeName) > 30 THEN			placeName[0] := chr (30);		{ Riprende la lettura }		GetItemText (myDialog, kPlaceWidthTE, buffer);		placeW := SToI (buffer);		GetItemText (myDialog, kPlaceHeightTE, buffer);		placeH := SToI (buffer);		GetItemText (myDialog, kPlaceTimePerMoveTE, buffer);		placeTime := SToI (buffer);		GetItemText (myDialog, kPlaceTEXTinTE, buffer);		placeTEXTIn := SToI (buffer);		placeTEXTout := 0;		GetItemText (myDialog, kPlacePICTinTE, buffer);		placePICTin := SToI (buffer);		{ Checkboxes }		placeData[7] := GetItemValue (myDialog, kMustBeSavedCB) <> 0;		placeData[6] := GetItemValue (myDialog, kNeedLightCB) <> 0;		placeData[5] := GetItemValue (myDialog, kHasWanderMonstersCB) <> 0;		placeData[1] := GetItemValue (myDialog, kHasPICTCB) <> 0;		morePlaceData[14] := GetItemValue (myDialog, kUseSmallIconCB) <> 0;		morePlaceData[13] := GetItemValue (myDialog, kCustomMusicCB) <> 0;		IF placeData [1] THEN BEGIN			GetItemText (myDialog, kplaceViewPictTE, buffer);			placeViewPict := SToI (buffer);			END		ELSE placeViewPict := 0;		placeData[3] := (placeKind = Shop);		placeData[2] := (placeKind <> Standard) & (placeKind <> Shop);		placeData[0] := GetItemValue (myDialog, kFullySeenCB) <> 0;		{ If he changed the size, tell him there will be problems }		IF NOT placeIsBrandNew AND ((oldPlaceW <> placeW) OR (oldPlaceH <> placeH)) THEN			DoResizePlace;				{ Three D? }		IF (placeKind <> oldPlaceKind) THEN BEGIN			IF placeKind = threeD THEN				ThreeDTools (TRUE);			IF oldPlaceKind = threeD THEN				ThreeDTools (FALSE);			END;		END	ELSE		DoPlaceInfoDialog := FALSE;	InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog)END;{$S MkrProcs}FUNCTION DoArenaInfoDialog: BOOLEAN;CONST	rDialogID = 128;	{ item ID. Come sempre, OK=1 e cancel=2 }	kArenaNameTE = 3;	kArenaIDTE = 4;	kArenaXTE = 5;	kArenaYTE = 6;	kArenaPictTE = 12;	kHelpForArenaPict = 14;		kTotalNumItems = kHelpForArenaPict;	{ Numero dell'ultimo pulsante }VAR	empty,	numberOnlyTEs,	buttons: Family;	myDialog: DialogPtr;	i, result: INTEGER;	buffer: str255;	e: EventRecord;BEGIN	{ Setup }	myDialog := GetNewDialog(rDialogID,NIL,WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, TRUE);	ClearFamily (empty);	buttons := empty;	buttons[kStdOkItemIndex] := TRUE;	buttons[kStdCancelItemIndex] := TRUE;	buttons[kHelpForArenaPict] := TRUE;	numberOnlyTEs := empty;	FOR i := kArenaIDTE TO kArenaYTE DO		numberOnlyTEs[i] := TRUE;		{ Fill the dialog fields with the current values }	SetItemText (myDialog, kArenaIDTE, IToS (arenaID));	SetItemText (myDialog, kArenaNameTE, arenaName);	SetItemText (myDialog, kArenaXTE, IToS (arenaX));	SetItemText (myDialog, kArenaYTE, IToS (arenaY));	SetItemText (myDialog, kArenaPictTE, IToS (arenaPict));		{ Dialog handling }	REPEAT		result := DialogLord (myDialog, kTotalNumItems, empty, empty,			buttons, empty, numberOnlyTEs, empty, numberOnlyTEs, 5, e);		IF result = kHelpForArenaPict THEN			HandleHelpButton (myDialog, kArenaPictTE, rPictForArenaMap, 'PICT')	UNTIL result <= kStdCancelItemIndex;		{ Result reading }	IF result = kStdOkItemIndex THEN BEGIN		DoArenaInfoDialog := TRUE;		gDirty := TRUE;		{ Read the dialog for responses }		GetItemText (myDialog, kArenaIDTE, buffer);		arenaID := SToI (buffer);		GetItemText (myDialog, kArenaNameTE, arenaName);		{ Controllo sulla lunghezza di arenaName }		IF length (arenaName) > 30 THEN			arenaName[0] := chr (30);		{ Riprende la lettura }		GetItemText (myDialog, kArenaXTE, buffer);		arenaX := SToI (buffer);		GetItemText (myDialog, kArenaYTE, buffer);		arenaY := SToI (buffer);		GetItemText (myDialog, kArenaPictTE, buffer);		arenaPict := SToI (buffer);		END	ELSE		DoArenaInfoDialog := FALSE;			{ Sanity Check }	IF arenaX > maxLocX THEN		arenaX := maxLocX;	IF arenaY > maxLocY THEN		arenaY := maxLocY;			InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog)END;{$S MkrProcs}PROCEDURE DoNewText;CONST	rDialogID = 140;	{ item ID. Come sempre, OK=1 e cancel=2 }	kTextNameTE = 3;	kTextIDTE = 4;	kTotalNumItems = 2;	{ Numero dell'ultimo pulsante }		kHeightOfWindowMenuBar = 20;VAR	empty,	numberOnlyTEs,	buttons: Family;	myDialog: DialogPtr;	result: INTEGER;	buffer: str255;	e: EventRecord;		textID: Integer;	textWindow: WindowPtr;BEGIN	{ Setup }	myDialog := GetNewDialog(rDialogID,NIL,WindowPtr(-1));	SetPort (myDialog);	DefaultButton (myDialog, TRUE);	ClearFamily (empty);	buttons := empty;	buttons[kStdOkItemIndex] := TRUE;	buttons[kStdCancelItemIndex] := TRUE;	numberOnlyTEs := empty;	numberOnlyTEs[kTextIDTE] := TRUE;		{ Fill the dialog fields with valid values }	REPEAT		textID := UniqueID ('TEXT')	UNTIL (textID > 999) AND (textID < 10001);	SetItemText (myDialog, kTextIDTE, IToS (textID));		ShowWindow(myDialog);   {make it visible}	REPEAT		{ Dialog handling }		result := DialogLord (myDialog, kTotalNumItems, empty, empty,			buttons, empty, numberOnlyTEs, empty, numberOnlyTEs, 5, e);					{ Result reading }		IF result = OK THEN BEGIN			{ Read the dialog for responses }			GetItemText (myDialog, kTextIDTE, buffer);			textID := SToI (buffer);			GetItemText (myDialog, kTextNameTE, buffer);			END;					IF textID < 1000 THEN			NewErrorAlert (kAlertStopAlert, errUseValidResIDs, textID)	UNTIL (result = Cancel) OR (textID > 999);			{ Sanity Check }	IF result = OK THEN BEGIN		{ Crea nuova finestra… }		TEXTWindow := GetNewCWindow(rTextWindowPrototype+ord(gHasThemes)*1000, nil, nil);		if TEXTWindow = nil then			DeathAlert (errMissingApplRes, resNotFound);		TMNewWindow (TEXTWindow,			fContainsTextEdit+fGrow+fRScroll+fInfoBar,			textID,				{ ref con }			12, 300,			1024, 640,			200, 300,			12, 48, 0, 0, 			kHeightOfWindowMenuBar,										{ Info bar height }			DrawPopUpMenus, NIL);		{ Crea i menu a scomparsa per il text editing }		InitPopUpMenus (TEXTWindow);		{ Salva il nome risorsa }		SetWTitle (TEXTWindow, buffer);		{ Salva lo ID risorsa }		TMSetWRefCon (TEXTWindow, kRefconForID, textID); { Non indispensabile, ma meglio farlo				perché se cambiasse il valore di kRefconForID (ora vale 1) il side				effect guasterebbe il programma }		ShowWindow (TEXTWindow);		TMSelectWindow (TEXTWindow);		END;			InitCursor;	SetPort (mainWindow);	DisposeDialog (myDialog)END;{$S MkrProcs}FUNCTION DoNewPlace: Boolean;VAR	x, y: INTEGER;	standardCharacteristics: BitsInByte;BEGIN	{ Per non settare tutte le caratteristiche booleane una alla volta,	uso un vettore che inizializzo e copio dentro tutte le locazioni }	FOR x := 0 TO 7 DO		standardCharacteristics[x] := FALSE;	{ PHASE ONE. Init place data fields }	IF placeMap <> NIL THEN		DeathAlert (0, 666);	placeMap := MapPtr (NewPtr (sizeOf (Map)));	placeID := 1000; { Just an ID }	placeName := GetString(rUntitled)^^; { Just a name }	placeW := 4;	placeH := 4;	placeTime := 1;	placeTEXTin := 0;	placeTEXTout := 0;	placePICTin := 0;	placeViewPict := 0;	placeKind := standard;	g3DBoxesHere.numBoxes := 0;	g3DLightsHere.numBoxes := 0;	FOR x := 7 DOWNTO 0 DO		placeData[x] := FALSE;	FOR x := 15 DOWNTO 0 DO		morePlaceData [x] := FALSE;	{ PHASE TWO. Customize place info }	IF DoPlaceInfoDialog (TRUE) THEN BEGIN		{ PHASE THREE. Setup map }		displayingPlace := TRUE;		{ Setup every location in the map }		FOR x := 1 TO placeW DO			FOR y := 1 TO placeH DO				WITH placeMap^[x, y] DO BEGIN					icon := 0;					bringsTo := 0;					encounter := 0;					characteristics := standardCharacteristics;					spare := 0;					textToShow := 0;					itemNeeded := 0;					END; { with }		IF MakeGWorld THEN BEGIN			RedrawGWorld;			IF NOT HasColor (currentWorldDepth) THEN				PosterizeGWorld;			DoNewPlace := TRUE			END		ELSE			DoNewPlace := FALSE		END { if user clicked OK on dialog }	ELSE BEGIN		DoNewPlace := FALSE;		DisposePtr (Ptr(placeMap)); { Bug fix 2.0 }		placeMap := NIL		END;END;{$S MkrProcs}FUNCTION DoNewArena: Boolean;VAR	x, y: INTEGER;	standardCharacteristics: BitsInByte;BEGIN	{ Per non settare tutte le caratteristiche booleane una alla volta,	uso un vettore che inizializzo e copio dentro tutte le locazioni }	FOR x := 7 DOWNTO 0 DO		standardCharacteristics[x] := FALSE;	{ PHASE ONE. Init arena data fields }	arenaID := 1000; { Just an ID }	arenaName := 'Untitled'; { Just a name }	arenaX := 10;	arenaY := 8;	arenaPict := 0;	{ PHASE TWO. Customize place info }	IF DoArenaInfoDialog THEN BEGIN		{ PHASE THREE. Setup map }		displayingArena := TRUE;		{ Setup every location in the map }		FOR x := 1 TO arenaX DO			FOR y := 1 TO arenaY DO				WITH arena[x, y] DO BEGIN					icon := 0;					spare := 0;					specs := standardCharacteristics;					END; { with }		DoNewArena := TRUE		END { if user clicked OK on dialog }	ELSE DoNewArena := FALSE;END;END. { Unit }