(*Clindro.v1.00 del 14 luglio 1991Una raccolta di chiamate di utilità generale creata da MisterAkko.Basata su Utilities del 14 febbraio 1991 di MacDTSGotchas: il funzionamento di questa unit si basa sull'esistenza dellerisorse di tipo e contenuto definite all'inizio della sezione CONST!!!1.0.1 del 12 ago 91. Usata in StandardAbout la tecnica di technote 1891.0.2 del 15 ott 91. Aggiunti i Marks, velocizzate le interfacce col toolbox.	Known bugs: StandardAbout genera caratteri spuri nel dialogo di about.	1.1 del 10 settembre 1993: Aggiunto	FindPrefsFolder1.2 del 8 apr 97	Supporto preliminare di Appearance manager	Reso più robusto ErrorAlert che ora può venire chiamato quando stavamo	lavorando in un GWorld	1.5, ferragosto 97.	Appearance compliant.	Aggiunto NewErrorAlert.*)UNIT Cilindro;	INTERFACE		USES			{ List 1 - always include these }			 Types			,QuickDraw;CONST	{ *********** Resource IDs ************** }	rUtilErrorAlert 	= 256;				{ dlg ID used in ErrorAlert }	rStdAboutAlert 	= 257;				{ dlg ID used for About box. }	rUtilStrings		= 256;				{ STR# resource we use for errors. }	rExplainStrings   = 257;				{ STR# resource we use for error explanation }	kStandardErr		= 1;					{ Generic "An error occured" string. }	kNoMenuBar			= 2;					{ Errore 'no menu bar found' per StdMenuSetup}	(************ End ResIDs *****************)		chBackspace 		= CHR(8);			{ ASCII code for Backspace character }	chClear 				= CHR(27);			{ ASCII code for Clear key (aka ESC) }	chDown				= CHR(31);			{ ASCII code for down arrow }	chEnd					= CHR(4);			{ ASCII code for the End key }	chEnter 				= CHR(3);			{ ASCII code for Enter character }	chEscape				= CHR(27);			{ ASCII code for Escape (aka Clear) key }	chFunction			= CHR(16);			{ ASCII code for any function key }	chFwdDelete 		= CHR($7F); 		{ ASCII code for forward delete }	chHelp				= CHR(5);			{ ASCII code for Help key }	chHome				= CHR(1);			{ ASCII code for the Home key }	chLeft				= CHR(28);			{ ASCII code for left arrow }	chPageDown			= CHR(12);			{ ASCII code for Page Down key }	chPageUp				= CHR(11);			{ ASCII code for Page Up key }	chReturn				= CHR(13);			{ ASCII code for Return character }	chRight 				= CHR(29);			{ ASCII code for right arrow }	chSpace 				= CHR(32);			{ ASCII code for Space character }	chTab					= CHR(9);			{ ASCII code for Tab character }	chUp					= CHR(30);			{ ASCII code for up arrow }		{ Define these for gQDVersion }	kQDOriginal			= 0;				{ Original QuickDraw }	kQD8Bit				= 1;				{ 8-bit Color QuickDraw }	kQD32Bit				= 2;				{ 32-bit QuickDraw }VAR{ The following global variables are initialized by StardardInitialization to	define the environnment.  This used to be a single SysEnvRec, but now,	all those variables defined in a SysEnvRec can be returned by Gestalt	(except sysVRefNum; see FindSysFolder).  Note that all the variables	below will be correctly initialized whether Gestalt is available or not;	the Gestalt glue handles this. }	gMachineType:			INTEGER;			{which machine this is}	gSystemVersion:		INTEGER;			{System version number}	gProcessorType:		INTEGER;			{which CPU this is}	gHasFPU:					BOOLEAN;			{true if machine has an FPU}	gQDVersion:				INTEGER;			{major QD version #; 0 for original, 													1 for color QD, 2 for 32-bit QD}	gKeyboardType:			INTEGER;			{which type of keyboard is present}	gAppleTalkVersion:	INTEGER;			{AppleTalk version number}	gHasThemes:				BOOLEAN;			{true if MacOS has the Appearance manager}{ gAppResRef is the application’s resource file reference. I need to save  this since I can open other resource files. The current resource file is  always gAppResRef unless I momentarily set it to another file to read its  resources, and then immediately restore it back.}	gAppResRef: 		INTEGER;			{set up by StandardInitialization}{ gInBackground is maintained by our osEvent handling routines. Any part of  the program can check it to find out if it is currently in the background.}	gInBackground:		BOOLEAN;			{maintained by StandardInitialization and											 event loop}{ gAppName holds the name of the application that's running. You can use if  for any purpose you'd like. It is also used by StandardAbout if it can't  find a string to use for the application name in a resource, so make sure  you call InitForStandardAbout if you are going to call StandardAbout. If you  call StandardInitialization, this is done for you. }	gAppName:			Str255;{ gSignature holds the creator signature for the running application. It follows the  same rules as those for gAppName. }	gSignature:			OSType;{ Initial values of these global variables are set to zero or FALSE by MPW's   runtime initialization routines.  If the Utilities initialization routines  have been properly called, then gUtilitiesInited will be true.  If it is  not true, then the values of the above global variables are invalid. }	gUtilitiesInited:	BOOLEAN;	{ La consueta variabile booleana che segnala quando abbiamo finito }	gQuit: BOOLEAN;PROCEDURE DeathAlert(errStringIndex, errCode: INTEGER);{ Display an alert that tells the user an error occurred, then exit the  program. This routine is used as an ultimate bail-out for serious errors  that prohibit the continuation of the application. Errors that do not  require the termination of the application should be handled in a different  manner. }PROCEDURE ErrorAlert(errStringIndex, errCode: INTEGER);{ Display an alert to inform the user of an error. errStringIndex acts as an  index into a STR# resource of error messages. If no errStringIndex is given,  i.e. = 0, then use a standard message.  BUG NOTE: GetIndString will return a bogus String if the index is not  positive. }PROCEDURE NewErrorAlert (alertType,	errStringIndex,	errorCode: Integer);{ Da usare al posto del vecchio ErrorAlert.Se può, chiama il nuovo StandardAlert di Mac OS 8. Sennò si arrangia con ErrorAlert.alertType vale kAlertStopAlert, kAlertNoteAlert, kAlertCautionAlert o kAlertPlainAlerterrStringIndex è il numero della stringa dentro STR# 256 (messaggio) e 257 (spiegazione)errorCode è il codice Mac OS dell'errore } PROCEDURE ErrorMessage(message: string; errCode: INTEGER);{ Andrebbe usato solo in tempo di debug… }FUNCTION FindSysFolder (VAR foundVRefNum: INTEGER; VAR foundDirID: LongInt): OSErr;{ FindSysFolder returns the (real) vRefNum, and the DirID of the current  system folder.  It uses the Folder Manager if present, otherwise   it falls back to SysEnvirons.  It returns zero on success, otherwise   a standard system error.}FUNCTION	FindPrefsFolder(VAR foundVRefNum:INTEGER; VAR foundDirID: LongInt): OSErr;{ Same for preferences folder }FUNCTION GetGestaltResult (gestaltSelector: OSType): LongInt;{ GetGestaltResult returns the result value from Gestalt for the specified selector.	If Gestalt returned an error GetGestaltResult returns zero.  Use of this function	is only cool if we don't care whether Gestalt returned an error.  In many cases	you may need to know the exact Gestalt error code so then this routine would be	inappropriate.}FUNCTION GetKFreeSpace(vRefNum: INTEGER): LONGINT;{ Return the amount of free space on the volume in KBytes. This builds a  LONGINT based on an unsigned INTEGER, which looks like a negative value to  Pascal.  -1 is returned as the size if there is an error. }PROCEDURE StandardAbout;{ Shows a standard about box with the name of the application, its version  number, a copyright notice, and credits. Most of this information is  taking from a standard DITL and the application’s 'vers' resource. The name  of the application is taken from GetAppParms }PROCEDURE StandardInitialization(callsToMoreMasters: INTEGER);{ Initializes “gInBackGround” to FALSE. Makes the following InitXXX calls:  InitGraf, InitFonts, InitWindows, InitMenus, TEInit, InitDialogs,  InitCursor. Brings application to front with 3 EventAvail calls.   Initializes some variables using Gestalt. Calls TrapExists to initialize  “gHasWaitNextEvent”. }PROCEDURE StandardMenuSetup(MBARID, AppleMenuID: INTEGER);{ Installs and draws the menus indicated by 'MBAR'(MBARID). Adds DA’s to the  menu indicated by AppleMenuID by calling AddResMenu. If the menuBar cannot  be created, the alert specified by rDeathAlert is displayed. }	IMPLEMENTATION		USES			Appearance,			Controls			,Events			,FixMath			,Fonts			,GestaltEqu			{ (3.2) }			,Memory			,Menus,			MixedMode,			OSUtils			,Processes			,QDOffscreen			,Resources			,SegLoad			,TextEdit			,TextUtils			,ToolUtils			{ List 3 - needs List 1/2 types }			,Aliases			{ (3.2) needs Memory }			,Files			,Script			{ needs OSUtils, FixMath }			,Windows			{ needs Events, Controls }			{ List 4 - needs List 1/2/3 types }			,Dialogs			{ needs TextEdit, Windows }			,Folders			{ (3.2) needs Files }			,StandardFile		{ (3.2) needs Aliases }			{ List 5 - needs List 1/2/3/4 types }			,Packages,			{ needs Dialogs, Files, Script, StandardFile (3.2) }						TaskMaster3; { Per DoUpdateStuff }VAR	gFatalDialog: DialogPtr;{$S UtilMain}FUNCTION LockHandleHigh(theHandle: {UNIV} Handle):SignedByte;	BEGIN		LockHandleHigh := HGetState(theHandle);		MoveHHi(theHandle);		HLock(theHandle);	END;{$S UtilMain}PROCEDURE ErrorAlert(errStringIndex, errCode: INTEGER);	VAR		msg1, msg2: 		Str255;		itemHit:			INTEGER;		loopGDevice, oldGHandle: GDHandle;		oldGPort: CGrafPtr;		done: Boolean;			BEGIN		SetCursor(qd.arrow);		IF errStringIndex <= 0 THEN			errStringIndex := kStandardErr;		GetIndString(msg1, rUtilStrings, errStringIndex);		IF errCode = noErr THEN			ParamText(msg1, '-', '', '')		ELSE BEGIN			NumToString(errCode, msg2);			ParamText(msg1, msg2, '', '');			END;					{ se eravamo in un GWorld, casino. Rimediamo }		GetGWorld (oldGport, oldGHandle);		loopGDevice := GetDeviceList;		done := FALSE;		WHILE (loopGDevice <> NIL) AND NOT done DO BEGIN			IF TestDeviceAttribute(loopGDevice, screenDevice) THEN BEGIN				SetGWorld (CGrafPtr(gFatalDialog), loopGDevice);				done := TRUE				END;			loopGDevice := GetNextDevice(loopGDevice);			END;					ShowWindow (gFatalDialog);		SelectWindow (gFatalDialog);		DrawDialog (gFatalDialog);		ModalDialog (NIL,itemHit);		HideWindow (gFatalDialog);		SetGWorld (oldGport, oldGHandle)	END;{$S UtilMain}FUNCTION CilindrosMiniFilterProc (theDialog:  DialogPtr; VAR theEvent:  EventRecord;                   VAR itemHit:  INTEGER) :  BOOLEAN;VAR	result: Boolean;BEGIN	{$UNUSED itemHit}	result := FALSE;						{ Salvo eccezioni, tutto bene }		IF (theEvent.what = updateEvt) AND (theEvent.message <> Longint (theDialog)) THEN		IF TMDoUpdateStuff (WindowPtr (theEvent.message), tmEverything) THEN			result := TRUE; { handled }	CilindrosMiniFilterProc := resultEND;{$S UtilMain}PROCEDURE NewErrorAlert (alertType,	errStringIndex,	errorCode: Integer);CONST	rStandardButtonMsg = 998;	rStandardErrorCodeMsg = 999;VAR	msg1, msg2, errorNumber: Str255;	param: AlertStdAlertParamRec;	myFilter: ModalFilterUPP;	err: OSErr;	dummyHit: Integer;BEGIN	InitCursor;	IF errStringIndex = 0 THEN		errStringIndex := kStandardErr; { Generic error alert }	{ Fetch error msg, explanation, and code text }	GetIndString(msg1, rUtilStrings, errStringIndex);	GetIndString(msg2, rExplainStrings, errStringIndex);	NumToString (errorCode, errorNumber);	IF errorCode <> 0 THEN BEGIN		errorNumber := Concat (chReturn, GetString (rStandardErrorCodeMsg)^^, errorNumber);		msg2 := Concat (msg2, errorNumber)		END;			IF gHasThemes THEN BEGIN		myFilter := NewModalFilterProc (@CilindrosMiniFilterProc);		WITH param DO BEGIN			movable := TRUE;			helpButton := FALSE;			filterProc := myFilter;			defaultText := StringPtr(kAlertDefaultCancelText);			cancelText := NIL;			otherText := NIL;			defaultButton := kAlertStdAlertOKButton;			cancelButton := 0;			position := kWindowDefaultPosition			END;		err := StandardAlert (alertType, @msg1, @msg2, @param, dummyHit);		DisposeRoutineDescriptor (myFilter)		END	ELSE BEGIN		msg1 := Concat (msg1, chReturn, msg2, errorNumber);		ErrorMessage (msg1, errorCode)		ENDEND;{$S UtilMain}PROCEDURE DeathAlert(errStringIndex, errCode: INTEGER);	BEGIN		NewErrorAlert (kAlertStopAlert, errStringIndex, errCode);		ExitToShell	END;	{$S UtilMain}PROCEDURE ErrorMessage(message: string; errCode: INTEGER);	VAR		msg: str255;		itemHit: integer;		loopGDevice, oldGHandle: GDHandle;		oldGPort: CGrafPtr;		done: Boolean;	BEGIN		{ se eravamo in un GWorld, casino. Rimediamo }		GetGWorld (oldGport, oldGHandle);		loopGDevice := GetDeviceList;		done := FALSE;		WHILE (loopGDevice <> NIL) AND NOT done DO BEGIN			IF TestDeviceAttribute(loopGDevice, screenDevice) THEN BEGIN				SetGWorld (CGrafPtr(gFatalDialog), loopGDevice);				done := TRUE				END;			loopGDevice := GetNextDevice(loopGDevice);			END;					NumToString(errCode, msg);		ParamText(message, msg, '', '');		ShowWindow (gFatalDialog);		SelectWindow (gFatalDialog);		DrawDialog (gFatalDialog);		ModalDialog (NIL,itemHit);		HideWindow (gFatalDialog);		SetGWorld (oldGport, oldGHandle)	END;{$S UtilMain}FUNCTION	FindPrefsFolder(VAR foundVRefNum:INTEGER; VAR foundDirID: LongInt): OSErr;	VAR		gesResponse:	LongInt;		envRec:			SysEnvRec;		myWDPB:			WDPBRec;		volName:		Str255;		err:			OSErr;BEGIN	foundVRefNum := 0;	foundDirID := 0;	IF (Gestalt (gestaltFindFolderAttr, gesResponse) = noErr) & 		(BTst (gesResponse, gestaltFindFolderPresent)) THEN { Does Folder Manager exist? }			err := FindFolder (kOnSystemDisk, kPreferencesFolderType, kCreateFolder, 			foundVRefNum, foundDirID)	ELSE BEGIN		{ Gestalt can't give us the answer, so we resort to SysEnvirons }		err := SysEnvirons (curSysEnvVers, envRec);		IF err = noErr THEN BEGIN			myWDPB.ioVRefNum := envRec.sysVRefNum;			volName := '';					{ Zero volume name }			myWDPB.ioNamePtr := @volName;			myWDPB.ioWDIndex := 0;			myWDPB.ioWDProcID := 0;			err := PBGetWDInfoSync (@myWDPB);			IF err = noErr THEN BEGIN				foundVRefNum := myWDPB.ioWDVRefNum;				foundDirID := myWDPB.ioWDDirID				END { if noErr }			END { if sysenvirons worked }		END; { if no folder manager }	FindPrefsFolder := errEND;{$S UtilMain}FUNCTION	FindSysFolder(VAR foundVRefNum:INTEGER; VAR foundDirID: LongInt): OSErr;	VAR		gesResponse:	LongInt;		envRec:			SysEnvRec;		myWDPB:			WDPBRec;		volName:		Str255;		err:			OSErr;	BEGIN		foundVRefNum := 0;		foundDirID := 0;		IF (Gestalt (gestaltFindFolderAttr, gesResponse) = noErr) & 			(BTst (gesResponse, gestaltFindFolderPresent)) THEN BEGIN	{ Does Folder Manager exist? }				err := FindFolder (kOnSystemDisk, kSystemFolderType, kDontCreateFolder, 				foundVRefNum, foundDirID)		END		ELSE BEGIN			{ Gestalt can't give us the answer, so we resort to SysEnvirons }			err := SysEnvirons (curSysEnvVers, envRec);			IF err = noErr THEN BEGIN				myWDPB.ioVRefNum := envRec.sysVRefNum;				volName := '';					{ Zero volume name }				myWDPB.ioNamePtr := @volName;				myWDPB.ioWDIndex := 0;				myWDPB.ioWDProcID := 0;				err := PBGetWDInfoSync (@myWDPB);				IF err = noErr THEN BEGIN					foundVRefNum := myWDPB.ioWDVRefNum;					foundDirID := myWDPB.ioWDDirID				END			END		END;		FindSysFolder := err	END;{$S UtilMain}FUNCTION	GetGestaltResult (gestaltSelector: OSType): LongInt;	VAR		gestaltResult:	LongInt;	BEGIN		IF Gestalt (gestaltSelector, gestaltResult) = noErr THEN			GetGestaltResult := gestaltResult		ELSE			GetGestaltResult := 0	END;	{$S UtilMain}FUNCTION GetKFreeSpace(vRefNum: INTEGER): LONGINT;	TYPE		TwoIntsMakesALong = record case boolean of 			true: (ints: array [0..1] of integer);			false: (long: longint)			end;	VAR		pb: 				HParamBlockRec;		convert:			TwoIntsMakesALong;		err:				OSErr;	BEGIN		WITH pb DO BEGIN							{ set up the block for PBHGetVInfo }			ioNamePtr := NIL;						{ we don't care about the name }			ioVRefNum := vRefNum;			ioVolIndex := 0;						{ use ioVRefNum only }		END;											{ with }		err := PBHGetVInfoSync(@pb);		IF (err = noErr) THEN BEGIN			convert.ints[0] := 0;			convert.ints[1] := pb.ioVFrBlk;			GetKFreeSpace := (convert.long * pb.ioVAlBlkSiz) DIV 1024;		END		ELSE										{ we couldn't get free space size! }			GetKFreeSpace := - 1;	END;	{$S UtilInit}PROCEDURE InitToolBox;	BEGIN		InitGraf(@qd.thePort);		InitFonts;		InitWindows;		InitMenus;		TEInit;		InitDialogs(NIL);		InitCursor;	END;{$S UtilInit}PROCEDURE InitUtilities;{ InitUtilities sets up some global variables for use by the utilities package.  If you call   StandardInitialization. } 	TYPE		OSTypePtr			= ^OSType;	VAR		apParam:			Handle;		bndlResource:		Handle;		BEGIN		gUtilitiesInited := FALSE;		{ Init all the Gestalt variables }		gMachineType := GetGestaltResult (gestaltMachineType);		gSystemVersion := GetGestaltResult (gestaltSystemVersion);		gProcessorType := GetGestaltResult (gestaltProcessorType);		{ We only concern ourselves with there being an FPU, not which type it is }		gHasFPU := (GetGestaltResult (gestaltFPUType) <> gestaltNoFPU);		{ We only concern ourselves with the major QD version number		  0 for original QD, 1 for 8-bit color QD, and 2 for 32-bit QD }		gQDVersion := BAND ((BSR (GetGestaltResult (gestaltQuickdrawVersion), 8)), $FF);		gKeyboardType := GetGestaltResult (gestaltKeyboardType);		gAppleTalkVersion := GetGestaltResult (gestaltAppleTalkVersion);		{ Appearance manager from Mac OS 8? }		gHasThemes := (GetGestaltResult (gestaltAppearanceAttr) <> 0);{$IFC MAC68K}		GetAppParms(gAppName, gAppResRef, apParam);{$ELSEC}{$UNUSED apParam}		gAppName := '';{$ENDC}		bndlResource := GetIndResource('BNDL', 128); { Bug fix 22 aug 96 }		IF (bndlResource <> NIL) THEN			gSignature := OSTypePtr(bndlResource^)^		ELSE			gSignature := '????';					{ Prefetch last chance dialog - it will be there even if out of memory }		gFatalDialog := GetNewDialog (rUtilErrorAlert, NIL, WindowPtr(0));					gQuit := FALSE;		gInBackground := FALSE;		gUtilitiesInited := TRUE;	END;	{$S UtilInit}PROCEDURE PullApplicationToFront;	CONST		kBroughtToFront 	= 3;	VAR		count:				INTEGER;		event:				EventRecord;		ignoreResult:		BOOLEAN;	BEGIN	{ This code is necessary to pull the application into the foreground.  I use	  EventAvail because I don’t want to remove any events the user may have done,	  such as typing ahead.  Until the application has made a few calls (3 seems	  to be the magic number) to the Event Manager, MultiFinder keeps me in the	  background.	Splashscreens and Alerts will remain in a background layer	  until we get a few events.  This is documented in Tech Note #180.}		FOR count := 1 TO kBroughtToFront DO			ignoreResult := EventAvail(everyEvent, event);	END;{$S UtilMain}PROCEDURE StandardAbout;	VAR		apNameHndl:		StringHandle;		versMsgPtr: 	StringPtr;		curVersion: 	VersRecHndl;		apName: 			Str255;		verNum: 			Str255;		itemHit:			INTEGER;	BEGIN		IF NOT gUtilitiesInited THEN			{ make sure we were inititialized }			InitUtilities;		apNameHndl := StringHandle(GetResource(gSignature, 0));		IF (apNameHndl = NIL) THEN			apName := gAppName		ELSE			apName := apNameHndl^^;		{ Per commenti su qs. tecnica vedi technote 189 }		curVersion := VersRecHndl(GetResource('vers', 1));		IF curVersion <> NIL THEN			WITH curVersion^^ DO BEGIN				versMsgPtr := StringPtr(ORD4(@shortVersion[1]) + length (shortVersion));				MoveLeft (versMsgPtr^, verNum, length (versMsgPtr^) + 1);				ReleaseResource (handle(curVersion));				END		ELSE			verNum := '????';						{ at least initialize it }				ParamText(apName, verNum, '', '');		itemHit := Alert(rStdAboutAlert, NIL)	END;											{ StandardAbout }	{$S UtilInit}PROCEDURE StandardInitialization(callsToMoreMasters: INTEGER);	VAR		count:				INTEGER;	BEGIN		InitToolBox;		FOR count := 1 TO callsToMoreMasters DO { allocate master pointer blocks }			MoreMasters;		PullApplicationToFront;		InitUtilities;				IF gHasThemes THEN			gHasThemes := (RegisterAppearanceClient = 0); { New for appearance }	END;											{ StandardInitialization }{$S UtilInit}PROCEDURE StandardMenuSetup(MBARID, AppleMenuID: INTEGER);	VAR		menuBar:			Handle;	BEGIN		menuBar := GetNewMBar(MBARID);		{ read menus into menu bar }		IF menuBar = NIL THEN			DeathAlert(rUtilStrings, kNoMenuBar);		SetMenuBar(menuBar);							{ install menus }		DisposeHandle(menuBar); 					{ E non ReleaseResource! Cfr docs di GetNewMBar }		AppendResMenu(GetMenuHandle(AppleMenuID), 'DRVR'); { add to Apple menu }		DrawMenuBar;	END;													{ StandardMenuSetup }END.