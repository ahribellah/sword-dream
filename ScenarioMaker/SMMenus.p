UNIT SMMenus;INTERFACEUSES	Types,	QuickDraw,	Controls,	Windows,		SMErrors;VAR	gShowPICT,	gGridlines: Boolean; { se true, la mappa è mostrata con griglia }PROCEDURE ThereIsDocOpen;{ Da chiamare quando viene aperto o creato uno scenario }PROCEDURE ThereIsNoDocOpen;{ Da chiamare quando lo scenario aperto viene chiuso }PROCEDURE WindowIsOpen (idOfItsMenu: INTEGER; hasPict: Boolean);{ da chiamare quando viene aperta la finestra di un place o arena. PassarekArenaMenu o kPlaceMenu come parametro. Se è un place ed ha una PICT,passare TRUE al secondo parametro. }PROCEDURE WindowIsClosed (idOfItsMenu: INTEGER);{ Da chiamare quando la finestra di un posto o di un arena viene chiusa }procedure DoCheckItem (myMenu, myItem: integer; check: boolean);(*** Pop up menus in text windows ***)PROCEDURE SMMenusInit;PROCEDURE InitPopUpMenus (theWindow: WindowPtr);PROCEDURE DrawPopUpMenus (myWin: WindowPtr);PROCEDURE HandleClickInTextInfoBar (theControl: ControlHandle; theWindow: WindowPtr);PROCEDURE TextWasChanged (inWhichWin: WindowPtr);IMPLEMENTATIONUSES	Fonts,	Menus,	Palettes,	QuickdrawText,	Script,	TextEdit, 	TextUtils,		Cilindro,	TaskMaster3;{$S MkrProcs}procedure DoCheckItem (myMenu, myItem: integer; check: boolean);var	mh: MenuHandle;begin	mh := GetMenuHandle (myMenu);	if mh = nil THEN		DeathAlert (errMissingApplRes, -192);	CheckItem (mh, myItem, check)end;{$S MkrProcs}PROCEDURE ThereIsDocOpen;VAR	mh: MenuHandle;BEGIN	mh := GetMenuHandle (kFileMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	{ 1. Can't open another, so… }	DisableItem (mh, kNewScenario);	DisableItem (mh, kOpenScenario);	{ 2. Lascialo chiudere in futuro. }	EnableItem (mh, kCheckScenario);	EnableItem (mh, kGrabIcons);	EnableItem (mh, kCloseScenario);	EnableItem (mh, kClose);	EnableItem (mh, kPageSetup);	EnableItem (mh, kPrint);	{ 3. Permetti di manipolare arene e places }	mh := GetMenuHandle (kArenaMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, 0);		mh := GetMenuHandle (kPlaceMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, 0);	mh := GetMenuHandle (kSpecialMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, 0);	DrawMenuBar;END;{$S MkrProcs}PROCEDURE ThereIsNoDocOpen;VAR	mh: MenuHandle;BEGIN	mh := GetMenuHandle (kFileMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, kNewScenario);	EnableItem (mh, kOpenScenario);	DisableItem (mh, kCheckScenario);	DisableItem (mh, kGrabIcons);	DisableItem (mh, kCloseScenario);	DisableItem (mh, kClose);	DisableItem (mh, kPageSetup);	DisableItem (mh, kPrint);	{ 3. Non Permettere di manipolare arene e places }	mh := GetMenuHandle (kArenaMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	DisableItem (mh, 0);		mh := GetMenuHandle (kPlaceMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	DisableItem (mh, 0);	mh := GetMenuHandle (kSpecialMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	DisableItem (mh, 0);	DrawMenuBar;END;{$S MkrProcs}PROCEDURE WindowIsOpen (idOfItsMenu: INTEGER; hasPict: Boolean);VAR	mh: MenuHandle;	otherMenu: INTEGER;BEGIN	mh := GetMenuHandle (idOfItsMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	DisableItem (mh, kNewArena);	DisableItem (mh, kOpenArena);	EnableItem (mh, kCloseArena);	EnableItem (mh, kSaveArena);	EnableItem (mh, kArenaInfo);	EnableItem (mh, kShowArenaStructure);	{ Ora impedisci che si crei un'arena mentre è aperto un place o viceversa }	IF idOfItsMenu = kArenaMenu THEN		otherMenu := kPlaceMenu	ELSE		otherMenu := kArenaMenu;	mh := GetMenuHandle (otherMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	DisableItem (mh, 0);	DrawMenuBar;END;{$S MkrProcs}PROCEDURE WindowIsClosed (idOfItsMenu: INTEGER);VAR	mh: MenuHandle;	otherMenu: Integer;BEGIN	mh := GetMenuHandle (idOfItsMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, kNewArena);	EnableItem (mh, kOpenArena);	DisableItem (mh, kCloseArena);	DisableItem (mh, kSaveArena);	DisableItem (mh, kArenaInfo);	DisableItem (mh, kShowArenaStructure);	{ Ora riabilita il menu gemello (arena se questo è place e viceversa) }	IF idOfItsMenu = kArenaMenu THEN		otherMenu := kPlaceMenu	ELSE		otherMenu := kArenaMenu;	mh := GetMenuHandle (otherMenu);	IF mh = NIL THEN		DeathAlert (kNoMenuBar, 0);	EnableItem (mh, 0);	DrawMenuBar;END;(*** POP UP MENU NELLA INFO BAR DELLE FINESTRE DI TESTO ***)CONST	{ refcon dei menu }	kColor = 134;	kSize = 136;		kSize1 = 9;		kSize2 = 10;		kSize3 = 12;		kSize4 = 14;		kSize5 = 18;	kStyle = 137;	kFont = Longint ('FONT');	kNumColors = 11;	kNumColorsAvailable = kNumColors+5;{ +5 mi da la possibilità		di aumentare il numero di colori semplicemente agendo con ResEdit }VAR	numColors: Integer;	colors: ARRAY [1..kNumColorsAvailable] OF RGBColor; {$S UtilInit}PROCEDURE SMMenusInit;CONST	rMyPalette = 1131;VAR	myColors: PaletteHandle;	i: Integer;BEGIN	myColors := GetNewPalette (rMyPalette);	IF myColors <> NIL THEN BEGIN		numColors := myColors^^.pmEntries;		IF numColors > kNumColorsAvailable THEN			DeathAlert (errTooManyColors, numColors);		FOR i := 1 TO numColors DO			 GetEntryColor (myColors, i, colors [i]);		DisposePalette (myColors);		END;END;{$S MkrProcs}PROCEDURE ShowCorrectColor (popup: ControlHandle; theWin: WindowPtr; c: RGBColor);VAR	theCorrectItem: Integer;		FUNCTION AreTheSame (c1, c2: RGBColor): Boolean;	BEGIN		AreTheSame := (c1.red = c2.red) AND (c1.green = c2.green) AND			(c1.blue = c2.blue)	END; { Color comparison }	BEGIN	theCorrectItem := 1;	WHILE (theCorrectItem <= kNumColorsAvailable) &		NOT AreTheSame(colors[theCorrectItem], c) DO			theCorrectItem := theCorrectItem + 1;	IF theCorrectItem <= kNumColorsAvailable THEN		TMSetWRefCon (theWin, kTMRforColor, theCorrectItem);	{ Questo lo faccio sempre, così al peggio finisco su "altro" }	SetControlValue (popup, theCorrectItem);END;{$S MkrProcs}PROCEDURE ShowCorrectSize (popup: ControlHandle; theWin: WindowPtr; size: Integer);VAR	theCorrectItem,	oldRefCon: Longint;BEGIN	{ Trova vecchio valore }	oldRefcon := TMGetWRefCon (theWin, kTMRforSizeAndFont);	{ Elimina il vecchio codice dimensione }	oldRefcon := BAnd (oldRefcon, $0000FFFF);	CASE size OF		kSize1: theCorrectItem := $10000;		kSize2: theCorrectItem := $20000;		kSize3: theCorrectItem := $30000;		kSize4: theCorrectItem := $40000;		kSize5: theCorrectItem := $50000;		OTHERWISE theCorrectItem := $60000;		END;	IF theCorrectItem < $60000 THEN		TMSetWRefCon (theWin, kTMRforSizeAndFont, theCorrectItem+oldRefCon);	SetControlValue (popup, HiWrd (theCorrectItem));END;{$S MkrProcs}PROCEDURE ShowCorrectStyle (popup: ControlHandle; theWin: WindowPtr; face: Style);VAR	theCorrectItem: Integer;BEGIN	IF face = [] THEN theCorrectItem := 1	ELSE if face = [bold] THEN theCorrectItem := 2	ELSE if face = [italic] THEN theCorrectItem := 3	ELSE if face = [underline] THEN theCorrectItem := 4	ELSE if face = [outline] THEN theCorrectItem := 5	ELSE if face = [shadow] THEN theCorrectItem := 6	ELSE if face = [condense] THEN theCorrectItem := 7	ELSE if face = [extend] THEN theCorrectItem := 8	ELSE theCorrectItem := 9;	SetControlValue (popup, theCorrectItem);	IF theCorrectItem < 9 THEN		TMSetWRefCon (theWin, kTMRforStyle, theCorrectItem);END;{$S MkrProcs}PROCEDURE ShowCorrectFont (popup: ControlHandle; theWin: WindowPtr; font: Integer);VAR	theFontMenu: MenuHandle;	popupInternals: PopupPrivateDataHandle;	i: Integer;	theFontName, anotherFontName: Str255;	oldRefcon: Longint;BEGIN	{ Trova vecchio valore }	oldRefcon := TMGetWRefCon (theWin, kTMRforSizeAndFont);	{ Elimina il vecchio codice font }	oldRefcon := BAnd (oldRefcon, $FFFF0000);	{ Memorizza nuovo codice font se del caso }	IF font > -1 THEN		TMSetWRefCon (theWin, kTMRforSizeAndFont, oldRefcon+font);	{ Dal popup, il menu }	popupInternals := PopupPrivateDataHandle (popup^^.contrlData);	theFontMenu := popupInternals^^.mHandle;	{ Trova la posizione del font prescelto nel menu… }	IF font = -1 THEN		i := 1 { Seleziona il primo item, lo pseudo-font "mixed" }	ELSE BEGIN		GetFontName (font, theFontName);		i := 1;	{ Parti dal secondo, ovvero il primo "buono" }		REPEAT			i := i + 1;			GetMenuItemText (theFontMenu, i, anotherFontName);		UNTIL anotherFontName = theFontName;		END;	{ … e selezionalo }	SetControlValue (popup, i);END;{$S MkrProcs}PROCEDURE InitPopUpMenus (theWindow: WindowPtr);CONST	kFirstPopUp = 134;	kLastPopUp = 137;		kDefaultSize = 10;	{ Standard size for scenario text }	rMixedString = 129; { STR resource with "mixed" }Var	theFontMenu: MenuHandle;	popupInternals: PopupPrivateDataHandle;	i, theFontID: Integer;	theFont: longint;	popUps: ARRAY [kFirstPopUp..kLastPopUp] OF ControlHandle;	fakeFont: StringHandle;	fakeFontCopy: Str255;BEGIN	SetPort (theWindow);	theFont := GetScriptVariable (smSystemScript, smScriptSmallFondSize);	theFontID := HiWrd (theFont);	TextFont (theFontID);	TextSize (LoWrd (theFont));	FOR i := kFirstPopUp TO kLastPopUp DO		popUps[i] := GetNewControl (i, theWindow);	{ Add fake font ("mixed") }	fakeFont := GetString (rMixedString);	popupInternals := PopupPrivateDataHandle (popups[135]^^.contrlData);	theFontMenu := popupInternals^^.mHandle;	IF fakeFont <> NIL THEN BEGIN		fakeFontCopy := fakeFont^^;		InsertMenuItem (theFontMenu, fakeFontCopy, 0);		i := {CountMItems(theFontMenu); } 1;		DisableItem (theFontMenu, i)		END;	{ setup default - size }	ShowCorrectSize (popUps[kSize], theWindow, 10);	{ setup default - style }	ShowCorrectStyle (popUps[kStyle], theWindow, []);	{ setup default - color }	TMSetWRefCon (theWindow, kTMRforColor, 1); { black }	{ setup default - font }	ShowCorrectFont (popUps[135], theWindow, theFontID);END;{$S DefProcs}PROCEDURE DrawPopUpMenus (myWin: WindowPtr);BEGIN	{$UNUSED myWin}	{ Nothing needs to be done. TaskMaster3 will call DrawControls for me }END;{$S MkrProcs}PROCEDURE TextWasChanged (inWhichWin: WindowPtr);VAR	newFont, newSize: Integer;	newStyle: Style;	newColor: RGBColor;	theControls: ControlHandle;		BEGIN	IF TEGetTextStyle (inWhichWin,		newFont, newSize, newStyle, newColor) THEN BEGIN		{ Ritrova i pop up menu }		theControls := WindowPeek (inWhichWin)^.controlList;		WHILE theControls <> NIL DO BEGIN			CASE theControls^^.contrlRfCon OF				kSize: { -1 viene interpretato come 13, e cioé "other" }					ShowCorrectSize (theControls, inWhichWin, newSize);				kStyle: { Style(-1) viene interpretato come [bold, italic] e cioè "mixed" }					ShowCorrectStyle (theControls, inWhichWin, newStyle);				kFont: { -1 viene mappato su un item chiamato "mixed" }					ShowCorrectFont (theControls, inWhichWin, newFont);				kColor: ShowCorrectColor (theControls, inWhichWin, newColor);				END; { case }			theControls := theControls^^.nextControl;			END;		END;END;{$S MkrProcs}PROCEDURE HandleClickInTextInfoBar (theControl: ControlHandle; theWindow: WindowPtr);VAR	menu, voce: Longint;			PROCEDURE ChangeColor (newColorID: Integer);	BEGIN		TMSetWRefCon (theWindow, kTMRforColor, newColorID);		{ Adesso ci pensa TaskMaster }		TESetTextStyle (theWindow, doColor, 1, 1, [], colors[newColorID]);	END;		PROCEDURE ChangeStyle (fontStyleID: Integer);	VAR		fontStyle: Style;	BEGIN		TMSetWRefCon (theWindow, kTMRforStyle, fontStyleID);		CASE fontStyleId OF			1: fontStyle := [];			2: fontStyle := [bold];			3: fontStyle := [italic];			4: fontStyle := [underline];			5: fontStyle := [outline];			6: fontStyle := [shadow];			7: fontStyle := [condense];			8: fontStyle := [extend];			OTHERWISE Exit (ChangeStyle)		END;		{ Adesso ci pensa TaskMaster }		TESetTextStyle (theWindow, doToggle+doFace, 1, 1, fontStyle, colors[1]);	END;		PROCEDURE ChangeFont (newFontID: Integer);	VAR		popupInternals: PopupPrivateDataHandle;		theFontMenu: MenuHandle;		fontName: Str255;		fontID: Integer;		oldRefcon: Longint;	BEGIN		{ Trova vecchio valore }		oldRefcon := TMGetWRefCon (theWindow, kTMRforSizeAndFont);		{ Elimina il vecchio codice font }		oldRefcon := BAnd (oldRefcon, $FFFF0000);		{ Dal popup, il menu }		popupInternals := PopupPrivateDataHandle (theControl^^.contrlData);		theFontMenu := popupInternals^^.mHandle;		{ Dal menu, il nome del font }		GetMenuItemText (theFontMenu, newFontID, fontName);		{ Dal nome del font, il numero del font }		GetFNum (fontName, fontID);		{ memorizza nel refcon il nuovo numero font }		TMSetWRefCon (theWindow, kTMRforSizeAndFont, oldRefcon+fontID);		{ Adesso ci pensa TaskMaster }		TESetTextStyle (theWindow, doFont, fontID, 1, [], colors[1]);	END;		PROCEDURE ChangeSize (fontSizeID: Longint);	VAR		fontSize: Integer; 		oldRefcon: Longint;	BEGIN		{ Trova vecchio valore }		oldRefcon := TMGetWRefCon (theWindow, kTMRforSizeAndFont);		{ Elimina il vecchio codice size }		oldRefcon := BAnd (oldRefcon, $0000FFFF);		{ Memorizza il nuovo codice size }		TMSetWRefCon (theWindow, kTMRforSizeAndFont, BSL(fontSizeID,16)+oldrefCon);		CASE fontSizeID OF			1: fontSize := 9;			2: fontSize := 10;			3: fontSize := 12;			4: fontSize := 14;			5: fontSize := 18;			OTHERWISE Exit (ChangeSize)			END;	{ Adesso ci pensa TaskMaster }	TESetTextStyle (theWindow, doSize, 1, fontSize, [], colors[1]);	END;	BEGIN	SetPort (theWindow);	{ Scopri il suo numero identificativo, stabilito nelle risorse }	menu := GetControlReference (theControl);	{ Scopri il nuovo valore selezionato dall'utente }	voce := GetControlValue (theControl);	{ Reagisci }	CASE menu OF		kColor:			ChangeColor (voce);		kSize:			ChangeSize (voce);		kStyle:			ChangeStyle (voce);		kFont:			ChangeFont (voce);		END;END;END.