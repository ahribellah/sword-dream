UNIT MusicEngine;{ Version 1.0 of Dec 11, 1994 }{ Update 1.0.1, 5 Mar 1995: Coretto per aggiornare agli Universal Headers 2.0a3 }{ Version 2.0, 17 ottobre 1995.Interamente rivisto eliminando gli inline, per compatibilità con powerPC e per Dream II. Eliminato ogni riferimento alla finta unit di interfaccia"Music.c" }INTERFACEUSES	Types,	QuickDraw;FUNCTION QTMusicInit: Boolean;{ Call this first, if it returns true, then music playing is possible }FUNCTION QTMusicPlay (ID: Integer): Integer;{ This is the actual routine to play a 'Musi' resource generated from }{ Midi2Musi. If it returns 0, music play has started.-1: then the resource was not found-2: music could not be played because of memory constraints }PROCEDURE QTMusicStop;{ Call this to stop playback of the current music and release it. }PROCEDURE QTMusicSuspend;{ Should be called on suspend events }FUNCTION QTMusicResume: Integer;{ Same API as QTMusicPlay }{ Should be called on resume events }PROCEDURE QTMusicQuit;{ This will clean up everything, release components, etc... }PROCEDURE QTMusicIdle;{ Call this routine during your idle proc - it checks to see if the }{ music is done playing, and if so, causes it to repeat (don't call }{ this if you don't want your background music to repeat) }FUNCTION GetTP: Longint;{ Quick hack per midi2music }IMPLEMENTATIONUSES	Components,	GestaltEqu,	Memory,	Movies,	Resources,	QuickTimeComponents,	QuickTimeMusic;	CONST		kMusicComponentType = 'musi';	TYPE		(** FORMATO DELLE RISORSE musi ***)				MusicDescription = RECORD				size: LongInt; { including header }				musicType: LongInt; { 'musi' }				resvd1: LongInt; { 0 }				resvd2: Integer;{ 0 }				dataRefIndex: Integer; { 1 }				musicFlags: LongInt; { 0 }				headerData: ARRAY[1..1] OF LongInt; { actually, some sort of tone descriptions }			END;		MusicDescriptionPtr = ^MusicDescription;		MusicDescriptionHandle = ^MusicDescriptionPtr;	VAR		tp: TunePlayer;		theTuneData: MusicDescriptionHandle;		inited: Boolean;{$S UtilInit}FUNCTION QTMusicInit: Boolean;VAR	gestResponse: longint;	err: OSErr;	result: ComponentResult;BEGIN	tp := NIL;	theTuneData := NIL;	inited := FALSE;	err := Gestalt (gestaltQuickTimeVersion, gestResponse);	IF (err = noErr) & (gestResponse>= $02000000) THEN		err := EnterMovies;	IF (err = noErr) & (gestResponse>= $02000000) THEN BEGIN		{ C'è QuickTime 2.0 }		{ open the default tune player }		tp := OpenDefaultComponent(kTunePlayerType, ResType(LongInt(kAnyComponentType)));		IF tp <> NIL THEN BEGIN			{ tell that we have 600 units per second }			result := TuneSetTimeScale(tp, 600);			{ known bug. If I can't set the time to 600 the component stays loaded. }			inited := (result = noErr)			END		END;	{ Return result }	QTMusicInit := initedEND;{$S UtilMain}FUNCTION GetTP: Longint;BEGIN	GetTP := Longint (tp)END;{$S UtilMain}FUNCTION QTMusicPlay (ID: Integer): Integer;CONST	rMidiResource = 'Musi';BEGIN	{ sanity check }	IF inited THEN BEGIN		{ no other music is playing, right? }		IF theTuneData <> NIL THEN			QTMusicStop;		{ load it }		Handle (theTuneData) := GetResource(rMidiResource,ID); 		IF theTuneData = NIL THEN BEGIN			QTMusicPlay := -1;			Exit (QTMusicPlay)			END;				{ prendi nota della handle }		HUnlock (Handle (theTuneData)); { Just in case some fool locked it down }		MoveHHi (Handle (theTuneData));		HLock(Handle(theTuneData));		{ Start playing }		QTMusicPlay := QTMusicResume		ENDEND;{$S UtilMain}PROCEDURE QTMusicQuit;	VAR		err: OSErr;BEGIN	IF inited THEN BEGIN		IF tp <> NIL THEN			QTMusicStop;		IF tp <> NIL THEN			err := CloseComponent(tp);		tp := NIL;		ExitMovies;		inited := FALSE		END;END;{$S UtilMain}PROCEDURE QTMusicStop;BEGIN	IF inited THEN BEGIN		QTMusicSuspend;		IF theTuneData <> NIL THEN BEGIN			ReleaseResource (Handle (theTuneData));			theTuneData := NIL			END;		ENDEND;{$S UtilMain}PROCEDURE QTMusicSuspend;VAR	result: ComponentResult;BEGIN	IF inited THEN BEGIN		result := TuneStop(tp, 0);		result := TuneUnroll (tp)		ENDEND;{$S UtilMain}FUNCTION QTMusicResume: Integer;LABEL	1;VAR	result: ComponentResult;	success: OSErr;	l: LongintPtr;BEGIN	success := noErr;	IF inited THEN BEGIN		{ Set the header, to tell what instruments are used }		result := TuneSetHeader(tp, theTuneData^^.headerData[1]);		IF result <> noErr THEN BEGIN			success := -2;			GOTO 1			END;			{ Have it allocate whatever resources are needed }		result := TunePreRoll(tp);		IF result <> noErr THEN BEGIN			success := -2;			GOTO 1			END;			{ We want to play at normal volume }		result := TuneSetVolume(tp, $10000);		IF result <> noErr THEN BEGIN			success := -3;			GOTO 1			END;			{ Queue up the music, normal tempo, play everything now }		l := LongintPtr (Ord4(theTuneData^) + theTuneData^^.size);		result := TuneQueue(tp, l^, $10000,				0, $7FFFFFFF, kTuneStartNow, NIL, 0);		IF result <> noErr THEN			success := -4;	1:		IF success <> noErr THEN QTMusicQuit;				QTMusicResume := success	ENDEND;{$S UtilMain}PROCEDURE QTMusicIdle;	VAR		result: ComponentResult;		theTuneStatus: TuneStatus;	l: LongintPtr;BEGIN	IF inited and (theTuneData <> NIL) THEN BEGIN		result := TuneGetStatus(tp, theTuneStatus);		WITH theTuneStatus DO			{ If finished… }			IF (result = noErr) & (queueCount = 0) & (tunePtr <> NIL) THEN BEGIN				{ … restart }				l := LongintPtr (Ord4(theTuneData^) + theTuneData^^.size);				result := TuneQueue(tp, l^, $10000,				0, $7FFFFFFF, kTuneStartNow, NIL, 0);				END;		ENDEND;END.