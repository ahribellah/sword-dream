unit	Engine3D_DrawProc;{	Dimensione delle variabili globali:	0	}interfaceuses	quickdraw,	types,	Dream3Display_Tipi;	procedure GetBase;procedure AddObjectInBase (	TheObject :	DisplayObject;							ThePos :	point);							procedure AddLightSource (	ThePoint :	point);implementationuses	icons,	types,	memory,		events, packages, toolutils, segload,	AppleEvents,	AERegistry,			cilindro,	dreamtypes,	Dream3Display_Tools,	Engine3D_Globals;{$S Engine3D_DrawProc}procedure GetBase;var	ThePoint :			DoublePoint;	I,	J,	K,	BaseNOld :			integer;	LightMatrix :		SqMapPtr;	LocalObject,	LocalSquare :		SqMapPtr;	DoublePlaceDim :	integer;	LocalBase :			PolyBaseArrayPtr;	TheElement :		SqElement;		{$S Engine3D_DrawProc}procedure GetPolys (Displace :	DoublePoint;					Square :	SqElement;					Hor :		integer;					Ver :		integer);var	DeltaN :	integer;		{$S Engine3D_DrawProc}procedure SplitFirstNext (	TheCIcon :	integer);var	TheSquare :	SqElement;	LocalBase :	PolyBaseArrayPtr;	begin	LocalBase := Base;	if Square.Next = 0 then begin		LocalBase^ [BaseN].Next := 0;		exit (SplitFirstNext);	end;	BaseLevelsN := BaseLevelsN + 1;	BaseLevels^ [BaseLevelsN] := LocalBase^ [BaseN];	LocalBase^ [BaseN].Next := BaseLevelsN;	TheSquare := GetSqElementInList (Square.Next);	BaseLevels^ [BaseLevelsN].CIcon := TheSquare.SqCIcon [TheCIcon];	while TheSquare.Next <> 0 do begin		BaseLevelsN := BaseLevelsN + 1;		BaseLevels^ [BaseLevelsN] := LocalBase^ [BaseN];		TheSquare := GetSqElementInList (TheSquare.Next);		BaseLevels^ [BaseLevelsN].CIcon := TheSquare.SqCIcon [TheCIcon];		BaseLevels^ [BaseLevelsN - 1].Next := BaseLevelsN;	end;	BaseLevels^ [BaseLevelsN].Next := 0;end;{$S Engine3D_DrawProc}procedure SplitFrontWall;var	dummy :	boolean;	begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		if not (Square.AlwaysFrontal) then begin			with RealCorner [0] do begin				h := Displace.h - Environment.PlaceDim;				v := Displace.v;			end;			with RealCorner [1] do begin				h := Displace.h + Environment.PlaceDim;				v := Displace.v;			end;			PoType := BaseSqElement;			CIcon := Square.SqCIcon [2];		end else begin			RealCorner [0] := Displace;			PoType := BaseSqFrontal;			CIcon := longint (GetCIconOnPtr (Square.SqCIcon [2], false, dummy));		end;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitSideWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitForeLeftWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitBackLeftWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitBackRightWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitForeRightWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitForeTWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitLeftTWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitBackTWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitRightTWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;end;{$S Engine3D_DrawProc}procedure SplitCrossWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		LocalBase^ [BaseN].FullMask := Square.FullMask;		SplitFirstNext (3);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [4];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (4);	end;end;{$S Engine3D_DrawProc}procedure SplitForeLeftDiagonalWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitBackLeftDiagonalWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitBackRightDiagonalWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitForeRightDiagonalWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitForeHalfWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitLeftHalfWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - Environment.PlaceDim;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitBackHalfWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitRightHalfWall;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v;		end;		with RealCorner [1] do begin			h := Displace.h + Environment.PlaceDim;			v := Displace.v;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;{$S Engine3D_DrawProc}procedure SplitRightWallColumn;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + 2;		end;		with RealCorner [1] do begin			h := Displace.h - 3;			v := Displace.v + 2;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - 3;			v := Displace.v + 2;		end;		with RealCorner [1] do begin			h := Displace.h - 3;			v := Displace.v - 2;		end;		CIcon := Square.SqCIcon [4];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (4);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - 3;			v := Displace.v - 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - 2;		end;		CIcon := Square.SqCIcon [5];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (5);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [6];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (6);	end;end;{$S Engine3D_DrawProc}procedure SplitLeftWallColumn;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + 2;		end;		with RealCorner [1] do begin			h := Displace.h + 3;			v := Displace.v + 2;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h + 3;			v := Displace.v - 2;		end;		with RealCorner [1] do begin			h := Displace.h + 3;			v := Displace.v + 2;		end;		CIcon := Square.SqCIcon [4];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (4);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - 2;		end;		with RealCorner [1] do begin			h := Displace.h + 3;			v := Displace.v - 2;		end;		CIcon := Square.SqCIcon [5];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (5);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - 2;		end;		CIcon := Square.SqCIcon [6];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (6);	end;end;{$S Engine3D_DrawProc}procedure SplitRightNiche;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim - 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim - 2;		end;		with RealCorner [1] do begin			h := Displace.h + 6;			v := Displace.v + 6;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h + 6;			v := Displace.v + 6;		end;		with RealCorner [1] do begin			h := Displace.h + 6;			v := Displace.v - 6;		end;		CIcon := Square.SqCIcon [4];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (4);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h + 6;			v := Displace.v - 6;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim + 2;		end;		CIcon := Square.SqCIcon [5];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (5);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim + 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [6];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (6);	end;end;{$S Engine3D_DrawProc}procedure SplitLeftNiche;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim - 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - 6;			v := Displace.v + 6;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v + Environment.PlaceDim - 2;		end;		CIcon := Square.SqCIcon [3];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (3);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - 6;			v := Displace.v - 6;		end;		with RealCorner [1] do begin			h := Displace.h - 6;			v := Displace.v + 6;		end;		CIcon := Square.SqCIcon [4];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (4);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h - 6;			v := Displace.v - 6;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim + 2;		end;		CIcon := Square.SqCIcon [5];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (5);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			h := Displace.h;			v := Displace.v - Environment.PlaceDim + 2;		end;		with RealCorner [1] do begin			h := Displace.h;			v := Displace.v;		end;		CIcon := Square.SqCIcon [6];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (6);	end;end;{$S Engine3D_DrawProc}procedure SplitFloor;beginend;{$S Engine3D_DrawProc}procedure SplitOctaColumn;begin	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v - 2;			h := Displace.h - 1;		end;		with RealCorner [1] do begin			v := Displace.v - 2;			h := Displace.h + 1;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v - 2;			h := Displace.h + 1;		end;		with RealCorner [1] do begin			v := Displace.v - 1;			h := Displace.h + 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v - 1;			h := Displace.h + 2;		end;		with RealCorner [1] do begin			v := Displace.v + 1;			h := Displace.h + 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v + 1;			h := Displace.h + 2;		end;		with RealCorner [1] do begin			v := Displace.v + 2;			h := Displace.h + 1;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v + 2;			h := Displace.h + 1;		end;		with RealCorner [1] do begin			v := Displace.v + 2;			h := Displace.h - 1;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v + 2;			h := Displace.h - 1;		end;		with RealCorner [1] do begin			v := Displace.v + 1;			h := Displace.h - 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v + 1;			h := Displace.h - 2;		end;		with RealCorner [1] do begin			v := Displace.v - 1;			h := Displace.h - 2;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;	BaseN := BaseN + 1;	with LocalBase^ [BaseN] do begin		with RealCorner [0] do begin			v := Displace.v - 1;			h := Displace.h - 2;		end;		with RealCorner [1] do begin			v := Displace.v - 2;			h := Displace.h - 1;		end;		CIcon := Square.SqCIcon [2];		PoType := BaseSqElement;		LocalBase^ [BaseN].FullMask := Square.FullMask;		LocalBase^ [BaseN].Light := LightMatrix^ [Hor, Ver];		SplitFirstNext (2);	end;end;begin	DeltaN := BaseN;	case Square.SqType of		1 :		SplitFrontWall;		2 :		SplitSideWall;		3 :		SplitForeLeftWall;		4 :		SplitBackLeftWall;		5 :		SplitBackRightWall;		6 :		SplitForeRightWall;		7 :		SplitForeTWall;		8 :		SplitLeftTWall;		9 :		SplitBackTWall;		10 :	SplitRightTWall;		11 :	SplitCrossWall;		12 :	SplitForeLeftDiagonalWall;		13 :	SplitBackLeftDiagonalWall;		14 :	SplitBackRightDiagonalWall;		15 :	SplitForeRightDiagonalWall;		16 :	SplitForeHalfWall;		17 :	SplitLeftHalfWall;		18 :	SplitBackHalfWall;		19 :	SplitRightHalfWall;		32 :	SplitLeftNiche;		34 :	SplitRightNiche;		42 :	SplitLeftWallColumn;		44 :	SplitRightWallColumn;		201 :	SplitOctaColumn;		otherwise;	end;end;{$S Engine3D_DrawProc}procedure GetObjPolys (	Displace :	DoublePoint;						Obj :		DisplayObject;						Hor :		integer;						Ver :		integer);{$S Engine3D_DrawProc}procedure SplitObj (Dim :	integer);begin	BaseN := BaseN + 1;	with Base^ [BaseN] do begin		RealCorner [0] := Displace;		RealCorner [1].h := Dim;		PoType := BaseObject;		CIcon := Obj.Id;		Base^ [BaseN].FullMask := false;		if Obj.LightSource then			Light := 3;	end;end;{$S Engine3D_DrawProc}procedure SetLightAround;var	I, J, N :	integer;begin	for N := 1 to NLightValues do		for I := Hor - NLightValues + N to Hor + NLightValues - N do			with Environment do				for J := Ver - NLightValues + N to Ver + NLightValues - N do					if (I in [1..MapHor]) and (J in [1..MapVer]) then						if LightMatrix^ [I, J] < NLightValues then							LightMatrix^ [I, J] := LightMatrix^ [I, J] + 1;end;begin	case Obj.ObType of		1..3 :	SplitObj (Obj.ObType);		otherwise;	end;	if Obj.LightSource then		SetLightAround	else		Base^ [BaseN].Light := LightMatrix^ [Hor, Ver];end;{$S Engine3D_DrawProc}procedure SetLight;var	I, J :	integer;	begin	LightMatrix := SqMapPtr (newptr (sizeof (SqMap)));	if LightMatrix = nil then		deathalert (erroutofmemory, MemError);		for I := 1 to Environment.MapHor do		for J := 1 to Environment.MapVer do			LightMatrix^ [I, J] := Environment.DiffuseLight;end;procedure SplitDoor (		TheElement :	SqElement;						var BaseN :			integer);var	TheDoor :	DoorWallPtr;procedure OpenTheDoor;const	Pi =	3.1415926;var	TheStart,	TheEnd :	DoublePoint;	TheLength :	integer;	begin	if TheElement.SqType = 2 then begin		TheStart := Base^ [BaseN].RealCorner [0];		TheStart.V := TheStart.V - round (TheDoor^.StartBy * 2 * Environment.PlaceDim / 64);		TheLength := round ((TheDoor^.EndBy - TheDoor^.StartBy) * 2 * Environment.PlaceDim / 64);		TheEnd.H := TheStart.H - round (TheLength * sin (TheDoor^.Angle * Pi / 180));		TheEnd.V := TheStart.V - round (TheLength * cos (TheDoor^.Angle * Pi / 180));	end else begin		TheStart := Base^ [BaseN].RealCorner [0];		TheStart.H := TheStart.H + round (TheDoor^.StartBy * 2 * Environment.PlaceDim / 64);		TheLength := round ((TheDoor^.EndBy - TheDoor^.StartBy) * 2 * Environment.PlaceDim / 64);		TheEnd.H := TheStart.H + round (TheLength * cos (TheDoor^.Angle * Pi / 180));		TheEnd.V := TheStart.V - round (TheLength * sin (TheDoor^.Angle * Pi / 180));	end;	Base^ [BaseN].RealCorner [0] := TheStart;	Base^ [BaseN].RealCorner [1] := TheEnd;end;begin	TheDoor := AddDoor (TheElement.RelatedDoor);	if TheDoor^.Open then		Base^ [BaseN].MustIBeShown := false;	TheElement.FullMask := false;	TheElement.SqCIcon [2] := TheDoor^.DoorCIconId;	GetPolys (ThePoint, TheElement, I, J);	if TheDoor^.Open then		Base^ [BaseN].MustIBeShown := true	else		Base^ [BaseN].MustIBeShown := false;	TheElement.SqCIcon [2] := TheDoor^.BorderCIconId;	GetPolys (ThePoint, TheElement, I, J);	if TheDoor^.Open then begin		Base^ [BaseN].MustIBeShown := true;		OpenTheDoor;	end else		Base^ [BaseN].MustIBeShown := false;	with TheDoor^ do begin		CloseTexture := BaseN - 2;		OpenTexture := BaseN - 1;		DoorTexture := BaseN;	end;end;begin	hlock (handle (Environment.SquareMap));	hlock (handle (Environment.ObjectMap));	LocalSquare := Environment.SquareMap^;	LocalObject := Environment.ObjectMap^;		SetLight;	BaseN := 0;	BaseFloorN := 0;	BaseLevelsN := 0;	LocalBase := Base;		DoublePlaceDim := Environment.PlaceDim * 2;	with Environment do begin		for I := 1 to MapHor do			for J := 1 to MapVer do begin				with ThePoint do begin					h := I * DoublePlaceDim - DoublePlaceDim;					v := MapVer * DoublePlaceDim - J * DoublePlaceDim + DoublePlaceDim;				end;				if LocalObject^ [I, J] <> 0 then begin					GetObjPolys (ThePoint, GetObjectInList (LocalObject^ [I, J]), I, J);					LocalBase^ [BaseN].Location.h := I;					LocalBase^ [BaseN].Location.v := MapVer - J;					LocalBase^ [BaseN].MustIBeShown := true;				end;			end;		for I := 1 to MapHor do			for J := 1 to MapVer do begin				with ThePoint do begin					h := I * DoublePlaceDim - DoublePlaceDim;					v := MapVer * DoublePlaceDim - J * DoublePlaceDim + DoublePlaceDim;				end;				if LocalSquare^ [I, J] <> 0 then begin					BaseNOld := BaseN;					TheElement := GetSqElementInList (LocalSquare^ [I, J]);					GetPolys (ThePoint, TheElement, I, J);					for K := BaseNOld + 1 to BaseN do begin						LocalBase^ [K].Location.h := I;						LocalBase^ [K].Location.v := MapVer - J;						if TheElement.Border then							LocalBase^ [K].PoType := 9;						LocalBase^ [K].MustIBeShown := true;					end;					if TheElement.RelatedDoor <> 0 then begin						SplitDoor (TheElement, BaseN);						TheElement.RelatedDoor := DoorN;					end;				end;			end;	end;		for I := 1 to BaseN do begin		LocalBase^ [I].Seen := false;	end;		disposeptr (ptr (LightMatrix));	hunlock (handle (Environment.SquareMap));	hunlock (handle (Environment.ObjectMap));end;{$S Engine3D_DrawProc}function GetBasePoint (	Index :	integer) :	point;begin	GetBasePoint := Base^ [Index].Location;end;{$S Engine3D_DrawProc}function GetLightDistance (	PointA,							PointB :	point) :	integer;		begin	if (PointA.h = PointB.h) and (PointA.v = PointB.v) then begin		GetLightDistance := 3;		exit (GetLightDistance);	end;	if (PointA.h >= PointB.h - 1) and (PointA.h <= PointB.h + 1) and		(PointA.v >= PointB.v - 1) and (PointA.v <= PointB.v + 1) then begin		GetLightDistance := 2;		exit (GetLightDistance);	end;	if (PointA.h >= PointB.h - 2) and (PointA.h <= PointB.h + 2) and		(PointA.v >= PointB.v - 2) and (PointA.v <= PointB.v + 2) then begin		GetLightDistance := 1;		exit (GetLightDistance);	end else		GetLightDistance := 0;end;{$S Engine3D_DrawProc}procedure AddLightSource (	ThePoint :	point);var	I :				integer;	TmpPoint :		point;	LightDistance :	integer;	begin	for I := 1 to BaseN do begin		TmpPoint := GetBasePoint (I);		LightDistance := GetLightDistance (TmpPoint, ThePoint);		if LightDistance <> 0 then begin			Base^ [I].Light := Base^ [I].Light + LightDistance;			if Base^ [I].Light > 3 then				Base^ [I].Light := 3;		end;	end;end;{$S Engine3D_DrawProc}procedure AddObjectInBase (	TheObject :	DisplayObject;							ThePos :	point);var	DoublePlaceDim :	integer;begin	DoublePlaceDim := Environment.PlaceDim * 2;	BaseN := BaseN + 1;	with Base^ [BaseN] do begin		RealCorner [0].h := ThePos.h * DoublePlaceDim - DoublePlaceDim;		RealCorner [0].v := ThePos.v * DoublePlaceDim - DoublePlaceDim;		RealCorner [1].h := TheObject.ObType;		Location := ThePos;		PoType := BaseObject;		CIcon := TheObject.Id;		FullMask := false;		if TheObject.LightSource then			Light := 3		else			Light := 0;	end;end;end.