Unit DreamTypes;{ Definizioni, costanti, variabili e tipi per Dream 2.2 }INTERFACEUses	Types,	QuickDraw;CONST	{ Errori }	errNeedSys7 = 3;	errMissingApplRes = 4;	{ An application resource is missing }	errMissingScenRes = 5;	{ A scenario resource is missing }	errOutOfMemory = 6;	errNoPreferences = 7;	errScenarioTooBig = 8;	errScenarioDamaged = 9;	errCantLoadGame = 10;	errCantSaveGame = 11;	errNeedColor = 12;	errScenarioTooRecent = 13;	errCantDoSound = 14;	errNoBetaPlease = 15;	errLocStackFull = 16;	errSavegameTooRecent = 17;	errDiskIsFull = 18;	errSavegameDamaged = 19;	errChooseAnother = 20;	errFaultySpell = 21;	errCantLoadDB = 22;	errSavegameEmpty = 23;	errUnknownAttackForm = 24;	errUnknownSpecialCode = 25;	errTooManyItems = 26;	errUnknownMdelTarget = 27;	errUnknownMdelAction = 28;	errFileLocked = 29;	errMusicNotFound = 30;	errNoMemoryForMusic = 31;	errUnknownMusicError = 32;	{ Errori non fatali, di cui il gioco avvisa il giocatore }	rAlertMessages = 132;	{ STR# con i messaggi }	kNoCharSelected = 1;	kOverloaded = 2;	kSackFull = 3;	kNoMoney = 4;	kSpellFailed = 5;	kWeaponFailed = 6;	kMatSpellCompMiss = 7;	kNoCharacters = 8;	kMonsterInjected = 9;	kDontUseFood = 10;	kCantSell = 11;	kCantUse = 12;	kMonstersRob = 13;	kPitchBlack = 14;	kCantIdentify = 15;	kCantCastInFight = 16;	kcantCastInPeace = 17;	kTargetIsRightHand = 18;	kCantCastWhenHit = 19;	kWrongKindOfSpell = 20;	kAlreadyKnowsThisSpell = 21;	kDontSaveAsOverOld = 22;	kMonsterDrained = 23;	kRosterFull = 24;	kAmmoUsedUp = 25;	kAmmoMissing = 26;	kItemCursed = 27;	kWontDismiss = 28;	kAlreadyGotHim = 29;	kInTheWall = 30;	{ Suoni }	sndCoin = 128;			{ √ }	sndNewLevel = 129;		{ √ }	sndAttention = 130;		{ √ }	sndImpossible = 131;	{ √ }	sndIll = 132;			{ √ }	sndBell = 133;			{ √ }	sndDiscover = 134;		{ √ }	sndItemUsedUp = 135;	{ √ }	sndClericSpell = 136;	{ √ }	sndBeginFight = 137;	{ √ }	sndEndFight = 138;		{ √ }	sndHit = 139;			{ √ }	sndSoSoHit = 140;		{ √ }	sndMissed = 141;		{ √ }	sndWizardSpell = 142;	{ √ }	sndRebound = 143;		{ √ }	sndPlayerDead = 144;	{ √ }	sndMonsterDead = 145;	{ √ }	sndThrownArrow = 146;	{ √ }	sndSleeps = 147;		{ √ }	sndFlying = 148;		{ √ }	sndSplit = 149;			{ √ }	sndBump = 150;			{ New 1.3 }	{ I menu }	kAppleMenu = 128;		kAboutDream = 1;		kAboutScenario = 2;	kFileMenu = 129;		kOpenGame = 1;		kClose = 2;		kSave = 3;		kSaveAs = 4;		kPageSetup = 6;		kPrint = 7;		kQuit = 9;	kEditMenu = 130;		kUndo = 1;		kCut = 3;		kCopy = 4;		kPaste = 5;	kGameMenu = 150;		kPauseGame = 1;		kSound = 3;		kSpeech = 4;		kTranscript = 5;		kNotification = 6;		kMusic = 7;		kQuickTime = 8;		kShuffleWindows = 10;	kGroupMenu = 151;		kSearch = 1;		kRest = 2;		kFormation = 3;		kWait = 4;		kByS = 6;		kByI = 7;		kByW = 8;		kByD = 9;		kByCo = 10;		kByCh = 11;		kByHP = 12;	kCharMenu = 152;		kCast = 1;		kDismiss = 2;		kShoot = 3;	kFakeMenu = 131;	{ Menu speciali per posti speciali }	kTempleMenu = 132;		kCLW = 1;		kCSW = 2;		kCCW = 3;		kCAW = 4;		kCI = 5;		kCP = 6;		kRestore = 7;		kRaiseDead = 8;		kRemoveCurse = 9;		kAskCleric = 13;	kBarMenu = 134;		kTalk = 1;		kLodge = 2;		kStdRations = 4;		kIronRations = 5;		kLightDrink = 6;		kStrongDrink = 7;		kLeaveChar = 9;		kTakeChar = 10;		kAskRanger = 12;	kBrothelMenu = 135;		kSpendNight = 1;		kRations = 2;		kAskThief = 4;	kBankMenu = 136;		kDeposit = 1;		kAskFighter = 3;	kMageTower = 137;		kComp1 = 1;		kComp2 = 2;		kComp3 = 3;		kComp4 = 4;		kComp5 = 5;		kComp6 = 6;		kComp7 = 7;		kComp8 = 8;		kAskMage = 10;	kShrine = 138;		kPray = 1;		kOffer = 2;		kAskPaladin = 4;	kThreeDMenu = 141;		kHighDetail = 1;		kLowDetail = 2;		kVarDetail = 3;		kClouds = 5;		k3DMipMap = 6;		kLensFlare = 7;	kComp1Menu = 200;	kComp2Menu = 201;	kComp3Menu = 202;	kComp4Menu = 203;	kComp5Menu = 204;	kComp6Menu = 205;	kComp7Menu = 206;	kComp8Menu = 207;	kComp9Menu = 208;		kBuyOne = 1;		kBuyFive = 2;		kBuyTen = 3;	kSpecialMenu = 139;		kTalkStranger = 1;		kJoinStranger = 2;	{ files in Dream }CONST	customGetFileDITL = 250;	{ Custom get file which includes "where is…" string }	fileTypeAppl = 'Drim';	fileTypeScenario = 'ADSc';	fileTypeScenario3D = 'AD3D';	fileTypeSavegame = 'ADGm';	fileTypePreferences = 'ADPf';	fileTypeDB = 'ADdb';		{ New in v1.1 }		resEncounter = 'Nctr';	resMonster = 'Mstr';	resWanderingMonsters = 'Wndr';	resXP = 'XP  ';	resSpellsPerLevel = 'Levl';	resTypeItem = 'Obj ';	resPlace = 'Plac';	resSpell = 'Spel';	resShop = 'Shop';	resArena = 'Aren';	resScenarioInfo = 'Info';	resDesignOrder = 'AdDB';		rOrdersID = 1000;	resScenList = 'Scen';		rScenListID = 1000;	resMonsterBrain = 'MDeL';	resTrap = 'Trap';	resCharacter = 'Char';	resNPCMenu = 'Menu';	resRiddle = 'Ridl';	CONST(*** Version identifiers ***)	{ Questi numeri sono usati da DreamIO per capire se un savefile è leggibile,	e da DoLoadScenario per capire se uno scenario è compatibile }	kCurrentDreamVersion = 220;				{ v 2.2 }	kCurrentFileFormatVersion = 210;		{ v1.2 added customizable icons													v1.3 adds NPCs													v1.3.1 adds more spells in memory													v2.0 stores character window settings													v2.1 uses a different KindOfAttack enum }	kMinimumFileFormatUnderstood = 90;	kGreatestFileFormatUnderstood = 219;	{ v 2,1,9 }	(*** Strings ***)CONST	{ User interface strings (status line, shop interface, etc }	rUserIntfStrings = 128;	{ STR# also used in DreamIO.p }		kClickToBrowse = 1;		kCanBeYoursFor = 2;		kGoldenEagles = 3;		kPromptString = 4;		kUntitledName = 5;		kQuitting = 6;		kLoadingNewGame = 7;		kGameIsStopped = 8;		kTargetChar = 9;		kTargetMonster = 10;		kTargetArena = 11;			{ Miscellaneous strings }	rMiscStrings = 129;		rStrName = 1;		rStrAlignment = 2;		rStrClass = 3;		rStrXP = 5;		rStrLevel = 4;		rStrAC = 8;		rStrHP = 6;		rStrHPOutOf = 7;		rStrWeight = 9;		rStrHeight = 12;		rStrWA = 11;		rStrload = 10;		rStrRace = 13;		rStrHuman = 14;		rStrElf = 15;		rStrDwarf = 16;		rStrGnome = 17;		rStrHalfelf = 18;		rStrHobbit = 19;		rStrValue = 20;		rStrS = 21;		rStrI = 22;		rStrW = 23;		rStrD = 24;		rStrCo = 25;		rStrCh = 26;		rStrAge = 27;		rStrGP = 28;		rStrNextXP = 29;		rStrDead = 30;		rStrPoisoned = 31;		rStrIll = 32;		rStrEncumbered = 33;		rStrDosesLeft = 34;		rPaladinWontJoin = 35;		rPaladinWillLeave = 36;		rOn = 37;		rLightbringer = 38;		rOff = 39;		rHighPriest = 40;		rBurnedOut = 41;		rStrWield = 42;		rStrFist = 43;		rStrAfterTheFall = 44;		rStrMoneyGained = 45;		rStrStoned = 46;		rStrClone = 47;		rItmIs = 48;		rItmUnknown = 49;		rItmMagic = 50;		rItmWeapon = 51;		rItmThrown = 52;		rItmArmor = 53;		rItmAmmo = 54;		rItmLightSource = 55;		rItmRechargeable = 56;		rItmCursed = 57;		rItmIntelligent = 58;		rItmFood = 59;		rItmScroll = 60;		rItmSplittable = 61;		rItmBook = 62;		rItmMap = 63;		rItmLastAttribute = rItmMap;		rItmKept = 64;		{ Posizioni: 65..71}		rItmLastPos = 71;		rItmUsable = 72;		rItmUnavailable = 73;		rItmMark = 74;		rItmDivider = 75;		rItmNothingSpecial = 76;		rBarmanStrings = 136;		rGoodByeCustomers = 1;		rGoAwayNoMoney = 2;		rThatllBe = 3;		rGEOnly = 4;	{ Transcript strings }	rTranscriptMessages = 134;	ktMovesNW = 7;	ktMovesN = 8;	ktMovesNE = 9;	ktMovesW = 4;	ktMovesE = 6;	ktYouStay = 5;	ktMovesSW = 1;	ktMovesS = 2;	ktMovesSE = 3;	ktYouEntered = 10;	ktCasts = 11;	ktMisses = 12;	ktIsHit = 13;	ktIsClobbered = 14;	ktIsHealed = 15;	ktIsPoisoned = 16;	ktIsDrained = 17;	ktIsDead = 18;	ktTheGroup = 19;	ktRests = 20;	ktSearchesThePlace = 21;	ktFindsSomething = 22;	ktEarns = 23;	ktGP = 24;	ktXP = 25;	ktIsDismissed = 26;	ktFindsNothing = 27;	ktJoins = 28;	ktHP = 29;	ktUses = 30;	ktDons = 31;	ktTakesOff = 32;	ktOneDayHasPassed = 33;	ktStarves = 34;	ktDoesntRest = 35;	ktIsUnableToMove = 36;	ktFlees = 37;	ktBuys = 38;	ktGrabs = 39;	ktSells = 40;	ktDrops = 41;	ktChangesFormation = 42;	ktHearsMonsters = 43;	ktNewLevel = 44;	ktSpellFailed = 45;	ktWeaponRebounded = 46;	ktLightIsOff = 47;	ktLearnsSpell = 48;	ktPlayerStalls = 49;	ktSaves = 50;	ktSavesForHalf = 51;	ktVanishes = 52;	ktExpires = 53;	ktGetsIll = 54;	ktIsCured = 55;	ktIsRestored = 56;	ktIsResurrected = 57;	ktIsSlowed = 58;	ktIsHasted = 59;	ktGroupPrays = 60;	ktPaladinIsNear = 61;	ktPaladinEyesYou = 62;	ktOffersGold = 63;	ktNoPaladinNearby = 64;	ktWaits = 65;	ktWontWait = 66;	ktIsFriend = 67;	ktNodsAndGoes = 68;	ktTremblesAndSniffs = 69;	ktWontResurrect = 70;	ktIsStoned = 71;	ktIsFleshed = 72;	ktFlies = 73;	ktIsGrounded = 74;	ktTurnsOff = 75;	ktDisarmsTrap = 76;	ktSpringsTrap = 77;	ktThankYou = 78;{ Name of preferences file }rDreamPrefsFile = 128;(*** Low level type definitions ***)TYPE	BitsInByte = PACKED ARRAY [0..7] OF Boolean;	BitsInWord = PACKED ARRAY [0..15] OF Boolean;	{ Risultato delle operazioni di I/O }	IoResult = (failedAbort, userCancel, failedRetry, failedContinue, allRight);(*** Stack of locations visited ***)CONST	{ maximum number of places in the places stack }	kMaxPlacesOnStack = 10;TYPE	TLocationStackItem = RECORD		x, y: INTEGER;		placeID: INTEGER;		from: Char			{ direzione dalla quale viene }		END;	TLocationStack = ARRAY [1..kMaxPlacesOnStack] OF TLocationStackItem;(*** Entities ***)CONST	kMaxCharInUI = 7;		{ Max num PC nella main window (zero-based) }	kNPCReference = 8;	kNoPCSelected = -1;Type	EntityRef = kNoPCSelected..kNPCReference;	{ Is normally 0 to 7.	-1 means "nobody", 8 is the extra character (ally or prisoner) }(*** Places ***)CONST	{ Maximum size of a place }	kMaxWorldH = 95;	kMaxWorldW = 95;TYPE	SpecialPlace = (Temple, Shop, Bar, Brothel,		Bank, MageTower, Shrine, Prison,		Standard,		ThreeD {New for v2,0}		);	MapLocation = PACKED RECORD		icon: integer;		bringsTo: integer;		encounter: integer;	{ Also used for trap ID }		characteristics: BitsInByte;			{ [7] is impassable,			[6] search is required to have the encounter			[5] Is Trapped (new for v1.1)			[4] Has Riddle (new for v1.3)			[3] Has dialog (new for v2.0)			[2] Has 3D event (new for v2.0)			[0] I have been there }		spare: Byte;		textToShow: Integer;		itemNeeded: Integer;		END;	Map =  PACKED ARRAY [1..kMaxWorldW*kMaxWorldH] of MapLocation;	MapPtr = ^Map;(*	I PULSANTI:		Tutti i pulsanti hanno come refCon il loro stesso resourceID. Questo mi		permette di identificarli quando sono premuti.		I pulsanti che stanno in finestre grigio chiaro hanno una speciale tabella dei		colori che li armonizza.		Il tutto è stabilito nelle risorse.*)(*** Shop ***)CONST	kMaxItemsInshop = 50;	{ Max numero di oggetti in una risorsa Shop }	{ Quando siamo dentro un negozio, al posto della mappa appare la lista degli oggetti	in vendita, e questi bottoni }	rButtonBuy = 132;	rButtonExit = 133;	rButtonTake = 134;	rButtonEnough = 135;	rButtonGetInfo = 136;		{ Solo con Mac OS 8.0 e superiori }	rTriangle = 500;	{ Disclosure triangle nella finestra dei personaggi }	rTabs = 501;		{ Tabs nella character window }	{ Alert }CONST	rDismissAlert = 128;	{ Sei certo di voler cacciare il tipo? }	rBuyNSellAlert = 131;	{ Usato quando non riesce a comprar qualcosa }	rSpellAlert = 132;		{ Usato quando non riesce a fare un incantesimo }	rDreamAlert = 133;		{ Usato negli altri casi }	rPaladinAlert = 135;	{ Il paladino ha qualcosa da dire! }	rScreenDepthAlert = 136;{ Change the screen depth, you cretin! }	rTooManyPCsAlert = 137;	{ There are already as many PCs as the scenario will support… }	rJoinItemsAlert = 138;	{ Join the rechargeable items or split them? }	rTooFewPCsAlert = 139;	rBarmanAlert = 140;		{ Talk to the barman }	rTooManyPCsAtSwitch = 141;	rSwitchScenAlert = 146;	{ Scenario switch }	rDontRevertToSaved = 255;	rAlertWriteProtected = 157;(* Le finestre in Dream.	Tutte le finestre non modali sono definite come WIND, e non come DLOG, in	conformità alla TN "Don't abuse the managers".	Le finestre modali definite come DLOG sono solo quelle per la creazione del	personaggio e quelle per la memorizzazione e il casting di un incantesimo.	Le finestre mantengono nel campo refCon il cursore della entità cui si riferiscono.	REFCON 1:		Main window = 100		Arena window = 101		Text windoid = 102		Transcript windoid = 103		Un personaggio = 110			Refcon 2: ID personaggio (indice del vettore Mondo)			refcon 3: Handle (TPersonaggio)			refcon 4: pagina a cui è aperta la schheda		Un item = 111			refcon 3: Handle (TItem)*)CONST	kMainWindowRefCon = 100;	kArenaWindowRefCon = 101;	kTextWindoidRefCon = 102;	kTranscriptWindoidRefCon = 103;	kHandicappedHelper = 104; { Mouse instead of keypad - to be done }	kPictWindoidRefCon = 105;	kSharewareNoticeWindow = 106;	kCharacterRefCon = 110;		kRefConForID = 2;		kRefConForHandle = 3;		kRefConForPage = 4;	kItemRefCon = 111;CONST	{ Colori usati nelle finestre dei personaggi }	rLightGrayPpat = 128;	{ Sfondo per finestre; XP da conquistare }	rGreenPpat = 129;		{ Hit points rimasti }	rRedPpat = 130;			{ Hit points persi }	rDarkGrayPpat = 131;	{ XP conquistati }{ Main window }CONST	rMainWindow = 128;	kStatusLineHeight = 16;	kIconWidth = 64;	kIconHeight = 64;	kMWTop = 0;	kMWLeft = 3 + kIconWidth; 			{ Sono le pos. del rect dove										è disegnata la mappa }	kMainWindowMinHeight = 96; 			{ 3 icone }	kMainWindowMinWidth = kMWLeft + 96; { roster + spazio divisorio + 3 icone}	kThreeDDisplayWidth = 320;	kThreeDDisplayHeight = 200;	kThreeDMapWidth = kThreeDDisplayWidth;	kThreeDMapHeight = 200;		kBottomSpaceForButtons = 31;			{ Quando mostriamo uno shop }{ Character window }CONST	rShowChar = 130;	rCharWindow = 130;	kCWHeight = 393;		{ Più la info bar }	kCWWidth = 255;		kCWInfoBarHeight = 44;	kCWTopOfFreeSpace = 35;	{ Margine alto dello spazio utilizzabile nella finestra }	kCWOffsetToIcons = 5;	{ Spazio tra il bordo e la prima icona }{ Item window }	rItemWindow = 129;	kIWHeight = 300;	kIWWidth = 256;	rButtonUse = 128;	{ ID dei pulsanti "Use", "Sell" e "Drop" della finestra oggetto }	rButtonSell = 129;	rButtonDrop = 130;	rButtonIdentify = 131;	rButtonCast = 137;	rButtonSplit = 138;	{ Arena window }CONST 	maxLocX = 14;	maxLocY = 12;	maxLocArena = maxLocX*maxLocY;TYPE	ArenaLocation = PACKED RECORD		icon: INTEGER;		specs: BitsInByte;			{ [7] is impassable			[6] is unholy			[5] is holy			[4] slows			[3] is antimagic			}		spare: Byte		END;{ Windoids }CONST	rPictWindow = 132;	rTextWindow = 131;	rTranscriptWindow = 133;	kStandardWindoidWidth = 300; { Comprende la scrollbar }{ Dialogs }	rNewCharDlog = 135;	{ DLOG per InitChar }	resSpellLearnDialog = 130;	{ Dialog per l'apprendimento di spell }		kUndoLearn = 3;		kMove = 4;		kBookList = 5;		kMayLearnList = 6;		kIconUserItem = 7;		kNumSpellsToLearn = 9;	{ Static text col num. di inc. da imparare }		kLastItem = kMayLearnList;	resRefillSpellDialog = 142;		kRSBookList = 2;		kRSMindList = 3;		kRSCharIcon = 4;		kRSNumSpells = 5;		kRSLastItem = kRSNumSpells;	{ Special items (material components etc.), sold in special places	whose description is part of the dream application resFork }CONST	kItmHolyWater = 128;	kItmAmber = 129;	kItmBatGuano = 130;	kItmGlassLens = 132;	kItmMagnet = 133;	kItmMushRoom = 134;	kItmQuickSilver = 135;	kItmMirror = 136;	kItmIronRations = 138;	kItmRations = 200;	kItmCurePotion = 201;(*** MDeL - new for v1.1 ***)TYPE	MonsterMove = PACKED RECORD	spare, action: Char;		(* 1..9: Move in specified direction			0:	Stand still			M:	Move towards adversary or fight if possible				Direct: alignment of chosen foe, or						10+class of chose foe, or						20+serial id of foe (zero-based)						30+serial id of companion (zero-based), or						98: weakest foe						99: nearest foe						100: myself			K:	Cast spell				Direct: Spell ID				Indirect: Target (same codes as "M")			I:	IA makes decision			S:	Say something				Direct: TEXT ID			F:	Flee from specified subject				Direct: Target (same codes as "H")				OTHER MONSTER OR ITSELF IS UNSUPPORTED *)	direct, indirect: Integer	END;	{ One of those may be associated to a monster }	MDeLHandle = ^MDeLPtr;	MDeLPtr = ^MonsterDecisionList;	MonsterDecisionList = ARRAY [1..32767] OF MonsterMove;(*** Spells ***)CONST	kMaxSpellLevel = 7;		{ Gli spell sono divisi per livelli, dal primo al settimo }	kMaxSpellInMemory = 40;	{ Al massimo 40 spell in memoria IN TUTTO }	kMaxKnownSpells = 50;	{ Max storage space inside a character for known spells }	kCasterLevelForItems = 12;	{ Livello dello spellcaster quando è un item }	kSpelSpecialPaladin = 128;	{ New for v 1.6 }	kSpelIdentifyAll = 221;	kSpelCureGraze = 301;	kSpelCureWound = 323;	kSpelCureGash = 340;	kSpelCureAll = 360;	kSpelCureIllness = 310;	kSpelCurePoison = 320;	kSpelRestore = 330;	kSpelRemoveCurse = 341;	kSpelRaise = 350;	rNameOfDBFile = 129;	{ ID of STR resource with name of Dream DB file }	rNameOfTempFile = 130;	{ ID of STR resource with name of temp file }TYPE	TSpellInfoHdl = ^TSpellInfoPtr;	TSpellInfoPtr = ^TSpellInfo;	TSpellInfo = RECORD		id, icon: Integer;		name: String [30];		next: TSpellInfoHdl		END;		{ Struttura data usata in Dream 1.1 per memorizzare tutti gli spell esistenti.	Il settore "false" viene usato per gli incantesimi da mago, "true" per chierico	(stessa convenzione usata all'interno degli Spel) }	AllSpellsTable = ARRAY [1..kMaxSpellLevel, FALSE..TRUE] OF TSpellInfoHdl;(*** AD&D Types ***)CONST	kMaxCharLevel = 36;		{ Massimo livello di abilità consentito }TYPE	{ Banalità standard da AD&D. Tipi utilizzati nella definizione delle	creature e dei personaggi in particolare. }	TAllineamento = (LE, NE, CE, CN, NNN, LN, CG, NG, LG); {TN è definito dal toolbox }	TRazza = (Umano, Elfo, Nano, Gnomo, NonUmanoide);	Sesso = (Maschio, Femmina);	TClasse = (Combattente, Ranger, Paladino, Ladro, Chierico, Mago, Mostro);		{ Mostro serve per le funzioni come CalcTHACO }	Livello = 1..kMaxCharLevel;	Eta = 14..2000;	Peso = 30..200;	Altezza = 100..220;	Caratteristica = 3..18;	Superforza = 0..100;	Storage = (Testa, Corpo, Cintura, ManoDx, Fodero, ManoSx,		Sacco1, Sacco2, Sacco3, Sacco4, Sacco5, Sacco6);	HPArray = ARRAY [Livello] of 0..10;	NumSpellsArray = ARRAY [1..kMaxSpellLevel] OF Integer;	MemorizedSpellsArray = ARRAY [1..kMaxSpellInMemory] OF INTEGER;	KnownSpellsArray = ARRAY [1..kMaxKnownSpells] OF INTEGER;	{ Status di una creatura }	(* v 1.x definition	OneStatus = (IsIll, IsStoned, IsFlying, IsInvisible, SeesInvisible,		IsBig, rs6, rs7, IsDead, rs9, rs10, rs11, rs12, rs13, rs14, rs15);	CreatureStatus = SET OF OneStatus;		v2.1 definition - Aggiungo IsPC per risolvere alcune incertezze nel FightingSystem *)	OneStatus = (rs15, rs14, rs13, rs12, rs11, rs10, rs9, IsDead, rs7, IsPC,		IsBig, SeesInvisible, IsInvisible, IsFlying, IsStoned, IsIll);	CreatureStatus = PACKED ARRAY [rs15..IsIll] OF Boolean;(* V1.x definition	SuperPowers -	Nei set gli item sono conservati nel bit di numero	uguale all'ord dell'elemento (cioé in ordine inverso rispetto	all'enumerato. 	ResEdit, con i BBIT, assegna i bit dal più significativo in ordine di	apparizione (se è settato il primissimo BBIT ottengo $8000000...)	KindOfAttack = (r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,		Illness, Curse, Special, DeathMagic, Missile,		WeaponPlusFive, WeaponPlusFour, WeaponPlusThree, WeaponPlusTwo,		WeaponPlusOne, Weapon, MagicEnergy, LevelDrain, TurnToStone,		Acid, Poison, Healing, Electricity, Frost, Fire, MindAttack);	PowerSet = SET OF KindOfAttack;		CONTENUTO DELLA MEMORIA QUANDO SI SETTANO I COMPONENTI	DI UN PACKED ARRAY [1..32] OF BOOLEAN, UNO ALLA VOLTA,	[1 true, gli altri false]: $0100 0000	[2 true, gli altri false]: $0200 0000	[3 true, gli altri false]: $0400 0000	[4 true, gli altri false]: $0800 0000	[5 true, gli altri false]: $1000 0000	...	[8 true, gli altri false]: $8000 0000	[9 true, gli altri false]: $0001 0000		PER QUESTO MOTIVO, MENTRE L'ORDINE NATURALE DOVREBBE ESSERE...	KindOfAttack = (MindAttack, Fire, Frost, Electricity, Healing, Poison, Acid, TurnToStone,		LevelDrain, MagicEnergy, Weapon, WeaponPlusOne, WeaponPlusTwo, WeaponPlusThree, WeaponPlusFour, WeaponPlusFive,		Missile, DeathMagic, Special, Curse, Illness,  r10, r9, r8,		r7, r6, r5, r4, r3, r2, r1, r0);CONST	kFirstAttack = MindAttack;	kLastAttack = r0;TYPE	PowerSet = PACKED ARRAY [kFirstAttack..kLastAttack] OF BOOLEAN;			IO DOVRo' INVECE SCRIVERE...*)(* V 2.1 definition *)	KindOfAttack = (TurnToStone, Acid, Poison, Healing,		Electricity, Frost, Fire, MindAttack,		WeaponPlusFive, WeaponPlusFour, WeaponPlusThree, WeaponPlusTwo,		WeaponPlusOne, Weapon, MagicEnergy, LevelDrain,		r8, r9, r10, Illness,		Curse, Special, DeathMagic, Missile,		r0, r1, r2, r3, r4, r5, r6, r7);CONST	kFirstAttack = TurnToStone;	kLastAttack = r7;	kFirstWeapon = WeaponPlusFive; { In caso di modifica, ritoccare TItem.grab }	kLastWeapon = Weapon;TYPE	PowerSet = PACKED ARRAY [kFirstAttack..kLastAttack] OF BOOLEAN;	{ Area d'effetto di un incantesimo }	AttackArea =	(Caster,			{ Per esempio Light }					Individual,			{ Per esempio Cure Light Wound }					OneMonster,			{ Per esempio un colpo di spada }					AllGroup,					AllMonsters,					RoundArea,			{ Per esempio Fireball }					SquareArea,			{ Per esempio Ice Storm }					StraightBolt		{ Per esempio Lightining }					); { Se ne aggiungo rivedere SpellCheck}	{ Azioni possibili a un mostro in ordine di aggressività }	MonsterAction = (Panic, Friend, Group, Stand, Flank, Fight);		{	Panic: fuggo lontano dal gruppo;			Fight: attacco un avversario 			Flank: cerco di circondare il gruppo (solo average intelligence)			Group: cerco di stare unito ai miei simili (solo low intelligence)			Stand: cerco di stare fermo dove sono per difendere chi mi sta dietro					(solo average intelligence)			Friend: cerco di aiutare una creatura che ha il mio stesso allineamento					(solo high intelligence)		}		MonsterMemory = RECORD		action: MonsterAction;		whom: Integer			{ Sarebbe EntityRef, ma -1 vale "chiunque" }		END;	(*** Resources ***)CONST	rEncounterTreasure = 128;	{ Fake "Plac", used for dispatching the treasure			items found after a fighting }	resFormation = 128;			{ Special fake "encounter" for setting up battle formation }	rScenarioInfo = 1000;		{ Must be inside scenario and tell of requirements }	rGroupIconWhenOut = 133;	rGroupIconWhenLarge = 134;	rGroupIconWhenIn = 136;		{ New for v2.0 }	rFirstSilhouette = 128; { For use with GetIndNrect }	{ GetIndNrect (rFirstSilhouette+ord (classe), ord(storage)) }	kChosenWeaponSpace = ord (Sacco6)+1; { For use with GetIndNrect }IMPLEMENTATIONEND.